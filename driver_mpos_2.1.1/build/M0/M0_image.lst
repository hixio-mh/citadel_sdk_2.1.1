
/home/paulkim/work/sdk/citadel/driver_mpos_2.1.1/build/M0/M0_image.out:     file format elf32-littlearm

SYMBOL TABLE:
30010000 l    d  .text	00000000 .text
30011de8 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 M0_common.c
00000000 l    df *ABS*	00000000 M0_tamper.c
00000000 l    df *ABS*	00000000 M0_usb.c
00000000 l    df *ABS*	00000000 ihost_config.c
00000000 l    df *ABS*	00000000 M0_wakeup_body.c
30010558 l     F .text	000000dc MCU_ultra_low_power_exit
30010634 l     F .text	00000030 citadel_power_on_IO_ring
30010664 l     F .text	0000003c citadel_power_on_usb
00000000 l    df *ABS*	00000000 M0_aon_gpio.c
00000000 l    df *ABS*	00000000 M0_mbox_entry.c
00000000 l    df *ABS*	00000000 M0_wfi.c
00000000 l    df *ABS*	00000000 M0_rtc.c
00000000 l    df *ABS*	00000000 M0_fastxip.c
00000000 l    df *ABS*	00000000 M0_mbox_body.c
30010fe4 l     F .text	00000028 crmu_cfg_xtal_pwr_off
3001100c l     F .text	00000030 citadel_power_off_IO_ring
00000000 l    df *ABS*	00000000 M0_smbus.c
00000000 l    df *ABS*	00000000 M0_wakeup_entry.c
300115f8 g     F .text	00000008 mcu_clrbit
30011868 g     F .text	00000098 MCU_setup_aongpio
300102dc g     F .text	0000027c ihost_config
30010b00 g     F .text	0000007c MCU_SoC_Wakeup_Handler
30011828 g     F .text	00000014 MCU_set_irq_user_vector
300117f0 g     F .text	00000010 MCU_clear_event
30011800 g     F .text	00000014 MCU_send_msg_to_mproc
30010e10 g     F .text	00000064 m0_aon_phy0_resume_handler
30010804 g     F .text	00000228 citadel_deep_sleep_exit
300117e0 g     F .text	00000010 MCU_check_event
30010100 g     F .text	00000100 m0_tamper_handler
30011400 g     F .text	00000064 m0_issue_ds_cmd
3001103c g     F .text	0000001c MCU_SoC_do_policy
30011788 g     F .text	00000010 MCU_check_irq
30010f50 g     F .text	00000094 user_fastxip_workaround
300113a0 g     F .text	00000060 m0_smb_slave_rx_fifo_read
30010a2c g     F .text	000000d4 MCU_get_valid_aon_gpio_wakeup_interrupt
30011058 g     F .text	0000000e MCU_SoC_Run_Handler
30011b94 g     F .text	00000254 user_wakeup_handler
300106a2 g     F .text	00000162 citadel_DRIPS_exit
3001161c g     F .text	0000001c cpu_reg32_wr_mask
3001164a g     F .text	00000014 MCU_memcpy
30011608 g     F .text	00000008 cpu_reg32_clr_masked_bits
30011a04 g     F .text	0000009c bbl_read_reg
30011464 g     F .text	00000178 m0_smbus_handler
30011aa0 g     F .text	00000010 MCU_bbl_access_ok
30011600 g     F .text	00000008 cpu_reg32_set_masked_bits
30011b00 g     F .text	00000048 MCU_setup_rtc
30011de8 g     O .bss	00000004 rd_data
300117a8 g     F .text	00000014 MCU_get_event
30011ac4 g     F .text	0000000a spru_reg_write
30010c60 g     F .text	00000154 user_mbox_handler
30011708 g     F .text	0000003c MCU_timer_raw_delay
30011798 g     F .text	00000010 MCU_clear_irq
30011278 g     F .text	00000128 MCU_SoC_DeepSleep_Handler
30011638 g     F .text	00000012 MCU_memset
300116c4 g     F .text	00000044 MCU_timer_udelay
3001165e g     F .text	0000002e MCU_delay
30011950 g     F .text	00000024 spru_interface_reset
3001106a g     F .text	0000020e MCU_SoC_DRIPS_Handler
300117bc g     F .text	00000024 MCU_enable_event
30011066 g     F .text	00000004 MCU_SoC_Sleep_Handler
30011744 g     F .text	0000000c MCU_get_soc_rev
30010e74 g     F .text	000000dc m0_rtc_handler
30011900 g     F .text	00000050 MCU_setup_usb
30011ace g     F .text	00000032 MCU_setup_tamper
3001168e g     F .text	00000036 MCU_get_timer_count
30011b48 g     F .text	0000004c MCU_setup_wakeup_src
300106a0 g     F .text	00000002 citadel_sleep_exit
30011750 g     F .text	00000014 MCU_get_irq
30010000 g     O .text	00000084 m0_isr_vector
3001183c g     F .text	0000002c MCU_set_pdsys_master_clock_gating
30011974 g     F .text	00000090 bbl_write_reg
30011764 g     F .text	00000024 MCU_enable_irq
3001168c g     F .text	00000002 MCU_die
300115e6 g     F .text	0000000a mcu_getbit
300115f0 g     F .text	00000008 mcu_setbit
30010db4 g     F .text	0000005c m0_wfi_handler
300115dc g     F .text	0000000a MCU_SYNC
30011814 g     F .text	00000014 MCU_send_msg_to_mcu
30010b7c g     F .text	000000e4 m0_aon_gpio_handler
30011610 g     F .text	0000000c cpu_reg32_wr_masked_bits
30010200 g     F .text	000000dc m0_usb_handler
30011ab0 g     F .text	00000014 spru_reg_read



Disassembly of section .text:

30010000 <m0_isr_vector>:
	...
30010008:	7d 0b 01 30 00 00 00 00 00 00 00 00 00 00 00 00     }..0............
30010018:	65 14 01 30 00 00 00 00 00 00 00 00 00 00 00 00     e..0............
	...
3001003c:	01 02 01 30 00 00 00 00 00 00 00 00 00 00 00 00     ...0............
	...
30010068:	01 01 01 30 75 0e 01 30 75 0e 01 30 00 00 00 00     ...0u..0u..0....
30010078:	b5 0d 01 30 61 0c 01 30 51 0f 01 30 00 00 00 00     ...0a..0Q..0....
	...

30010100 <m0_tamper_handler>:
 * NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
 ******************************************************************************/
#include "M0.h"

__attribute__ ((interrupt ("IRQ"))) int m0_tamper_handler(void)
{
30010100:	b5f0      	push	{r4, r5, r6, r7, lr}
30010102:	b085      	sub	sp, #20
#ifdef MPROC_PM_USE_TAMPER_AS_WAKEUP_SRC
	s32_t ret = 0;
	u32_t irq_handled = 0;
	CITADEL_PM_ISR_ARGS_s *pm_args = CRMU_GET_PM_ISR_ARGS();
	MPROC_PM_MODE_e cur_pm_state = pm_args->tgt_pm_state;
30010104:	4b39      	ldr	r3, [pc, #228]	; (300101ec <m0_tamper_handler+0xec>)
30010106:	791c      	ldrb	r4, [r3, #4]
#ifdef MPROC_PM__ADV_S_POWER_OFF_PLL
	MPROC_PM_MODE_e prv_pm_state = pm_args->prv_pm_state;
30010108:	795e      	ldrb	r6, [r3, #5]

/* Memory mapped registers I/O functions */

static inline u32_t sys_read32(mem_addr_t addr)
{
	return *(volatile u32_t *)addr;
3001010a:	4b39      	ldr	r3, [pc, #228]	; (300101f0 <m0_tamper_handler+0xf0>)
3001010c:	681b      	ldr	r3, [r3, #0]
3001010e:	4b39      	ldr	r3, [pc, #228]	; (300101f4 <m0_tamper_handler+0xf4>)
30010110:	681d      	ldr	r5, [r3, #0]
	/* Put some default wake up Code 1 */
	u32_t wakeup_msg_code1 = MAILBOX_CODE1__WAKEUP_TEST;

	MCU_SET_STATE_IN_WAKEUP_ENTRY_C();

	MCU_memset((void *)&wakeup_code, 0, sizeof(MPROC_PM_WAKEUP_CODE_s));
30010112:	2210      	movs	r2, #16
30010114:	2100      	movs	r1, #0
30010116:	4668      	mov	r0, sp
30010118:	f001 fa8e 	bl	30011638 <MCU_memset>

	/* SPRU Alarm event */
	if (event_status & BIT(MCU_SPRU_ALARM_EVENT)) {
3001011c:	016b      	lsls	r3, r5, #5
3001011e:	d402      	bmi.n	30010126 <m0_tamper_handler+0x26>

OK_exit: /* NO VALID WAKEUP interrupt occurs, direct return */
	MCU_SET_STATE_IN_WAKEUP_ENTRY_C();
#endif
	return 0;
}
30010120:	2000      	movs	r0, #0
30010122:	b005      	add	sp, #20
30010124:	bdf0      	pop	{r4, r5, r6, r7, pc}
		tamper_timestamp  = spru_reg_read(BBL_TAMPER_TIMESTAMP);
30010126:	2020      	movs	r0, #32
30010128:	f001 fcc2 	bl	30011ab0 <spru_reg_read>
3001012c:	0005      	movs	r5, r0
		tamper_src_stat   = spru_reg_read(BBL_TAMPER_SRC_STAT);
3001012e:	2028      	movs	r0, #40	; 0x28
30010130:	f001 fcbe 	bl	30011ab0 <spru_reg_read>
30010134:	0007      	movs	r7, r0
		tamper_src_stat_1 = spru_reg_read(BBL_TAMPER_SRC_STAT_1);
30010136:	2034      	movs	r0, #52	; 0x34
30010138:	f001 fcba 	bl	30011ab0 <spru_reg_read>
		if (tamper_src_stat || tamper_src_stat_1) {
3001013c:	003b      	movs	r3, r7
3001013e:	4303      	orrs	r3, r0
30010140:	d002      	beq.n	30010148 <m0_tamper_handler+0x48>
			wakeup_code.info.tamper.time = tamper_timestamp;
30010142:	9501      	str	r5, [sp, #4]
			wakeup_code.info.tamper.src  = tamper_src_stat;
30010144:	9702      	str	r7, [sp, #8]
			wakeup_code.info.tamper.src1 = tamper_src_stat_1;
30010146:	9003      	str	r0, [sp, #12]
		wakeup_code.wakeup_src       = ws_tamper;
30010148:	231a      	movs	r3, #26
3001014a:	466a      	mov	r2, sp
3001014c:	7013      	strb	r3, [r2, #0]
	if (cur_pm_state == MPROC_PM_MODE__DEEPSLEEP
3001014e:	1f63      	subs	r3, r4, #5
30010150:	2b01      	cmp	r3, #1
30010152:	d918      	bls.n	30010186 <m0_tamper_handler+0x86>
	MCU_memcpy((void *)&pm_args->wakeup, (void *)&wakeup_code,
30010154:	2210      	movs	r2, #16
30010156:	4669      	mov	r1, sp
30010158:	4827      	ldr	r0, [pc, #156]	; (300101f8 <m0_tamper_handler+0xf8>)
3001015a:	f001 fa76 	bl	3001164a <MCU_memcpy>
	ret = MCU_SoC_Wakeup_Handler(cur_pm_state, prv_pm_state, wakeup_msg_code0, wakeup_msg_code1);
3001015e:	2311      	movs	r3, #17
30010160:	4a26      	ldr	r2, [pc, #152]	; (300101fc <m0_tamper_handler+0xfc>)
30010162:	0031      	movs	r1, r6
30010164:	0020      	movs	r0, r4
30010166:	f000 fccb 	bl	30010b00 <MCU_SoC_Wakeup_Handler>
	if (!ret) {
3001016a:	2800      	cmp	r0, #0
3001016c:	d105      	bne.n	3001017a <m0_tamper_handler+0x7a>
		if (cur_pm_state > MPROC_PM_MODE__SLEEP)
3001016e:	2c04      	cmp	r4, #4
30010170:	d837      	bhi.n	300101e2 <m0_tamper_handler+0xe2>
		MCU_send_msg_to_mcu(MAILBOX_CODE0__NOTHING,
30010172:	2100      	movs	r1, #0
30010174:	2000      	movs	r0, #0
30010176:	f001 fb4d 	bl	30011814 <MCU_send_msg_to_mcu>
	if (cur_pm_state < MPROC_PM_MODE__DEEPSLEEP)
3001017a:	2c05      	cmp	r4, #5
3001017c:	d8d0      	bhi.n	30010120 <m0_tamper_handler+0x20>
		MCU_setup_wakeup_src(MPROC_EXIT_LP);
3001017e:	2000      	movs	r0, #0
30010180:	f001 fce2 	bl	30011b48 <MCU_setup_wakeup_src>
30010184:	e7cc      	b.n	30010120 <m0_tamper_handler+0x20>
			tamper_src_stat = spru_reg_read(BBL_TAMPER_SRC_STAT);
30010186:	2028      	movs	r0, #40	; 0x28
30010188:	f001 fc92 	bl	30011ab0 <spru_reg_read>
			spru_reg_write(BBL_TAMPER_SRC_CLEAR, 0xffffffff);
3001018c:	2501      	movs	r5, #1
3001018e:	426d      	negs	r5, r5
30010190:	0029      	movs	r1, r5
30010192:	202c      	movs	r0, #44	; 0x2c
30010194:	f001 fc96 	bl	30011ac4 <spru_reg_write>
			spru_reg_write(BBL_TAMPER_SRC_CLEAR, 0x0);
30010198:	2100      	movs	r1, #0
3001019a:	202c      	movs	r0, #44	; 0x2c
3001019c:	f001 fc92 	bl	30011ac4 <spru_reg_write>
			tamper_src_stat_1 = spru_reg_read(BBL_TAMPER_SRC_STAT_1);
300101a0:	2034      	movs	r0, #52	; 0x34
300101a2:	f001 fc85 	bl	30011ab0 <spru_reg_read>
			spru_reg_write(BBL_TAMPER_SRC_CLEAR_1, 0xffffffff);
300101a6:	0029      	movs	r1, r5
300101a8:	2038      	movs	r0, #56	; 0x38
300101aa:	f001 fc8b 	bl	30011ac4 <spru_reg_write>
			spru_reg_write(BBL_TAMPER_SRC_CLEAR_1, 0x0);
300101ae:	2100      	movs	r1, #0
300101b0:	2038      	movs	r0, #56	; 0x38
300101b2:	f001 fc87 	bl	30011ac4 <spru_reg_write>
			MCU_enable_event(MCU_SPRU_ALARM_EVENT,	0);
300101b6:	2100      	movs	r1, #0
300101b8:	201a      	movs	r0, #26
300101ba:	f001 faff 	bl	300117bc <MCU_enable_event>
			if (cur_pm_state == MPROC_PM_MODE__DEEPSLEEP)
300101be:	2c06      	cmp	r4, #6
300101c0:	d1c8      	bne.n	30010154 <m0_tamper_handler+0x54>
				MCU_clear_event(MCU_SPRU_ALARM_EVENT);
300101c2:	201a      	movs	r0, #26
300101c4:	f001 fb14 	bl	300117f0 <MCU_clear_event>
	MCU_memcpy((void *)&pm_args->wakeup, (void *)&wakeup_code,
300101c8:	2210      	movs	r2, #16
300101ca:	4669      	mov	r1, sp
300101cc:	480a      	ldr	r0, [pc, #40]	; (300101f8 <m0_tamper_handler+0xf8>)
300101ce:	f001 fa3c 	bl	3001164a <MCU_memcpy>
	ret = MCU_SoC_Wakeup_Handler(cur_pm_state, prv_pm_state, wakeup_msg_code0, wakeup_msg_code1);
300101d2:	2311      	movs	r3, #17
300101d4:	4a09      	ldr	r2, [pc, #36]	; (300101fc <m0_tamper_handler+0xfc>)
300101d6:	0031      	movs	r1, r6
300101d8:	2006      	movs	r0, #6
300101da:	f000 fc91 	bl	30010b00 <MCU_SoC_Wakeup_Handler>
	if (!ret) {
300101de:	2800      	cmp	r0, #0
300101e0:	d19e      	bne.n	30010120 <m0_tamper_handler+0x20>
			pm_args->tgt_pm_state = MPROC_PM_MODE__RUN_200;
300101e2:	2202      	movs	r2, #2
300101e4:	4b01      	ldr	r3, [pc, #4]	; (300101ec <m0_tamper_handler+0xec>)
300101e6:	711a      	strb	r2, [r3, #4]
300101e8:	e7c3      	b.n	30010172 <m0_tamper_handler+0x72>
300101ea:	46c0      	nop			; (mov r8, r8)
300101ec:	30010000 	.word	0x30010000
300101f0:	30024050 	.word	0x30024050
300101f4:	3002405c 	.word	0x3002405c
300101f8:	30010040 	.word	0x30010040
300101fc:	11223344 	.word	0x11223344

30010200 <m0_usb_handler>:
 * NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
 ******************************************************************************/
#include "M0.h"

__attribute__ ((interrupt ("IRQ"))) int m0_usb_handler(void)
{
30010200:	b5f0      	push	{r4, r5, r6, r7, lr}
30010202:	b085      	sub	sp, #20
	s32_t ret = 0;
	u32_t irq_handled = 0;
	CITADEL_PM_ISR_ARGS_s *pm_args = CRMU_GET_PM_ISR_ARGS();
	MPROC_PM_MODE_e cur_pm_state = pm_args->tgt_pm_state;
30010204:	4b2d      	ldr	r3, [pc, #180]	; (300102bc <m0_usb_handler+0xbc>)
30010206:	791e      	ldrb	r6, [r3, #4]
#ifdef MPROC_PM__ADV_S_POWER_OFF_PLL
	MPROC_PM_MODE_e prv_pm_state = pm_args->prv_pm_state;
30010208:	795f      	ldrb	r7, [r3, #5]
#else
	MPROC_PM_MODE_e prv_pm_state = MPROC_PM_MODE__END;
#endif

	u32_t usb_wakeup = pm_args->usb_settings.wakeup_src;
3001020a:	699d      	ldr	r5, [r3, #24]
3001020c:	4b2c      	ldr	r3, [pc, #176]	; (300102c0 <m0_usb_handler+0xc0>)
3001020e:	681b      	ldr	r3, [r3, #0]
30010210:	4b2c      	ldr	r3, [pc, #176]	; (300102c4 <m0_usb_handler+0xc4>)
30010212:	681c      	ldr	r4, [r3, #0]
	/* Put some default wake up Code 1 */
	u32_t wakeup_msg_code1 = MAILBOX_CODE1__WAKEUP_TEST;

	MCU_SET_STATE_IN_WAKEUP_ENTRY_C();

	MCU_memset((void *)&wakeup_code, 0, sizeof(MPROC_PM_WAKEUP_CODE_s));
30010214:	2210      	movs	r2, #16
30010216:	2100      	movs	r1, #0
30010218:	4668      	mov	r0, sp
3001021a:	f001 fa0d 	bl	30011638 <MCU_memset>

	/* USB intr from valid src */
	if((event_status & BIT(MCU_USBPHY0_WAKE_EVENT))
	|| (event_status & BIT(MCU_USBPHY0_FILTER_EVENT))
	|| (event_status & BIT(MCU_USBPHY1_WAKE_EVENT))
	|| (event_status & BIT(MCU_USBPHY1_FILTER_EVENT))) {
3001021e:	23f0      	movs	r3, #240	; 0xf0
30010220:	021b      	lsls	r3, r3, #8
	if((event_status & BIT(MCU_USBPHY0_WAKE_EVENT))
30010222:	421c      	tst	r4, r3
30010224:	d03a      	beq.n	3001029c <m0_usb_handler+0x9c>
		MCU_SET_STATE_IN_WAKEUP_ENTRY_C();
		irq_handled = 1;

		/* TODO: Should this wake-up be on all 4 USB events? */

		if(event_status & BIT(MCU_USBPHY0_WAKE_EVENT))
30010226:	04e3      	lsls	r3, r4, #19
30010228:	0fdb      	lsrs	r3, r3, #31
			usb_status |= BIT(MPROC_USB0_WAKE);
		if(event_status & BIT(MCU_USBPHY0_FILTER_EVENT))
3001022a:	04a2      	lsls	r2, r4, #18
3001022c:	d501      	bpl.n	30010232 <m0_usb_handler+0x32>
			usb_status |= BIT(MPROC_USB0_FLTR);
3001022e:	2202      	movs	r2, #2
30010230:	4313      	orrs	r3, r2
		if(event_status & BIT(MCU_USBPHY1_WAKE_EVENT))
30010232:	0462      	lsls	r2, r4, #17
30010234:	d501      	bpl.n	3001023a <m0_usb_handler+0x3a>
			usb_status |= BIT(MPROC_USB1_WAKE);
30010236:	2204      	movs	r2, #4
30010238:	4313      	orrs	r3, r2
		if(event_status & BIT(MCU_USBPHY1_FILTER_EVENT))
3001023a:	0422      	lsls	r2, r4, #16
3001023c:	d501      	bpl.n	30010242 <m0_usb_handler+0x42>
			usb_status |= BIT(MPROC_USB1_FLTR);
3001023e:	2208      	movs	r2, #8
30010240:	4313      	orrs	r3, r2
		valid_usb_intr = usb_wakeup & usb_status;
30010242:	402b      	ands	r3, r5

		/* In RUN mode */
		if (cur_pm_state < MPROC_PM_MODE__SLEEP) {
30010244:	2e03      	cmp	r6, #3
30010246:	d92c      	bls.n	300102a2 <m0_usb_handler+0xa2>
		} else /*In LP mode*/ {
			/* 1. First check none-wakeup USB
			 * interrupt, don't return
			 */
			/* 2. Last check valid wakeup USBs interrupt */
			if (valid_usb_intr) {
30010248:	2b00      	cmp	r3, #0
3001024a:	d027      	beq.n	3001029c <m0_usb_handler+0x9c>
				if ((MCU_WAKEUP_SOURCE & BIT(USBPHY_WAKE_EVENT))) {
					u32_t i = 0;
					MCU_SET_STATE_IN_WAKEUP_ENTRY_C();
					wakeup_code.wakeup_src = ws_usb;
3001024c:	220f      	movs	r2, #15
3001024e:	4669      	mov	r1, sp
30010250:	700a      	strb	r2, [r1, #0]
					wakeup_code.info.usbno.usbno = valid_usb_intr;
30010252:	9301      	str	r3, [sp, #4]
					/* Pick the first USB event that has caused this wake-up
					 * and prepare code1 of the mailbox message.
					 */
					for(i = 0; i < MPROC_USB_END; i++) {
						if(valid_usb_intr & BIT(i)) {
30010254:	07da      	lsls	r2, r3, #31
30010256:	d429      	bmi.n	300102ac <m0_usb_handler+0xac>
30010258:	2401      	movs	r4, #1
3001025a:	2001      	movs	r0, #1
3001025c:	0019      	movs	r1, r3
3001025e:	40e1      	lsrs	r1, r4
30010260:	4208      	tst	r0, r1
30010262:	d124      	bne.n	300102ae <m0_usb_handler+0xae>
					for(i = 0; i < MPROC_USB_END; i++) {
30010264:	3401      	adds	r4, #1
30010266:	2c04      	cmp	r4, #4
30010268:	d1f8      	bne.n	3001025c <m0_usb_handler+0x5c>
	u32_t wakeup_msg_code1 = MAILBOX_CODE1__WAKEUP_TEST;
3001026a:	4c17      	ldr	r4, [pc, #92]	; (300102c8 <m0_usb_handler+0xc8>)
		|| cur_pm_state == MPROC_PM_MODE__DRIPS) {
		MCU_SET_STATE_IN_WAKEUP_ENTRY_C();
	}

	/* Copy back wakeup details */
	MCU_memcpy((void *)&pm_args->wakeup, (void *)&wakeup_code,
3001026c:	2210      	movs	r2, #16
3001026e:	4669      	mov	r1, sp
30010270:	4816      	ldr	r0, [pc, #88]	; (300102cc <m0_usb_handler+0xcc>)
30010272:	f001 f9ea 	bl	3001164a <MCU_memcpy>
			   sizeof(MPROC_PM_WAKEUP_CODE_s));

	/* Do wakeup */
	ret = MCU_SoC_Wakeup_Handler(cur_pm_state, prv_pm_state, wakeup_msg_code0, wakeup_msg_code1);
30010276:	0023      	movs	r3, r4
30010278:	4a15      	ldr	r2, [pc, #84]	; (300102d0 <m0_usb_handler+0xd0>)
3001027a:	0039      	movs	r1, r7
3001027c:	0030      	movs	r0, r6
3001027e:	f000 fc3f 	bl	30010b00 <MCU_SoC_Wakeup_Handler>
	MCU_SET_STATE_IN_WAKEUP_ENTRY_C();

	/* Clear mailbox values, this will trigger
	 * a mbox interrupt again
	 */
	if (!ret) {
30010282:	2800      	cmp	r0, #0
30010284:	d108      	bne.n	30010298 <m0_usb_handler+0x98>
		 * falling edge intr
		 * will reset A7 again.
		 *
		 * Can't we make this rising edge only?
		 */
		if (cur_pm_state > MPROC_PM_MODE__SLEEP)
30010286:	2e04      	cmp	r6, #4
30010288:	d902      	bls.n	30010290 <m0_usb_handler+0x90>
			pm_args->tgt_pm_state = MPROC_PM_MODE__RUN_200;
3001028a:	2202      	movs	r2, #2
3001028c:	4b0b      	ldr	r3, [pc, #44]	; (300102bc <m0_usb_handler+0xbc>)
3001028e:	711a      	strb	r2, [r3, #4]

		MCU_send_msg_to_mcu(MAILBOX_CODE0__NOTHING,
30010290:	2100      	movs	r1, #0
30010292:	2000      	movs	r0, #0
30010294:	f001 fabe 	bl	30011814 <MCU_send_msg_to_mcu>
		MAILBOX_CODE1__NOTHING);
	}

	if (cur_pm_state < MPROC_PM_MODE__DEEPSLEEP)
30010298:	2e05      	cmp	r6, #5
3001029a:	d90a      	bls.n	300102b2 <m0_usb_handler+0xb2>
	return 0;

OK_exit: /* NO VALID WAKEUP interrupt occurs, direct return */
	MCU_SET_STATE_IN_WAKEUP_ENTRY_C();
	return 0;
}
3001029c:	2000      	movs	r0, #0
3001029e:	b005      	add	sp, #20
300102a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
			MCU_send_msg_to_mproc(MAILBOX_CODE0__USB_INTR_IN_RUN,
300102a2:	490c      	ldr	r1, [pc, #48]	; (300102d4 <m0_usb_handler+0xd4>)
300102a4:	480c      	ldr	r0, [pc, #48]	; (300102d8 <m0_usb_handler+0xd8>)
300102a6:	f001 faab 	bl	30011800 <MCU_send_msg_to_mproc>
			goto OK_exit;
300102aa:	e7f7      	b.n	3001029c <m0_usb_handler+0x9c>
					for(i = 0; i < MPROC_USB_END; i++) {
300102ac:	2400      	movs	r4, #0
							wakeup_msg_code1 = MAILBOX_CODE1__WAKEUP_USB0_WAKE + i;
300102ae:	340c      	adds	r4, #12
							break;
300102b0:	e7dc      	b.n	3001026c <m0_usb_handler+0x6c>
		MCU_setup_wakeup_src(MPROC_EXIT_LP);
300102b2:	2000      	movs	r0, #0
300102b4:	f001 fc48 	bl	30011b48 <MCU_setup_wakeup_src>
300102b8:	e7f0      	b.n	3001029c <m0_usb_handler+0x9c>
300102ba:	46c0      	nop			; (mov r8, r8)
300102bc:	30010000 	.word	0x30010000
300102c0:	30024050 	.word	0x30024050
300102c4:	3002405c 	.word	0x3002405c
300102c8:	44332211 	.word	0x44332211
300102cc:	30010040 	.word	0x30010040
300102d0:	11223344 	.word	0x11223344
300102d4:	77003300 	.word	0x77003300
300102d8:	22005500 	.word	0x22005500

300102dc <ihost_config>:
 * @param None
 *
 * @return N/A
 */
void ihost_config(void)
{
300102dc:	b530      	push	{r4, r5, lr}
	register u32_t lock, lock_status;

	/* 2] PLL Power up
	 * b] Turn on PLL LDO/PWR
	 */
	WrReg(A7_CRM_PLL_PWR_ON,0xB);
300102de:	220b      	movs	r2, #11
300102e0:	4b6d      	ldr	r3, [pc, #436]	; (30010498 <ihost_config+0x1bc>)
300102e2:	601a      	str	r2, [r3, #0]

	/* Wait for 50us before removing PLL ISO */
	timer_wait(IHOST_PLL_PWRON_WAIT);
300102e4:	4b6d      	ldr	r3, [pc, #436]	; (3001049c <ihost_config+0x1c0>)
300102e6:	3a09      	subs	r2, #9
300102e8:	601a      	str	r2, [r3, #0]
300102ea:	496d      	ldr	r1, [pc, #436]	; (300104a0 <ihost_config+0x1c4>)
300102ec:	4a6d      	ldr	r2, [pc, #436]	; (300104a4 <ihost_config+0x1c8>)
300102ee:	6011      	str	r1, [r2, #0]
300102f0:	2101      	movs	r1, #1
300102f2:	4a6d      	ldr	r2, [pc, #436]	; (300104a8 <ihost_config+0x1cc>)
300102f4:	6011      	str	r1, [r2, #0]
300102f6:	2282      	movs	r2, #130	; 0x82
300102f8:	601a      	str	r2, [r3, #0]
300102fa:	4a6c      	ldr	r2, [pc, #432]	; (300104ac <ihost_config+0x1d0>)
300102fc:	6813      	ldr	r3, [r2, #0]
300102fe:	2b00      	cmp	r3, #0
30010300:	d0fc      	beq.n	300102fc <ihost_config+0x20>
30010302:	2300      	movs	r3, #0
30010304:	2200      	movs	r2, #0
	 * Turn on switches bit by bit 
	 */
	/* Weak switch programming */
	spare3 = 0x0;
	for (spare4 = 0x0; spare4 <= 0x7; spare4++) {
		spare3 |= (1 << spare4);
30010306:	2501      	movs	r5, #1
		WrRegField(IHOST0_CONFIG_ROOT, A7_CRM_PWRON_IN_DOMAIN_4,
30010308:	24ff      	movs	r4, #255	; 0xff
3001030a:	4869      	ldr	r0, [pc, #420]	; (300104b0 <ihost_config+0x1d4>)
		spare3 |= (1 << spare4);
3001030c:	0029      	movs	r1, r5
3001030e:	4099      	lsls	r1, r3
30010310:	430a      	orrs	r2, r1
		WrRegField(IHOST0_CONFIG_ROOT, A7_CRM_PWRON_IN_DOMAIN_4,
30010312:	0021      	movs	r1, r4
30010314:	4011      	ands	r1, r2
30010316:	6001      	str	r1, [r0, #0]
	for (spare4 = 0x0; spare4 <= 0x7; spare4++) {
30010318:	3301      	adds	r3, #1
3001031a:	2b08      	cmp	r3, #8
3001031c:	d1f6      	bne.n	3001030c <ihost_config+0x30>
			PWRON_IN_DOMAIN_4_VECTOR, spare3);
	}

	/* Strong switch programming */
	WrRegField(IHOST0_CONFIG_ROOT, A7_CRM_PWROK_IN_DOMAIN_4,
3001031e:	22ff      	movs	r2, #255	; 0xff
30010320:	4b64      	ldr	r3, [pc, #400]	; (300104b4 <ihost_config+0x1d8>)
30010322:	601a      	str	r2, [r3, #0]
		PWROK_IN_DOMAIN_4_VECTOR, 0xFF);

	timer_wait(IHOST_SWITCH_PROG_TIMEOUT); /* 10us */
30010324:	4b5d      	ldr	r3, [pc, #372]	; (3001049c <ihost_config+0x1c0>)
30010326:	3afd      	subs	r2, #253	; 0xfd
30010328:	601a      	str	r2, [r3, #0]
3001032a:	21cc      	movs	r1, #204	; 0xcc
3001032c:	4a5d      	ldr	r2, [pc, #372]	; (300104a4 <ihost_config+0x1c8>)
3001032e:	6011      	str	r1, [r2, #0]
30010330:	39cb      	subs	r1, #203	; 0xcb
30010332:	4a5d      	ldr	r2, [pc, #372]	; (300104a8 <ihost_config+0x1cc>)
30010334:	6011      	str	r1, [r2, #0]
30010336:	2282      	movs	r2, #130	; 0x82
30010338:	601a      	str	r2, [r3, #0]
3001033a:	4a5c      	ldr	r2, [pc, #368]	; (300104ac <ihost_config+0x1d0>)
3001033c:	6813      	ldr	r3, [r2, #0]
3001033e:	2b00      	cmp	r3, #0
30010340:	d0fc      	beq.n	3001033c <ihost_config+0x60>

	data1 = RdRegField(IHOST0_CONFIG_ROOT,
30010342:	4b5d      	ldr	r3, [pc, #372]	; (300104b8 <ihost_config+0x1dc>)
30010344:	681a      	ldr	r2, [r3, #0]
		A7_CRM_PWRON_OUT_DOMAIN_4, PWRON_OUT_DOMAIN_4_VECTOR);
	data2 = RdRegField(IHOST0_CONFIG_ROOT,
30010346:	4b5d      	ldr	r3, [pc, #372]	; (300104bc <ihost_config+0x1e0>)
30010348:	681b      	ldr	r3, [r3, #0]
		A7_CRM_PWROK_OUT_DOMAIN_4, PWROK_OUT_DOMAIN_4_VECTOR);

	if ((data1 & data2) == 0xff) {
3001034a:	401a      	ands	r2, r3
3001034c:	23ff      	movs	r3, #255	; 0xff
3001034e:	4013      	ands	r3, r2
30010350:	2bff      	cmp	r3, #255	; 0xff
30010352:	d100      	bne.n	30010356 <ihost_config+0x7a>
30010354:	e095      	b.n	30010482 <ihost_config+0x1a6>
		/* GPIO[3] bit set to '1' to Display switch programming Pass */
		WrReg(GP_DATA_OUT, RdReg(GP_DATA_OUT) | IHOST_SWITCH_STATUS);
	}

	/* [e] Remove PLL/TOP(memory and logic) isolations */
	WrReg(A7_CRM_PLL_PWR_ON, 0x3); /* Remove PLL output ISO */
30010356:	4950      	ldr	r1, [pc, #320]	; (30010498 <ihost_config+0x1bc>)
30010358:	2203      	movs	r2, #3
3001035a:	600a      	str	r2, [r1, #0]
 
	/* Remove Memory isolation */
	WrReg(A7_CRM_DOMAIN_4_CONTROL, 0x9);
3001035c:	4b58      	ldr	r3, [pc, #352]	; (300104c0 <ihost_config+0x1e4>)
3001035e:	2009      	movs	r0, #9
30010360:	6018      	str	r0, [r3, #0]
	/* Remove logic isolation */
	WrReg(A7_CRM_DOMAIN_4_CONTROL, 0x8);
30010362:	3801      	subs	r0, #1
30010364:	6018      	str	r0, [r3, #0]
	/* 4] PLL Programming
	 * [a] Set up Interrupt
	 * clear off any interrupt and get ready
	 * to monitor lock interrupt status
	 */
	WrReg(A7_CRM_PLL_INTERRUPT_STATUS,0x300);
30010366:	23c0      	movs	r3, #192	; 0xc0
30010368:	009b      	lsls	r3, r3, #2
3001036a:	4856      	ldr	r0, [pc, #344]	; (300104c4 <ihost_config+0x1e8>)
3001036c:	6003      	str	r3, [r0, #0]
	WrReg(A7_CRM_PLL_INTERRUPT_ENABLE,0x300);
3001036e:	4856      	ldr	r0, [pc, #344]	; (300104c8 <ihost_config+0x1ec>)
30010370:	6003      	str	r3, [r0, #0]
     * KI                : 'd3
     * KA                : 'd3
	 */

	/* NDIV_FRAC LSB */
	WrReg(A7_CRM_PLL0_CTRL1, 0x0);
30010372:	2300      	movs	r3, #0
30010374:	4855      	ldr	r0, [pc, #340]	; (300104cc <ihost_config+0x1f0>)
30010376:	6003      	str	r3, [r0, #0]
	/* NDIV_FRAC MSB */
	WrReg(A7_CRM_PLL0_CTRL2, 0x0);
30010378:	4855      	ldr	r0, [pc, #340]	; (300104d0 <ihost_config+0x1f4>)
3001037a:	6003      	str	r3, [r0, #0]
	/*  PDIV + NDIV_INT */
#ifdef CITADEL_DV_BOOT
	WrReg(A7_CRM_PLL0_CTRL3, ((0x1 << A7_CRM_PLL0_CTRL3__PLL0_PDIV_R ) | 0x26));
#else
	WrReg(A7_CRM_PLL0_CTRL3, ((0x1 << A7_CRM_PLL0_CTRL3__PLL0_PDIV_R) | 0x18));
3001037c:	4c55      	ldr	r4, [pc, #340]	; (300104d4 <ihost_config+0x1f8>)
3001037e:	4856      	ldr	r0, [pc, #344]	; (300104d8 <ihost_config+0x1fc>)
30010380:	6004      	str	r4, [r0, #0]
#endif
	/* KA/KI/KP */
	WrReg(A7_CRM_PLL0_CTRL4, ((0x1a << A7_CRM_PLL0_CTRL4__PLL0_FREFEFF_INFO_R)
30010382:	4c56      	ldr	r4, [pc, #344]	; (300104dc <ihost_config+0x200>)
30010384:	4856      	ldr	r0, [pc, #344]	; (300104e0 <ihost_config+0x204>)
30010386:	6004      	str	r4, [r0, #0]

	/* these 4 registers drive the i_pll_ctrl[63:0] input
	 * of the pll (16b per register). the values are derived
	 * from the spec (sections 8 and 10) PLL VCO range selection
	 */
	WrReg(A7_CRM_PLL0_CFG0_CTRL, 0x00000000);
30010388:	4856      	ldr	r0, [pc, #344]	; (300104e4 <ihost_config+0x208>)
3001038a:	6003      	str	r3, [r0, #0]
	WrReg(A7_CRM_PLL0_CFG1_CTRL, 0x00000000); 
3001038c:	4856      	ldr	r0, [pc, #344]	; (300104e8 <ihost_config+0x20c>)
3001038e:	6003      	str	r3, [r0, #0]
	WrReg(A7_CRM_PLL0_CFG2_CTRL, 0x00000000);
30010390:	4856      	ldr	r0, [pc, #344]	; (300104ec <ihost_config+0x210>)
30010392:	6003      	str	r3, [r0, #0]
	WrReg(A7_CRM_PLL0_CFG3_CTRL, 0x00000000);
30010394:	4856      	ldr	r0, [pc, #344]	; (300104f0 <ihost_config+0x214>)
30010396:	6003      	str	r3, [r0, #0]

	/* [c] CRM PLL control update
     * PLL channel control - set to always on
	 */
	WrReg(A7_CRM_PLL0_CHANNEL_CONTROL, 0x3);
30010398:	4b56      	ldr	r3, [pc, #344]	; (300104f4 <ihost_config+0x218>)
3001039a:	601a      	str	r2, [r3, #0]

	/* PLL channel0 control (for post divider) */
#ifdef CITADEL_DV_BOOT
	WrReg(A7_CRM_PLL0_CHANNEL0_DESCRIPTION, 0x1);
#else
	WrReg(A7_CRM_PLL0_CHANNEL0_DESCRIPTION, 0x3);
3001039c:	4b56      	ldr	r3, [pc, #344]	; (300104f8 <ihost_config+0x21c>)
3001039e:	601a      	str	r2, [r3, #0]
#endif

	/* update the PLL post dividers and vco */
	WrReg(A7_CRM_PLL_COMMAND, 0x3);
300103a0:	4b56      	ldr	r3, [pc, #344]	; (300104fc <ihost_config+0x220>)
300103a2:	601a      	str	r2, [r3, #0]

	/* [d] PLL reset
	 * de-asert PLL reset
	 */
	WrReg(A7_CRM_PLL_PWR_ON, 0x13);
300103a4:	2313      	movs	r3, #19
300103a6:	600b      	str	r3, [r1, #0]

	/* 5] Clock Programming
	 * [a] Release clock source reset
	 */
	WrReg(A7_CRM_SOFTRESETN_0, 0x7); 
300103a8:	3204      	adds	r2, #4
300103aa:	4b55      	ldr	r3, [pc, #340]	; (30010500 <ihost_config+0x224>)
300103ac:	601a      	str	r2, [r3, #0]
	/* wait ~500ns (500/38.46 = 13) */
	timer_wait(10);
300103ae:	4b3b      	ldr	r3, [pc, #236]	; (3001049c <ihost_config+0x1c0>)
300103b0:	3a05      	subs	r2, #5
300103b2:	601a      	str	r2, [r3, #0]
300103b4:	210a      	movs	r1, #10
300103b6:	4a3b      	ldr	r2, [pc, #236]	; (300104a4 <ihost_config+0x1c8>)
300103b8:	6011      	str	r1, [r2, #0]
300103ba:	3909      	subs	r1, #9
300103bc:	4a3a      	ldr	r2, [pc, #232]	; (300104a8 <ihost_config+0x1cc>)
300103be:	6011      	str	r1, [r2, #0]
300103c0:	2282      	movs	r2, #130	; 0x82
300103c2:	601a      	str	r2, [r3, #0]
300103c4:	4a39      	ldr	r2, [pc, #228]	; (300104ac <ihost_config+0x1d0>)
300103c6:	6813      	ldr	r3, [r2, #0]
300103c8:	2b00      	cmp	r3, #0
300103ca:	d0fc      	beq.n	300103c6 <ihost_config+0xea>

	/* [b] Setup clock description
	 * clock dividers
	 */
	WrReg(A7_CRM_AXI_CLK_DESC, 0x3); /* div by 4 */
300103cc:	2303      	movs	r3, #3
300103ce:	4a4d      	ldr	r2, [pc, #308]	; (30010504 <ihost_config+0x228>)
300103d0:	6013      	str	r3, [r2, #0]
	WrReg(A7_CRM_ACP_CLK_DESC, 0x3); /* div by 4 */
300103d2:	4a4d      	ldr	r2, [pc, #308]	; (30010508 <ihost_config+0x22c>)
300103d4:	6013      	str	r3, [r2, #0]
	WrReg(A7_CRM_ATB_CLK_DESC, 0x3); /* div by 4 */
300103d6:	4a4d      	ldr	r2, [pc, #308]	; (3001050c <ihost_config+0x230>)
300103d8:	6013      	str	r3, [r2, #0]
	WrReg(A7_CRM_PCLKDBG_DESC, 0x7); /* div by 8 */
300103da:	2207      	movs	r2, #7
300103dc:	4b4c      	ldr	r3, [pc, #304]	; (30010510 <ihost_config+0x234>)
300103de:	601a      	str	r2, [r3, #0]

	/* clock change trigger - must set to take
	 * effect after clock source change
	 */
	WrReg(A7_CRM_CLOCK_MODE_CONTROL, 0x1); 
300103e0:	2301      	movs	r3, #1
300103e2:	4a4c      	ldr	r2, [pc, #304]	; (30010514 <ihost_config+0x238>)
300103e4:	6013      	str	r3, [r2, #0]

	/* [c] Enable clocks - turn on functional clocks */
	/* SRAM clock enable */
	WrReg(A7_CRM_SUBSYSTEM_CONFIG_2, 0x1);
300103e6:	4a4c      	ldr	r2, [pc, #304]	; (30010518 <ihost_config+0x23c>)
300103e8:	6013      	str	r3, [r2, #0]

	/* turn on function clocks */
	/* { PDBG, ATB, ACP, AXI, ARM } */
	WrReg(A7_CRM_CLOCK_CONTROL_0, 0x3FF);
300103ea:	494c      	ldr	r1, [pc, #304]	; (3001051c <ihost_config+0x240>)
300103ec:	4a4c      	ldr	r2, [pc, #304]	; (30010520 <ihost_config+0x244>)
300103ee:	6011      	str	r1, [r2, #0]
	/* { APB, TMON } */
	WrReg(A7_CRM_CLOCK_CONTROL_1, 0x3C0);
300103f0:	393f      	subs	r1, #63	; 0x3f
300103f2:	4a4c      	ldr	r2, [pc, #304]	; (30010524 <ihost_config+0x248>)
300103f4:	6011      	str	r1, [r2, #0]

	/* 6] PLL Lock and post -divider channel reset removal */
	/* [a] Poll PLL lock status until locked */
	WrReg(CRMU_TIM_TIMER1Control, 0x02);
300103f6:	2102      	movs	r1, #2
300103f8:	4a28      	ldr	r2, [pc, #160]	; (3001049c <ihost_config+0x1c0>)
300103fa:	6011      	str	r1, [r2, #0]
	WrReg(CRMU_TIM_TIMER1IntClr, 0x1);
300103fc:	4a2a      	ldr	r2, [pc, #168]	; (300104a8 <ihost_config+0x1cc>)
300103fe:	6013      	str	r3, [r2, #0]
	if (!isFunctionalTestMode()) {
30010400:	4b49      	ldr	r3, [pc, #292]	; (30010528 <ihost_config+0x24c>)
30010402:	681b      	ldr	r3, [r3, #0]
30010404:	22e0      	movs	r2, #224	; 0xe0
30010406:	00d2      	lsls	r2, r2, #3
30010408:	4013      	ands	r3, r2
3001040a:	2280      	movs	r2, #128	; 0x80
3001040c:	0052      	lsls	r2, r2, #1
3001040e:	4293      	cmp	r3, r2
30010410:	d03d      	beq.n	3001048e <ihost_config+0x1b2>
		WrReg(CRMU_TIM_TIMER1Load, ARM_PLL_TIMEOUT_2);
30010412:	4a46      	ldr	r2, [pc, #280]	; (3001052c <ihost_config+0x250>)
30010414:	4b23      	ldr	r3, [pc, #140]	; (300104a4 <ihost_config+0x1c8>)
30010416:	601a      	str	r2, [r3, #0]
	}
	else {
		WrReg(CRMU_TIM_TIMER1Load, ARM_PLL_TIMEOUT);
	}
	WrReg(CRMU_TIM_TIMER1Control, 0x82);
30010418:	2282      	movs	r2, #130	; 0x82
3001041a:	4b20      	ldr	r3, [pc, #128]	; (3001049c <ihost_config+0x1c0>)
3001041c:	601a      	str	r2, [r3, #0]

	while (!RdReg(CRMU_TIM_TIMER1RIS)) {
3001041e:	4a23      	ldr	r2, [pc, #140]	; (300104ac <ihost_config+0x1d0>)
		if (!isFunctionalTestMode()) {
30010420:	4c41      	ldr	r4, [pc, #260]	; (30010528 <ihost_config+0x24c>)
30010422:	20e0      	movs	r0, #224	; 0xe0
30010424:	00c0      	lsls	r0, r0, #3
30010426:	2180      	movs	r1, #128	; 0x80
30010428:	0049      	lsls	r1, r1, #1
			if(RdReg(IHOST0_CONFIG_ROOT + A7_CRM_PLL_STATUS)
3001042a:	4d41      	ldr	r5, [pc, #260]	; (30010530 <ihost_config+0x254>)
	while (!RdReg(CRMU_TIM_TIMER1RIS)) {
3001042c:	6813      	ldr	r3, [r2, #0]
3001042e:	2b00      	cmp	r3, #0
30010430:	d106      	bne.n	30010440 <ihost_config+0x164>
		if (!isFunctionalTestMode()) {
30010432:	6823      	ldr	r3, [r4, #0]
30010434:	4003      	ands	r3, r0
30010436:	428b      	cmp	r3, r1
30010438:	d0f8      	beq.n	3001042c <ihost_config+0x150>
			if(RdReg(IHOST0_CONFIG_ROOT + A7_CRM_PLL_STATUS)
3001043a:	682b      	ldr	r3, [r5, #0]
3001043c:	059b      	lsls	r3, r3, #22
3001043e:	d5f5      	bpl.n	3001042c <ihost_config+0x150>
			 & (0x1 << A7_CRM_PLL_STATUS__PLL0_LOCK_R))
				break;
		}
	}

	if (RdReg(IHOST0_CONFIG_ROOT + A7_CRM_PLL_STATUS)
30010440:	4b3b      	ldr	r3, [pc, #236]	; (30010530 <ihost_config+0x254>)
30010442:	681b      	ldr	r3, [r3, #0]
30010444:	059b      	lsls	r3, r3, #22
30010446:	d50a      	bpl.n	3001045e <ihost_config+0x182>
		& (0x1 << A7_CRM_PLL_STATUS__PLL0_LOCK_R)) {
		/* [b] PLL post-divider channel reset */
		WrReg(A7_CRM_PLL_PWR_ON, 0x33);
30010448:	2233      	movs	r2, #51	; 0x33
3001044a:	4b13      	ldr	r3, [pc, #76]	; (30010498 <ihost_config+0x1bc>)
3001044c:	601a      	str	r2, [r3, #0]
		/* [c] Switch to PLL output */
		/* PLL channel control */
		WrReg(A7_CRM_PLL_CHANNEL_BYPASS_ENABLE, 0x0);
3001044e:	2200      	movs	r2, #0
30010450:	4b38      	ldr	r3, [pc, #224]	; (30010534 <ihost_config+0x258>)
30010452:	601a      	str	r2, [r3, #0]
		/* GPIO[4] bit set to '1' to Display PLL pass */
		WrReg(GP_DATA_OUT, RdReg(GP_DATA_OUT) | IHOST_PLL_LOCK_STATUS);
30010454:	4a38      	ldr	r2, [pc, #224]	; (30010538 <ihost_config+0x25c>)
30010456:	6813      	ldr	r3, [r2, #0]
30010458:	2110      	movs	r1, #16
3001045a:	430b      	orrs	r3, r1
3001045c:	6013      	str	r3, [r2, #0]
	}

	/* 8] Reset Programming */
	/* [a] Release soft resets */
	WrReg(A7_CRM_SUBSYSTEM_CONFIG_0, 0x00F0); /* Indicate DBG powered up */
3001045e:	22f0      	movs	r2, #240	; 0xf0
30010460:	4b36      	ldr	r3, [pc, #216]	; (3001053c <ihost_config+0x260>)
30010462:	601a      	str	r2, [r3, #0]

	/* Bus clocks --> PERIPH --> L2 --> CPU */
	/* Bus { PCLKDBG, ATB, ACP, AXI } */
	WrReg(A7_CRM_SOFTRESETN_0, 0x1E07);
30010464:	4b26      	ldr	r3, [pc, #152]	; (30010500 <ihost_config+0x224>)
30010466:	4a36      	ldr	r2, [pc, #216]	; (30010540 <ihost_config+0x264>)
30010468:	601a      	str	r2, [r3, #0]
	/* Bus { APB } */
	WrReg(A7_CRM_SOFTRESETN_1, 0x0100);
3001046a:	4a36      	ldr	r2, [pc, #216]	; (30010544 <ihost_config+0x268>)
3001046c:	2180      	movs	r1, #128	; 0x80
3001046e:	0049      	lsls	r1, r1, #1
30010470:	6011      	str	r1, [r2, #0]
	/* Periph components */
	WrReg(A7_CRM_SOFTRESETN_0, 0xFE07);
30010472:	4935      	ldr	r1, [pc, #212]	; (30010548 <ihost_config+0x26c>)
30010474:	6019      	str	r1, [r3, #0]
	/* L2 */
	WrReg(A7_CRM_SOFTRESETN_0, 0xFF0F);
30010476:	4935      	ldr	r1, [pc, #212]	; (3001054c <ihost_config+0x270>)
30010478:	6019      	str	r1, [r3, #0]
	/* CPUPOR */
	WrReg(A7_CRM_SOFTRESETN_0, 0xFFFF);
3001047a:	4935      	ldr	r1, [pc, #212]	; (30010550 <ihost_config+0x274>)
3001047c:	6019      	str	r1, [r3, #0]
	/* CPU/DBG */
	WrReg(A7_CRM_SOFTRESETN_1, 0xFFFF);
3001047e:	6011      	str	r1, [r2, #0]
}
30010480:	bd30      	pop	{r4, r5, pc}
		WrReg(GP_DATA_OUT, RdReg(GP_DATA_OUT) | IHOST_SWITCH_STATUS);
30010482:	4a2d      	ldr	r2, [pc, #180]	; (30010538 <ihost_config+0x25c>)
30010484:	6813      	ldr	r3, [r2, #0]
30010486:	2108      	movs	r1, #8
30010488:	430b      	orrs	r3, r1
3001048a:	6013      	str	r3, [r2, #0]
3001048c:	e763      	b.n	30010356 <ihost_config+0x7a>
		WrReg(CRMU_TIM_TIMER1Load, ARM_PLL_TIMEOUT);
3001048e:	4a31      	ldr	r2, [pc, #196]	; (30010554 <ihost_config+0x278>)
30010490:	4b04      	ldr	r3, [pc, #16]	; (300104a4 <ihost_config+0x1c8>)
30010492:	601a      	str	r2, [r3, #0]
30010494:	e7c0      	b.n	30010418 <ihost_config+0x13c>
30010496:	46c0      	nop			; (mov r8, r8)
30010498:	56010070 	.word	0x56010070
3001049c:	30023008 	.word	0x30023008
300104a0:	00000a2c 	.word	0x00000a2c
300104a4:	30023000 	.word	0x30023000
300104a8:	3002300c 	.word	0x3002300c
300104ac:	30023010 	.word	0x30023010
300104b0:	56010890 	.word	0x56010890
300104b4:	560108d0 	.word	0x560108d0
300104b8:	560108b0 	.word	0x560108b0
300104bc:	560108f0 	.word	0x560108f0
300104c0:	56010810 	.word	0x56010810
300104c4:	5601008c 	.word	0x5601008c
300104c8:	56010088 	.word	0x56010088
300104cc:	56010100 	.word	0x56010100
300104d0:	56010104 	.word	0x56010104
300104d4:	00001018 	.word	0x00001018
300104d8:	56010108 	.word	0x56010108
300104dc:	000069ba 	.word	0x000069ba
300104e0:	5601010c 	.word	0x5601010c
300104e4:	56010120 	.word	0x56010120
300104e8:	56010124 	.word	0x56010124
300104ec:	56010128 	.word	0x56010128
300104f0:	5601012c 	.word	0x5601012c
300104f4:	560100a0 	.word	0x560100a0
300104f8:	56010140 	.word	0x56010140
300104fc:	56010080 	.word	0x56010080
30010500:	56010480 	.word	0x56010480
30010504:	56010304 	.word	0x56010304
30010508:	56010308 	.word	0x56010308
3001050c:	5601030c 	.word	0x5601030c
30010510:	56010310 	.word	0x56010310
30010514:	56010040 	.word	0x56010040
30010518:	56010c88 	.word	0x56010c88
3001051c:	000003ff 	.word	0x000003ff
30010520:	56010200 	.word	0x56010200
30010524:	56010204 	.word	0x56010204
30010528:	30024000 	.word	0x30024000
3001052c:	00001450 	.word	0x00001450
30010530:	56010084 	.word	0x56010084
30010534:	560100ac 	.word	0x560100ac
30010538:	30024804 	.word	0x30024804
3001053c:	56010c80 	.word	0x56010c80
30010540:	00001e07 	.word	0x00001e07
30010544:	56010484 	.word	0x56010484
30010548:	0000fe07 	.word	0x0000fe07
3001054c:	0000ff0f 	.word	0x0000ff0f
30010550:	0000ffff 	.word	0x0000ffff
30010554:	00000514 	.word	0x00000514

30010558 <MCU_ultra_low_power_exit>:
}


static inline void sys_write32(u32_t data, mem_addr_t addr)
{
	*(volatile u32_t *)addr = data;
30010558:	2282      	movs	r2, #130	; 0x82
3001055a:	4b2a      	ldr	r3, [pc, #168]	; (30010604 <MCU_ultra_low_power_exit+0xac>)
3001055c:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
3001055e:	4a2a      	ldr	r2, [pc, #168]	; (30010608 <MCU_ultra_low_power_exit+0xb0>)
30010560:	6811      	ldr	r1, [r2, #0]
	sys_write32(0x82, CRMU_TIM_TIMER1Control);

	/* 1. CRMU_XTAL_CHANNEL_CONTROL1[28]
	 * (CRMU_XTAL_PWR_DET_ENA_REG) to 1
	 */
	sys_write32(sys_read32(CRMU_XTAL_CHANNEL_CONTROL1) | (1U << 28), CRMU_XTAL_CHANNEL_CONTROL1);
30010562:	2380      	movs	r3, #128	; 0x80
30010564:	055b      	lsls	r3, r3, #21
30010566:	430b      	orrs	r3, r1
	*(volatile u32_t *)addr = data;
30010568:	6013      	str	r3, [r2, #0]
3001056a:	4a28      	ldr	r2, [pc, #160]	; (3001060c <MCU_ultra_low_power_exit+0xb4>)
3001056c:	2307      	movs	r3, #7
3001056e:	6013      	str	r3, [r2, #0]
30010570:	3b06      	subs	r3, #6
30010572:	6013      	str	r3, [r2, #0]
30010574:	4a26      	ldr	r2, [pc, #152]	; (30010610 <MCU_ultra_low_power_exit+0xb8>)
30010576:	6013      	str	r3, [r2, #0]
30010578:	2294      	movs	r2, #148	; 0x94
3001057a:	0092      	lsls	r2, r2, #2
3001057c:	4b25      	ldr	r3, [pc, #148]	; (30010614 <MCU_ultra_low_power_exit+0xbc>)
3001057e:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30010580:	4a25      	ldr	r2, [pc, #148]	; (30010618 <MCU_ultra_low_power_exit+0xc0>)
30010582:	6813      	ldr	r3, [r2, #0]
	/* TODO: Consider increasing this delay to 30ms.
	 * First Clear the Timer Interrupt before starting.
	 */
	sys_write32(0x1, CRMU_TIM_TIMER1IntClr);
	sys_write32(PLL_PWRON_WAIT, CRMU_TIM_TIMER1Load);
	while(!sys_read32(CRMU_TIM_TIMER1RIS));
30010584:	2b00      	cmp	r3, #0
30010586:	d0fc      	beq.n	30010582 <MCU_ultra_low_power_exit+0x2a>
	*(volatile u32_t *)addr = data;
30010588:	4b1f      	ldr	r3, [pc, #124]	; (30010608 <MCU_ultra_low_power_exit+0xb0>)
3001058a:	4a24      	ldr	r2, [pc, #144]	; (3001061c <MCU_ultra_low_power_exit+0xc4>)
3001058c:	601a      	str	r2, [r3, #0]
3001058e:	4a24      	ldr	r2, [pc, #144]	; (30010620 <MCU_ultra_low_power_exit+0xc8>)
30010590:	601a      	str	r2, [r3, #0]
30010592:	2201      	movs	r2, #1
30010594:	4b23      	ldr	r3, [pc, #140]	; (30010624 <MCU_ultra_low_power_exit+0xcc>)
30010596:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30010598:	4a23      	ldr	r2, [pc, #140]	; (30010628 <MCU_ultra_low_power_exit+0xd0>)
3001059a:	6813      	ldr	r3, [r2, #0]
	crmu_cfg_xtal_pwr_on();
#endif

	/* switch to xtal 26M clock */
	sys_write32(0x1, CRMU_ULTRA_LOW_POWER_CTRL);
	while (sys_read32(CRMU_CLOCK_SWITCH_STATUS) != 0x1)
3001059c:	2b01      	cmp	r3, #1
3001059e:	d1fc      	bne.n	3001059a <MCU_ultra_low_power_exit+0x42>
300105a0:	4b22      	ldr	r3, [pc, #136]	; (3001062c <MCU_ultra_low_power_exit+0xd4>)
300105a2:	6819      	ldr	r1, [r3, #0]
	/* 0.1. CRMU_CLOCK_GATE_CONTROL, Un-GATE UART, OTP and SOTP
	 * rd_data = sys_read32(CRMU_CLOCK_GATE_CONTROL);
	 * rd_data = rd_data | (0xC000071F);
	 * sys_write32(rd_data, CRMU_CLOCK_GATE_CONTROL);
	 */
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) | (1 << CRMU_CLOCK_GATE_CONTROL__CRMU_BSPI_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
300105a4:	2280      	movs	r2, #128	; 0x80
300105a6:	0612      	lsls	r2, r2, #24
300105a8:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
300105aa:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300105ac:	6819      	ldr	r1, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) | (1 << CRMU_CLOCK_GATE_CONTROL__CRMU_UART_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
300105ae:	2280      	movs	r2, #128	; 0x80
300105b0:	05d2      	lsls	r2, r2, #23
300105b2:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
300105b4:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300105b6:	6819      	ldr	r1, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) | (1 << CRMU_CLOCK_GATE_CONTROL__CRMU_SOTP_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
300105b8:	2280      	movs	r2, #128	; 0x80
300105ba:	00d2      	lsls	r2, r2, #3
300105bc:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
300105be:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300105c0:	6819      	ldr	r1, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) | (1 << CRMU_CLOCK_GATE_CONTROL__CRMU_SMBUS_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
300105c2:	2280      	movs	r2, #128	; 0x80
300105c4:	0092      	lsls	r2, r2, #2
300105c6:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
300105c8:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300105ca:	6819      	ldr	r1, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) | (1 << CRMU_CLOCK_GATE_CONTROL__CRMU_OTPC_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
300105cc:	2280      	movs	r2, #128	; 0x80
300105ce:	0052      	lsls	r2, r2, #1
300105d0:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
300105d2:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300105d4:	681a      	ldr	r2, [r3, #0]
	/* FIXME: Why was SPRU_CRMU_REF_CLK not included in Lynx? What are the repercusions?
	 * It seems to work fine with RTC as wakeup in DRIPS.
	 */
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) | (1 << CRMU_CLOCK_GATE_CONTROL__CRMU_SPRU_CRMU_REF_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
300105d6:	2120      	movs	r1, #32
300105d8:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
300105da:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300105dc:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) | (1 << CRMU_CLOCK_GATE_CONTROL__CRMU_CDRU_CLK_25_ENABLE), CRMU_CLOCK_GATE_CONTROL);
300105de:	3910      	subs	r1, #16
300105e0:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
300105e2:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300105e4:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) | (1 << CRMU_CLOCK_GATE_CONTROL__CRMU_TIM_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
300105e6:	3908      	subs	r1, #8
300105e8:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
300105ea:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300105ec:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) | (1 << CRMU_CLOCK_GATE_CONTROL__CRMU_WDT_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
300105ee:	3904      	subs	r1, #4
300105f0:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
300105f2:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300105f4:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) | (1 << CRMU_CLOCK_GATE_CONTROL__CRMU_MCU_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
300105f6:	3903      	subs	r1, #3
300105f8:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
300105fa:	601a      	str	r2, [r3, #0]
300105fc:	2200      	movs	r2, #0
300105fe:	4b0c      	ldr	r3, [pc, #48]	; (30010630 <MCU_ultra_low_power_exit+0xd8>)
30010600:	601a      	str	r2, [r3, #0]
#endif

	/* 7. Un-Gate MPROC clocks */
	sys_write32(0x0, CDRU_CLK_DIS_CTRL);
#endif
}
30010602:	4770      	bx	lr
30010604:	30023008 	.word	0x30023008
30010608:	3001c000 	.word	0x3001c000
3001060c:	3001c060 	.word	0x3001c060
30010610:	3002300c 	.word	0x3002300c
30010614:	30023000 	.word	0x30023000
30010618:	30023010 	.word	0x30023010
3001061c:	12034207 	.word	0x12034207
30010620:	1a074207 	.word	0x1a074207
30010624:	3001c058 	.word	0x3001c058
30010628:	3001c05c 	.word	0x3001c05c
3001062c:	3001c050 	.word	0x3001c050
30010630:	3001d08c 	.word	0x3001d08c

30010634 <citadel_power_on_IO_ring>:
	return *(volatile u32_t *)addr;
30010634:	4a07      	ldr	r2, [pc, #28]	; (30010654 <citadel_power_on_IO_ring+0x20>)
30010636:	6813      	ldr	r3, [r2, #0]
	 * drive AON GPIO 2 High to turn IO Ring Power Off. Once OTP is
	 * programmed this need to be programmed accordingly.
	 *
	 */
	/* Set Bit 2 of GP_OUT_EN register to enable output on AON GPIO 2 */
	sys_write32((sys_read32(GP_OUT_EN)) | 0x4, GP_OUT_EN);
30010638:	2104      	movs	r1, #4
3001063a:	430b      	orrs	r3, r1
	*(volatile u32_t *)addr = data;
3001063c:	6013      	str	r3, [r2, #0]
	return *(volatile u32_t *)addr;
3001063e:	4b06      	ldr	r3, [pc, #24]	; (30010658 <citadel_power_on_IO_ring+0x24>)
30010640:	681a      	ldr	r2, [r3, #0]
	/* Clear Bit 2 of GP_RES_EN register to disable pull-up / pull-down
	 * of On-Chip GPIO Pad Resister for AON GPIO 2.
	 */
	sys_write32((sys_read32(GP_RES_EN)) & 0x7fb, GP_RES_EN);
30010642:	4906      	ldr	r1, [pc, #24]	; (3001065c <citadel_power_on_IO_ring+0x28>)
30010644:	400a      	ands	r2, r1
	*(volatile u32_t *)addr = data;
30010646:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30010648:	4a05      	ldr	r2, [pc, #20]	; (30010660 <citadel_power_on_IO_ring+0x2c>)
3001064a:	6813      	ldr	r3, [r2, #0]
	/* Set Bit 2 of GP_DATA_OUT register to '0' to Turn On Power to
	 * A7's GPIOs.
	 */
	sys_write32((sys_read32(GP_DATA_OUT)) & 0x7fb, GP_DATA_OUT);
3001064c:	400b      	ands	r3, r1
	*(volatile u32_t *)addr = data;
3001064e:	6013      	str	r3, [r2, #0]
#endif
}
30010650:	4770      	bx	lr
30010652:	46c0      	nop			; (mov r8, r8)
30010654:	30024808 	.word	0x30024808
30010658:	30024838 	.word	0x30024838
3001065c:	000007fb 	.word	0x000007fb
30010660:	30024804 	.word	0x30024804

30010664 <citadel_power_on_usb>:
	return *(volatile u32_t *)addr;
30010664:	4a0a      	ldr	r2, [pc, #40]	; (30010690 <citadel_power_on_usb+0x2c>)
30010666:	6813      	ldr	r3, [r2, #0]
	 * 1 - override_l1_suspend_select rw When set, value in bit1 (utmi_l1_suspendm) of CDRU_USBPHY_D_CTRL1
	 * register drives L1 suspend signals to PHY, Else USB Device Controller drives L1 suspend to PHY. 0
	 * 0 - override_l1_sleep_ovr_select rw When set, value in bit0 (utmi_l1_sleepm) of CDRU_USBPHY_D_CTRL1
	 * register drives L1 suspend signals to PHY, Else USB Device Controller drives L1 suspend to PHY. 0
	 */
	sys_write32(sys_read32(CDRU_USBD_MISC) & ~(0xF), CDRU_USBD_MISC);
30010668:	210f      	movs	r1, #15
3001066a:	438b      	bics	r3, r1
	*(volatile u32_t *)addr = data;
3001066c:	6013      	str	r3, [r2, #0]
	return *(volatile u32_t *)addr;
3001066e:	4a09      	ldr	r2, [pc, #36]	; (30010694 <citadel_power_on_usb+0x30>)
30010670:	6813      	ldr	r3, [r2, #0]
	 * 20 phy_iso rw Used for Isolation of PHY outputs to the Core. Default: 1
	 * 19:0 pll_ndiv_frac rw PLL feedback divider fraction control. Default: 0x66666
	 *
	 * FIXME: Why are we programming default values here?
	 */
	sys_write32(sys_read32(CRMU_USBPHY_D_CTRL) & (~0x100000), CRMU_USBPHY_D_CTRL);
30010672:	4909      	ldr	r1, [pc, #36]	; (30010698 <citadel_power_on_usb+0x34>)
30010674:	400b      	ands	r3, r1
	*(volatile u32_t *)addr = data;
30010676:	6013      	str	r3, [r2, #0]
	return *(volatile u32_t *)addr;
30010678:	4b08      	ldr	r3, [pc, #32]	; (3001069c <citadel_power_on_usb+0x38>)
3001067a:	6819      	ldr	r1, [r3, #0]
	 * 5:3 - pdiv rw PLL input reference clock pre-divider control 0x1
	 * 2 - resetb rw Active-low asynchronous reset. This is the main reset and shuts the entire IP when asserted low. 0
	 * 1 - utmi_l1_suspendm rw Active Low.USB Device PHY L1 suspend mode, shallow mode. PLL is off. 1
	 * 0 - utmi_l1_sleepm rw Active Low.USB Device PHY L1 sleep mode, shallow mode. PLL is off. HS TX/RX are disabled. 1
	 */
	sys_write32(sys_read32(CDRU_USBPHY_D_CTRL1) | (1 << 27), CDRU_USBPHY_D_CTRL1); /* bit1 = 1 */
3001067c:	2280      	movs	r2, #128	; 0x80
3001067e:	0512      	lsls	r2, r2, #20
30010680:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
30010682:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30010684:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CDRU_USBPHY_D_CTRL1) | (0x3), CDRU_USBPHY_D_CTRL1); /* bits[1:0] = 0x3; */
30010686:	2103      	movs	r1, #3
30010688:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
3001068a:	601a      	str	r2, [r3, #0]
#endif
}
3001068c:	4770      	bx	lr
3001068e:	46c0      	nop			; (mov r8, r8)
30010690:	3001d0a0 	.word	0x3001d0a0
30010694:	3001c024 	.word	0x3001c024
30010698:	ffefffff 	.word	0xffefffff
3001069c:	3001d0c4 	.word	0x3001d0c4

300106a0 <citadel_sleep_exit>:
	 | (event & 0xffffff) | MAILBOX_CODE0_mProcWakeup, 4);
	/* MAILBOX_CODE0_mProcSoftResetAndResume, 4); */
	cpu_reg32_wr(CRMU_IPROC_MAIL_BOX1, MAILBOX_CODE1_PM);
#endif
#endif
}
300106a0:	4770      	bx	lr

300106a2 <citadel_DRIPS_exit>:
 * @param None
 *
 * @return none
 */
void citadel_DRIPS_exit(void)
{
300106a2:	b500      	push	{lr}
300106a4:	b083      	sub	sp, #12
	/* Power On the IO Ring First */
	citadel_power_on_IO_ring();
300106a6:	f7ff ffc5 	bl	30010634 <citadel_power_on_IO_ring>

	/* Power On USB PHY */
	citadel_power_on_usb();
300106aa:	f7ff ffdb 	bl	30010664 <citadel_power_on_usb>
	 * They ideally should, because they are CRMU registers.
	 *
	 * FIXME: This sequence to turn 26MHz On possibly contributes to DRIPS
	 * wake-up instability.
	 */
	MCU_ultra_low_power_exit();
300106ae:	f7ff ff53 	bl	30010558 <MCU_ultra_low_power_exit>
300106b2:	2282      	movs	r2, #130	; 0x82
300106b4:	4b37      	ldr	r3, [pc, #220]	; (30010794 <citadel_DRIPS_exit+0xf2>)
300106b6:	601a      	str	r2, [r3, #0]
300106b8:	4837      	ldr	r0, [pc, #220]	; (30010798 <citadel_DRIPS_exit+0xf6>)
300106ba:	2101      	movs	r1, #1
300106bc:	6001      	str	r1, [r0, #0]
300106be:	2200      	movs	r2, #0
300106c0:	4b36      	ldr	r3, [pc, #216]	; (3001079c <citadel_DRIPS_exit+0xfa>)
300106c2:	601a      	str	r2, [r3, #0]
300106c4:	4b36      	ldr	r3, [pc, #216]	; (300107a0 <citadel_DRIPS_exit+0xfe>)
300106c6:	601a      	str	r2, [r3, #0]
300106c8:	6002      	str	r2, [r0, #0]
	return *(volatile u32_t *)addr;
300106ca:	6818      	ldr	r0, [r3, #0]
	sys_write32(sys_read32(CRMU_GENPLL_CONTROL0) & 0x4, CRMU_GENPLL_CONTROL0);
300106cc:	3204      	adds	r2, #4
300106ce:	4002      	ands	r2, r0
	*(volatile u32_t *)addr = data;
300106d0:	601a      	str	r2, [r3, #0]
300106d2:	4b34      	ldr	r3, [pc, #208]	; (300107a4 <citadel_DRIPS_exit+0x102>)
300106d4:	6019      	str	r1, [r3, #0]
300106d6:	2294      	movs	r2, #148	; 0x94
300106d8:	0092      	lsls	r2, r2, #2
300106da:	4b33      	ldr	r3, [pc, #204]	; (300107a8 <citadel_DRIPS_exit+0x106>)
300106dc:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300106de:	4a33      	ldr	r2, [pc, #204]	; (300107ac <citadel_DRIPS_exit+0x10a>)
300106e0:	6813      	ldr	r3, [r2, #0]
	while(!sys_read32(CRMU_TIM_TIMER1RIS));
300106e2:	2b00      	cmp	r3, #0
300106e4:	d0fc      	beq.n	300106e0 <citadel_DRIPS_exit+0x3e>
300106e6:	4932      	ldr	r1, [pc, #200]	; (300107b0 <citadel_DRIPS_exit+0x10e>)
	while((sys_read32(CRMU_GENPLL_STATUS) & 0x1) != 0x1)
300106e8:	2201      	movs	r2, #1
300106ea:	680b      	ldr	r3, [r1, #0]
300106ec:	421a      	tst	r2, r3
300106ee:	d0fc      	beq.n	300106ea <citadel_DRIPS_exit+0x48>
	*(volatile u32_t *)addr = data;
300106f0:	2282      	movs	r2, #130	; 0x82
300106f2:	4b28      	ldr	r3, [pc, #160]	; (30010794 <citadel_DRIPS_exit+0xf2>)
300106f4:	601a      	str	r2, [r3, #0]
300106f6:	4b2f      	ldr	r3, [pc, #188]	; (300107b4 <citadel_DRIPS_exit+0x112>)
300106f8:	4a2f      	ldr	r2, [pc, #188]	; (300107b8 <citadel_DRIPS_exit+0x116>)
300106fa:	601a      	str	r2, [r3, #0]
300106fc:	492f      	ldr	r1, [pc, #188]	; (300107bc <citadel_DRIPS_exit+0x11a>)
300106fe:	4a30      	ldr	r2, [pc, #192]	; (300107c0 <citadel_DRIPS_exit+0x11e>)
30010700:	6011      	str	r1, [r2, #0]
30010702:	4930      	ldr	r1, [pc, #192]	; (300107c4 <citadel_DRIPS_exit+0x122>)
30010704:	4a30      	ldr	r2, [pc, #192]	; (300107c8 <citadel_DRIPS_exit+0x126>)
30010706:	6011      	str	r1, [r2, #0]
30010708:	4930      	ldr	r1, [pc, #192]	; (300107cc <citadel_DRIPS_exit+0x12a>)
3001070a:	4a31      	ldr	r2, [pc, #196]	; (300107d0 <citadel_DRIPS_exit+0x12e>)
3001070c:	6011      	str	r1, [r2, #0]
3001070e:	4a31      	ldr	r2, [pc, #196]	; (300107d4 <citadel_DRIPS_exit+0x132>)
30010710:	601a      	str	r2, [r3, #0]
30010712:	2201      	movs	r2, #1
30010714:	4b23      	ldr	r3, [pc, #140]	; (300107a4 <citadel_DRIPS_exit+0x102>)
30010716:	601a      	str	r2, [r3, #0]
30010718:	2294      	movs	r2, #148	; 0x94
3001071a:	0092      	lsls	r2, r2, #2
3001071c:	4b22      	ldr	r3, [pc, #136]	; (300107a8 <citadel_DRIPS_exit+0x106>)
3001071e:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30010720:	4923      	ldr	r1, [pc, #140]	; (300107b0 <citadel_DRIPS_exit+0x10e>)
	while((sys_read32(CRMU_GENPLL_STATUS) & 0x1) != 0x1)
30010722:	2201      	movs	r2, #1
30010724:	680b      	ldr	r3, [r1, #0]
30010726:	421a      	tst	r2, r3
30010728:	d0fc      	beq.n	30010724 <citadel_DRIPS_exit+0x82>
3001072a:	4b2b      	ldr	r3, [pc, #172]	; (300107d8 <citadel_DRIPS_exit+0x136>)
3001072c:	6819      	ldr	r1, [r3, #0]
	sys_write32(sys_read32(CRMU_GENPLL_CONTROL1) | 0x00FC0000, CRMU_GENPLL_CONTROL1);
3001072e:	22fc      	movs	r2, #252	; 0xfc
30010730:	0412      	lsls	r2, r2, #16
30010732:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
30010734:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30010736:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_GENPLL_CONTROL1) & 0xFF03FFFF, CRMU_GENPLL_CONTROL1);
30010738:	4928      	ldr	r1, [pc, #160]	; (300107dc <citadel_DRIPS_exit+0x13a>)
3001073a:	400a      	ands	r2, r1
	*(volatile u32_t *)addr = data;
3001073c:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
3001073e:	4a28      	ldr	r2, [pc, #160]	; (300107e0 <citadel_DRIPS_exit+0x13e>)
30010740:	6813      	ldr	r3, [r2, #0]
	sys_write32(sys_read32(CRMU_ISO_CELL_CONTROL) & ~(1 << CRMU_ISO_CELL_CONTROL__CRMU_ISO_PDSYS_PLL_LOCKED), CRMU_ISO_CELL_CONTROL);
30010742:	4928      	ldr	r1, [pc, #160]	; (300107e4 <citadel_DRIPS_exit+0x142>)
30010744:	400b      	ands	r3, r1
	*(volatile u32_t *)addr = data;
30010746:	6013      	str	r3, [r2, #0]
30010748:	2280      	movs	r2, #128	; 0x80
3001074a:	0412      	lsls	r2, r2, #16
3001074c:	4b26      	ldr	r3, [pc, #152]	; (300107e8 <citadel_DRIPS_exit+0x146>)
3001074e:	601a      	str	r2, [r3, #0]
30010750:	2203      	movs	r2, #3
30010752:	4b26      	ldr	r3, [pc, #152]	; (300107ec <citadel_DRIPS_exit+0x14a>)
30010754:	601a      	str	r2, [r3, #0]
30010756:	3a01      	subs	r2, #1
30010758:	4b25      	ldr	r3, [pc, #148]	; (300107f0 <citadel_DRIPS_exit+0x14e>)
3001075a:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
3001075c:	4b25      	ldr	r3, [pc, #148]	; (300107f4 <citadel_DRIPS_exit+0x152>)
3001075e:	681b      	ldr	r3, [r3, #0]
	if (sys_read32(CRMU_IHOST_SW_PERSISTENT_REG0) == 0x0)
30010760:	2b00      	cmp	r3, #0
30010762:	d102      	bne.n	3001076a <citadel_DRIPS_exit+0xc8>
	*(volatile u32_t *)addr = data;
30010764:	3a01      	subs	r2, #1
30010766:	4b24      	ldr	r3, [pc, #144]	; (300107f8 <citadel_DRIPS_exit+0x156>)
30010768:	601a      	str	r2, [r3, #0]
	ihost_config();
3001076a:	f7ff fdb7 	bl	300102dc <ihost_config>
	for (i_loop = 0; i_loop < 10; i_loop++)
3001076e:	2300      	movs	r3, #0
30010770:	9301      	str	r3, [sp, #4]
30010772:	9b01      	ldr	r3, [sp, #4]
30010774:	2b09      	cmp	r3, #9
30010776:	d805      	bhi.n	30010784 <citadel_DRIPS_exit+0xe2>
30010778:	9b01      	ldr	r3, [sp, #4]
3001077a:	3301      	adds	r3, #1
3001077c:	9301      	str	r3, [sp, #4]
3001077e:	9b01      	ldr	r3, [sp, #4]
30010780:	2b09      	cmp	r3, #9
30010782:	d9f9      	bls.n	30010778 <citadel_DRIPS_exit+0xd6>
30010784:	2301      	movs	r3, #1
30010786:	4a1d      	ldr	r2, [pc, #116]	; (300107fc <citadel_DRIPS_exit+0x15a>)
30010788:	6013      	str	r3, [r2, #0]
3001078a:	4a1d      	ldr	r2, [pc, #116]	; (30010800 <citadel_DRIPS_exit+0x15e>)
3001078c:	6013      	str	r3, [r2, #0]
	/* reset A7 - From SV Code
	 * FIXME: Shouldn't this be part of the IHOST power Up sequence?
	 */
	sys_write32(0x1, CRMU_RESET_CTRL);
	sys_write32(0x1, CRMU_CHIP_POR_CTRL);
}
3001078e:	b003      	add	sp, #12
30010790:	bd00      	pop	{pc}
30010792:	46c0      	nop			; (mov r8, r8)
30010794:	30023008 	.word	0x30023008
30010798:	3001c020 	.word	0x3001c020
3001079c:	3001d028 	.word	0x3001d028
300107a0:	3001d000 	.word	0x3001d000
300107a4:	3002300c 	.word	0x3002300c
300107a8:	30023000 	.word	0x30023000
300107ac:	30023010 	.word	0x30023010
300107b0:	3001d024 	.word	0x3001d024
300107b4:	3001d00c 	.word	0x3001d00c
300107b8:	0200003d 	.word	0x0200003d
300107bc:	00040006 	.word	0x00040006
300107c0:	3001d010 	.word	0x3001d010
300107c4:	00140006 	.word	0x00140006
300107c8:	3001d014 	.word	0x3001d014
300107cc:	00080008 	.word	0x00080008
300107d0:	3001d018 	.word	0x3001d018
300107d4:	8200003d 	.word	0x8200003d
300107d8:	3001d004 	.word	0x3001d004
300107dc:	ff03ffff 	.word	0xff03ffff
300107e0:	3001c044 	.word	0x3001c044
300107e4:	ffffefff 	.word	0xffffefff
300107e8:	3001d08c 	.word	0x3001d08c
300107ec:	30024044 	.word	0x30024044
300107f0:	30024c80 	.word	0x30024c80
300107f4:	30024c54 	.word	0x30024c54
300107f8:	30024c5c 	.word	0x30024c5c
300107fc:	3001d044 	.word	0x3001d044
30010800:	3001d048 	.word	0x3001d048

30010804 <citadel_deep_sleep_exit>:
 * @param None
 *
 * @return none
 */
s32_t citadel_deep_sleep_exit(void)
{
30010804:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
30010806:	2501      	movs	r5, #1
30010808:	4b5f      	ldr	r3, [pc, #380]	; (30010988 <citadel_deep_sleep_exit+0x184>)
3001080a:	601d      	str	r5, [r3, #0]
	return *(volatile u32_t *)addr;
3001080c:	4a5f      	ldr	r2, [pc, #380]	; (3001098c <citadel_deep_sleep_exit+0x188>)
3001080e:	6813      	ldr	r3, [r2, #0]

	/* 1. Lower the AON LDO output voltage after entering sleep mode.
	 * Set CRMU_LDO_CTRL_REG_28_0[3:0] (AONLDO Vout) back to 4'b0000
	 * upon wakeup before resuming any activity.
	 */
	sys_write32((sys_read32(CRMU_LDO_CTRL_REG_28_0) & 0XFFFFFFF0), CRMU_LDO_CTRL_REG_28_0);
30010810:	210f      	movs	r1, #15
30010812:	438b      	bics	r3, r1
	*(volatile u32_t *)addr = data;
30010814:	6013      	str	r3, [r2, #0]
	return *(volatile u32_t *)addr;
30010816:	4c5e      	ldr	r4, [pc, #376]	; (30010990 <citadel_deep_sleep_exit+0x18c>)
30010818:	6823      	ldr	r3, [r4, #0]

	/* 2. CRMU_ISO_CELL_CONTROL[0] : CRMU_ISO_PDSYS; set to 0 */
	sys_write32((sys_read32(CRMU_ISO_CELL_CONTROL)) & ~(0x1), CRMU_ISO_CELL_CONTROL);
3001081a:	43ab      	bics	r3, r5
	*(volatile u32_t *)addr = data;
3001081c:	6023      	str	r3, [r4, #0]
3001081e:	2200      	movs	r2, #0
30010820:	4b5c      	ldr	r3, [pc, #368]	; (30010994 <citadel_deep_sleep_exit+0x190>)
30010822:	601a      	str	r2, [r3, #0]
	 * sys_write32((sys_read32(GP_DATA_OUT)) | 0x2, GP_DATA_OUT);
	 */
	sys_write32(0x00, GP_TEST_ENABLE);

	/* Power the IO Ring First */
	citadel_power_on_IO_ring();
30010824:	f7ff ff06 	bl	30010634 <citadel_power_on_IO_ring>
	return *(volatile u32_t *)addr;
30010828:	4b5b      	ldr	r3, [pc, #364]	; (30010998 <citadel_deep_sleep_exit+0x194>)
3001082a:	681a      	ldr	r2, [r3, #0]
	*(volatile u32_t *)addr = data;
3001082c:	601d      	str	r5, [r3, #0]
	return *(volatile u32_t *)addr;
3001082e:	6823      	ldr	r3, [r4, #0]
	rd_data = sys_read32(CRMU_MAIN_LDO_PU_CTRL);
	sys_write32(0x1, CRMU_MAIN_LDO_PU_CTRL);

	/* 6. Disable PD_SYS Power good ISO */
	rd_data = sys_read32(CRMU_ISO_CELL_CONTROL);
	sys_write32(rd_data & 0xFFFFFEFF, CRMU_ISO_CELL_CONTROL);
30010830:	4a5a      	ldr	r2, [pc, #360]	; (3001099c <citadel_deep_sleep_exit+0x198>)
30010832:	4013      	ands	r3, r2
	*(volatile u32_t *)addr = data;
30010834:	6023      	str	r3, [r4, #0]
	return *(volatile u32_t *)addr;
30010836:	495a      	ldr	r1, [pc, #360]	; (300109a0 <citadel_deep_sleep_exit+0x19c>)

	/* 7. poll for pdsys pmu_stable */
	do {
		rd_data = sys_read32(CRMU_POWER_POLL) & 0x1;
30010838:	3203      	adds	r2, #3
3001083a:	32ff      	adds	r2, #255	; 0xff
3001083c:	680b      	ldr	r3, [r1, #0]
	} while (!rd_data);
3001083e:	421a      	tst	r2, r3
30010840:	d0fc      	beq.n	3001083c <citadel_deep_sleep_exit+0x38>
30010842:	4a53      	ldr	r2, [pc, #332]	; (30010990 <citadel_deep_sleep_exit+0x18c>)
30010844:	6813      	ldr	r3, [r2, #0]

	/* 8. Disable PD_SYS ISO */
	rd_data = sys_read32(CRMU_ISO_CELL_CONTROL);
	sys_write32(rd_data & 0xFFFFFFFE, CRMU_ISO_CELL_CONTROL);
30010846:	2501      	movs	r5, #1
30010848:	43ab      	bics	r3, r5
	*(volatile u32_t *)addr = data;
3001084a:	6013      	str	r3, [r2, #0]

	/* 3. Exit Ultra Low Power Mode
	 * AON clock gating and power on XTAL
	 */
	MCU_ultra_low_power_exit();
3001084c:	f7ff fe84 	bl	30010558 <MCU_ultra_low_power_exit>
	return *(volatile u32_t *)addr;
30010850:	4a54      	ldr	r2, [pc, #336]	; (300109a4 <citadel_deep_sleep_exit+0x1a0>)
30010852:	6811      	ldr	r1, [r2, #0]

	/* 9. Restore clock */
	rd_data = sys_read32(CRMU_CLOCK_GATE_CONTROL);
	rd_data = rd_data | 0xC000071F;
30010854:	4b54      	ldr	r3, [pc, #336]	; (300109a8 <citadel_deep_sleep_exit+0x1a4>)
30010856:	430b      	orrs	r3, r1
	*(volatile u32_t *)addr = data;
30010858:	6013      	str	r3, [r2, #0]
3001085a:	2400      	movs	r4, #0
3001085c:	4b53      	ldr	r3, [pc, #332]	; (300109ac <citadel_deep_sleep_exit+0x1a8>)
3001085e:	601c      	str	r4, [r3, #0]
30010860:	4b53      	ldr	r3, [pc, #332]	; (300109b0 <citadel_deep_sleep_exit+0x1ac>)
30010862:	601d      	str	r5, [r3, #0]
30010864:	4b53      	ldr	r3, [pc, #332]	; (300109b4 <citadel_deep_sleep_exit+0x1b0>)
30010866:	601c      	str	r4, [r3, #0]
30010868:	601d      	str	r5, [r3, #0]
3001086a:	4e53      	ldr	r6, [pc, #332]	; (300109b8 <citadel_deep_sleep_exit+0x1b4>)
3001086c:	6035      	str	r5, [r6, #0]
3001086e:	4b53      	ldr	r3, [pc, #332]	; (300109bc <citadel_deep_sleep_exit+0x1b8>)
30010870:	601c      	str	r4, [r3, #0]
	/* 11.1 Power on the PLL(s) */
	sys_write32(((1U << CRMU_PLL_AON_CTRL__GENPLL_ISO_IN) | (0U << CRMU_PLL_AON_CTRL__GENPLL_PWRDN) | (0U << CRMU_PLL_AON_CTRL__GENPLL_FREF_PWRDN)), CRMU_PLL_AON_CTRL);

	/* 11.2 Remove PLL ISO */
	sys_write32(0, CRMU_PLL_ISO_CTRL);
	MCU_timer_udelay(100);
30010872:	2064      	movs	r0, #100	; 0x64
30010874:	f000 ff26 	bl	300116c4 <MCU_timer_udelay>
30010878:	4d51      	ldr	r5, [pc, #324]	; (300109c0 <citadel_deep_sleep_exit+0x1bc>)
3001087a:	602c      	str	r4, [r5, #0]
3001087c:	6034      	str	r4, [r6, #0]
	/* 11.4 Remove PLL ISO */
	sys_write32(((0U << CRMU_PLL_AON_CTRL__GENPLL_ISO_IN) | (0U << CRMU_PLL_AON_CTRL__GENPLL_PWRDN) | (0U << CRMU_PLL_AON_CTRL__GENPLL_FREF_PWRDN)), CRMU_PLL_AON_CTRL);

	/* 12. Configure all the clocks to default values */
	/* 12.1 Clear all MDIV and NDIV fields */
	WrReg(CRMU_GENPLL_CONTROL2, (RdReg(CRMU_GENPLL_CONTROL2) & ~(CRMU_GENPLL_CONTROL2__i_ndiv_frac_MASK)));
3001087e:	4c51      	ldr	r4, [pc, #324]	; (300109c4 <citadel_deep_sleep_exit+0x1c0>)
30010880:	6823      	ldr	r3, [r4, #0]
30010882:	0e1b      	lsrs	r3, r3, #24
30010884:	061b      	lsls	r3, r3, #24
30010886:	6023      	str	r3, [r4, #0]
	WrReg(CRMU_GENPLL_CONTROL3, (RdReg(CRMU_GENPLL_CONTROL3) & ~(CRMU_GENPLL_CONTROL3__i_ndiv_int_MASK) & ~(CRMU_GENPLL_CONTROL3__i_p1div_MASK)));
30010888:	4b4f      	ldr	r3, [pc, #316]	; (300109c8 <citadel_deep_sleep_exit+0x1c4>)
3001088a:	681a      	ldr	r2, [r3, #0]
3001088c:	494f      	ldr	r1, [pc, #316]	; (300109cc <citadel_deep_sleep_exit+0x1c8>)
3001088e:	400a      	ands	r2, r1
30010890:	601a      	str	r2, [r3, #0]
	WrReg(CRMU_GENPLL_CONTROL4, (RdReg(CRMU_GENPLL_CONTROL4) & ~(CRMU_GENPLL_CONTROL4__i_m1div_MASK) &  ~(CRMU_GENPLL_CONTROL4__i_m2div_MASK)));
30010892:	484f      	ldr	r0, [pc, #316]	; (300109d0 <citadel_deep_sleep_exit+0x1cc>)
30010894:	6802      	ldr	r2, [r0, #0]
30010896:	4f4f      	ldr	r7, [pc, #316]	; (300109d4 <citadel_deep_sleep_exit+0x1d0>)
30010898:	403a      	ands	r2, r7
3001089a:	6002      	str	r2, [r0, #0]
	WrReg(CRMU_GENPLL_CONTROL5, (RdReg(CRMU_GENPLL_CONTROL5) & ~(CRMU_GENPLL_CONTROL5__i_m3div_MASK) & ~(CRMU_GENPLL_CONTROL5__i_m4div_MASK)));
3001089c:	494e      	ldr	r1, [pc, #312]	; (300109d8 <citadel_deep_sleep_exit+0x1d4>)
3001089e:	680a      	ldr	r2, [r1, #0]
300108a0:	403a      	ands	r2, r7
300108a2:	600a      	str	r2, [r1, #0]
	WrReg(CRMU_GENPLL_CONTROL6, (RdReg(CRMU_GENPLL_CONTROL6) & ~(CRMU_GENPLL_CONTROL6__i_m5div_MASK) & ~(CRMU_GENPLL_CONTROL6__i_m6div_MASK)));
300108a4:	4a4d      	ldr	r2, [pc, #308]	; (300109dc <citadel_deep_sleep_exit+0x1d8>)
300108a6:	6816      	ldr	r6, [r2, #0]
300108a8:	403e      	ands	r6, r7
300108aa:	6016      	str	r6, [r2, #0]
	/* 12.2 NDIV Configuration */
	WrReg(CRMU_GENPLL_CONTROL2, (RdReg(CRMU_GENPLL_CONTROL2) | (0x000000 << CRMU_GENPLL_CONTROL2__i_ndiv_frac_R)));
300108ac:	6826      	ldr	r6, [r4, #0]
300108ae:	6026      	str	r6, [r4, #0]
	WrReg(CRMU_GENPLL_CONTROL3, (RdReg(CRMU_GENPLL_CONTROL3) | (0x3D << CRMU_GENPLL_CONTROL3__i_ndiv_int_R) | (0x2  << CRMU_GENPLL_CONTROL3__i_p1div_R)));
300108b0:	681e      	ldr	r6, [r3, #0]
300108b2:	4c4b      	ldr	r4, [pc, #300]	; (300109e0 <citadel_deep_sleep_exit+0x1dc>)
300108b4:	4334      	orrs	r4, r6
300108b6:	601c      	str	r4, [r3, #0]
	/* 12.3 MDIV Configuration */
	WrReg(CRMU_GENPLL_CONTROL4, (RdReg(CRMU_GENPLL_CONTROL4) | (0x6 << CRMU_GENPLL_CONTROL4__i_m1div_R) | (0x4 << CRMU_GENPLL_CONTROL4__i_m2div_R)));
300108b8:	6806      	ldr	r6, [r0, #0]
300108ba:	4c4a      	ldr	r4, [pc, #296]	; (300109e4 <citadel_deep_sleep_exit+0x1e0>)
300108bc:	4334      	orrs	r4, r6
300108be:	6004      	str	r4, [r0, #0]
	WrReg(CRMU_GENPLL_CONTROL5, (RdReg(CRMU_GENPLL_CONTROL5) | (0x6 << CRMU_GENPLL_CONTROL5__i_m3div_R) | (0x14 << CRMU_GENPLL_CONTROL5__i_m4div_R)));
300108c0:	680c      	ldr	r4, [r1, #0]
300108c2:	4849      	ldr	r0, [pc, #292]	; (300109e8 <citadel_deep_sleep_exit+0x1e4>)
300108c4:	4320      	orrs	r0, r4
300108c6:	6008      	str	r0, [r1, #0]
	WrReg(CRMU_GENPLL_CONTROL6, (RdReg(CRMU_GENPLL_CONTROL6) | (0x8 << CRMU_GENPLL_CONTROL6__i_m5div_R) | (0x8 << CRMU_GENPLL_CONTROL6__i_m6div_R)));
300108c8:	6810      	ldr	r0, [r2, #0]
300108ca:	4948      	ldr	r1, [pc, #288]	; (300109ec <citadel_deep_sleep_exit+0x1e8>)
300108cc:	4301      	orrs	r1, r0
300108ce:	6011      	str	r1, [r2, #0]
	WrReg(CRMU_GENPLL_CONTROL3, (RdReg(CRMU_GENPLL_CONTROL3) | (0x1 << CRMU_GENPLL_CONTROL3__genpll_sel_sw_setting)));
300108d0:	6819      	ldr	r1, [r3, #0]
300108d2:	2280      	movs	r2, #128	; 0x80
300108d4:	0612      	lsls	r2, r2, #24
300108d6:	430a      	orrs	r2, r1
300108d8:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300108da:	682a      	ldr	r2, [r5, #0]

	/* 13. PLL i_areset de-assert */
	sys_write32(sys_read32(CRMU_GENPLL_CONTROL0) & 0x4, CRMU_GENPLL_CONTROL0);
300108dc:	2304      	movs	r3, #4
300108de:	4013      	ands	r3, r2
	*(volatile u32_t *)addr = data;
300108e0:	602b      	str	r3, [r5, #0]
	return *(volatile u32_t *)addr;
300108e2:	4943      	ldr	r1, [pc, #268]	; (300109f0 <citadel_deep_sleep_exit+0x1ec>)
	/* MCU_timer_raw_delay(0x10); */

	/* 14. Wait until PLL locked */
	while ((sys_read32(CRMU_GENPLL_STATUS) & 0x1) != 1)
300108e4:	2201      	movs	r2, #1
300108e6:	680b      	ldr	r3, [r1, #0]
300108e8:	421a      	tst	r2, r3
300108ea:	d0fc      	beq.n	300108e6 <citadel_deep_sleep_exit+0xe2>
	*(volatile u32_t *)addr = data;
300108ec:	2303      	movs	r3, #3
300108ee:	4a41      	ldr	r2, [pc, #260]	; (300109f4 <citadel_deep_sleep_exit+0x1f0>)
300108f0:	6013      	str	r3, [r2, #0]
300108f2:	4a41      	ldr	r2, [pc, #260]	; (300109f8 <citadel_deep_sleep_exit+0x1f4>)
300108f4:	6013      	str	r3, [r2, #0]
300108f6:	2282      	movs	r2, #130	; 0x82
300108f8:	4b40      	ldr	r3, [pc, #256]	; (300109fc <citadel_deep_sleep_exit+0x1f8>)
300108fa:	601a      	str	r2, [r3, #0]
300108fc:	3a81      	subs	r2, #129	; 0x81
300108fe:	4b40      	ldr	r3, [pc, #256]	; (30010a00 <citadel_deep_sleep_exit+0x1fc>)
30010900:	601a      	str	r2, [r3, #0]
30010902:	324f      	adds	r2, #79	; 0x4f
30010904:	4b3f      	ldr	r3, [pc, #252]	; (30010a04 <citadel_deep_sleep_exit+0x200>)
30010906:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30010908:	4a3f      	ldr	r2, [pc, #252]	; (30010a08 <citadel_deep_sleep_exit+0x204>)
3001090a:	4839      	ldr	r0, [pc, #228]	; (300109f0 <citadel_deep_sleep_exit+0x1ec>)

	/* 17. Wait PLL locked */
	sys_write32(0x1, CRMU_TIM_TIMER2IntClr);
	sys_write32(0x50, CRMU_TIM_TIMER2Load);
	while (!sys_read32(CRMU_TIM_TIMER2RIS)) {
		if ((sys_read32(CRMU_GENPLL_STATUS) & 0x1) == 0x1)
3001090c:	2101      	movs	r1, #1
3001090e:	6813      	ldr	r3, [r2, #0]
	while (!sys_read32(CRMU_TIM_TIMER2RIS)) {
30010910:	2b00      	cmp	r3, #0
30010912:	d102      	bne.n	3001091a <citadel_deep_sleep_exit+0x116>
30010914:	6803      	ldr	r3, [r0, #0]
		if ((sys_read32(CRMU_GENPLL_STATUS) & 0x1) == 0x1)
30010916:	4219      	tst	r1, r3
30010918:	d0f9      	beq.n	3001090e <citadel_deep_sleep_exit+0x10a>
3001091a:	4b3c      	ldr	r3, [pc, #240]	; (30010a0c <citadel_deep_sleep_exit+0x208>)
3001091c:	6819      	ldr	r1, [r3, #0]
	/*-----------------------------------------------------------
	 * 18. Creating pulse on Bit<6~11>=LOAD enable for all channels
	 *-----------------------------------------------------------
	 */
	/* 18.1 disable PLL channels */
	sys_write32(sys_read32(CRMU_GENPLL_CONTROL1) | 0x00FC0000, CRMU_GENPLL_CONTROL1);
3001091e:	22fc      	movs	r2, #252	; 0xfc
30010920:	0412      	lsls	r2, r2, #16
30010922:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
30010924:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30010926:	681a      	ldr	r2, [r3, #0]

	/* 18.2 enable PLL channels */
	sys_write32(sys_read32(CRMU_GENPLL_CONTROL1) & 0xFF03FFFF, CRMU_GENPLL_CONTROL1);
30010928:	4939      	ldr	r1, [pc, #228]	; (30010a10 <citadel_deep_sleep_exit+0x20c>)
3001092a:	400a      	ands	r2, r1
	*(volatile u32_t *)addr = data;
3001092c:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
3001092e:	4a18      	ldr	r2, [pc, #96]	; (30010990 <citadel_deep_sleep_exit+0x18c>)
30010930:	6813      	ldr	r3, [r2, #0]

	/*------------------------------------------------------------
	 * 19. Remove ISO from pll_lock if PLL gets lock
	 *------------------------------------------------------------
	 */
	sys_write32(sys_read32(CRMU_ISO_CELL_CONTROL) & 0xFFFFEFFF, CRMU_ISO_CELL_CONTROL);
30010932:	4938      	ldr	r1, [pc, #224]	; (30010a14 <citadel_deep_sleep_exit+0x210>)
30010934:	400b      	ands	r3, r1
	*(volatile u32_t *)addr = data;
30010936:	6013      	str	r3, [r2, #0]
30010938:	2200      	movs	r2, #0
3001093a:	4b37      	ldr	r3, [pc, #220]	; (30010a18 <citadel_deep_sleep_exit+0x214>)
3001093c:	601a      	str	r2, [r3, #0]
3001093e:	3201      	adds	r2, #1
30010940:	4b2f      	ldr	r3, [pc, #188]	; (30010a00 <citadel_deep_sleep_exit+0x1fc>)
30010942:	601a      	str	r2, [r3, #0]
30010944:	324f      	adds	r2, #79	; 0x4f
30010946:	4b2f      	ldr	r3, [pc, #188]	; (30010a04 <citadel_deep_sleep_exit+0x200>)
30010948:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
3001094a:	4a2f      	ldr	r2, [pc, #188]	; (30010a08 <citadel_deep_sleep_exit+0x204>)
3001094c:	4833      	ldr	r0, [pc, #204]	; (30010a1c <citadel_deep_sleep_exit+0x218>)

	/* 21. Wait CLK21/41/81 stable */
	sys_write32(0x1, CRMU_TIM_TIMER2IntClr);
	sys_write32(0x50, CRMU_TIM_TIMER2Load);
	while (!sys_read32(CRMU_TIM_TIMER2RIS)) {
		if ((sys_read32(SYS_CLK_SWITCH_READY_STAT) & 0x7) == 0x07)
3001094e:	2107      	movs	r1, #7
30010950:	6813      	ldr	r3, [r2, #0]
	while (!sys_read32(CRMU_TIM_TIMER2RIS)) {
30010952:	2b00      	cmp	r3, #0
30010954:	d103      	bne.n	3001095e <citadel_deep_sleep_exit+0x15a>
30010956:	6803      	ldr	r3, [r0, #0]
		if ((sys_read32(SYS_CLK_SWITCH_READY_STAT) & 0x7) == 0x07)
30010958:	400b      	ands	r3, r1
3001095a:	2b07      	cmp	r3, #7
3001095c:	d1f8      	bne.n	30010950 <citadel_deep_sleep_exit+0x14c>
	*(volatile u32_t *)addr = data;
3001095e:	2200      	movs	r2, #0
30010960:	4b26      	ldr	r3, [pc, #152]	; (300109fc <citadel_deep_sleep_exit+0x1f8>)
30010962:	601a      	str	r2, [r3, #0]
30010964:	2280      	movs	r2, #128	; 0x80
30010966:	0412      	lsls	r2, r2, #16
30010968:	4b10      	ldr	r3, [pc, #64]	; (300109ac <citadel_deep_sleep_exit+0x1a8>)
3001096a:	601a      	str	r2, [r3, #0]
	 */
	sys_write32(0x00800000, CDRU_CLK_DIS_CTRL); /* usbh still disabled */

#ifdef MPROC_PM__ADVANCED_DS
	/* Power On USB PHY */
	citadel_power_on_usb();
3001096c:	f7ff fe7a 	bl	30010664 <citadel_power_on_usb>
30010970:	2301      	movs	r3, #1
30010972:	4a2b      	ldr	r2, [pc, #172]	; (30010a20 <citadel_deep_sleep_exit+0x21c>)
30010974:	6013      	str	r3, [r2, #0]
30010976:	4a2b      	ldr	r2, [pc, #172]	; (30010a24 <citadel_deep_sleep_exit+0x220>)
30010978:	6013      	str	r3, [r2, #0]
3001097a:	4a2b      	ldr	r2, [pc, #172]	; (30010a28 <citadel_deep_sleep_exit+0x224>)
3001097c:	6013      	str	r3, [r2, #0]
	/* 25. Reset A7 */
	sys_write32(0x1, CRMU_RESET_CTRL);
	sys_write32(0x1, CRMU_CHIP_POR_CTRL);

	/* 26.Invoke ihost_config() */
	ihost_config();
3001097e:	f7ff fcad 	bl	300102dc <ihost_config>

	return 1;
}
30010982:	2001      	movs	r0, #1
30010984:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
30010986:	46c0      	nop			; (mov r8, r8)
30010988:	3001c008 	.word	0x3001c008
3001098c:	3001c014 	.word	0x3001c014
30010990:	3001c044 	.word	0x3001c044
30010994:	30024844 	.word	0x30024844
30010998:	3001c00c 	.word	0x3001c00c
3001099c:	fffffeff 	.word	0xfffffeff
300109a0:	3001c040 	.word	0x3001c040
300109a4:	3001c050 	.word	0x3001c050
300109a8:	c000071f 	.word	0xc000071f
300109ac:	3001d08c 	.word	0x3001d08c
300109b0:	3001c048 	.word	0x3001c048
300109b4:	3001d040 	.word	0x3001d040
300109b8:	3001c020 	.word	0x3001c020
300109bc:	3001d028 	.word	0x3001d028
300109c0:	3001d000 	.word	0x3001d000
300109c4:	3001d008 	.word	0x3001d008
300109c8:	3001d00c 	.word	0x3001d00c
300109cc:	f0fffe00 	.word	0xf0fffe00
300109d0:	3001d010 	.word	0x3001d010
300109d4:	ff00ff00 	.word	0xff00ff00
300109d8:	3001d014 	.word	0x3001d014
300109dc:	3001d018 	.word	0x3001d018
300109e0:	0200003d 	.word	0x0200003d
300109e4:	00040006 	.word	0x00040006
300109e8:	00140006 	.word	0x00140006
300109ec:	00080008 	.word	0x00080008
300109f0:	3001d024 	.word	0x3001d024
300109f4:	30024044 	.word	0x30024044
300109f8:	30024c80 	.word	0x30024c80
300109fc:	30023028 	.word	0x30023028
30010a00:	3002302c 	.word	0x3002302c
30010a04:	30023020 	.word	0x30023020
30010a08:	30023030 	.word	0x30023030
30010a0c:	3001d004 	.word	0x3001d004
30010a10:	ff03ffff 	.word	0xff03ffff
30010a14:	ffffefff 	.word	0xffffefff
30010a18:	3001d038 	.word	0x3001d038
30010a1c:	3001d03c 	.word	0x3001d03c
30010a20:	3001c010 	.word	0x3001c010
30010a24:	3001d044 	.word	0x3001d044
30010a28:	3001d048 	.word	0x3001d048

30010a2c <MCU_get_valid_aon_gpio_wakeup_interrupt>:
 * @param aon_gpio_wakeup - The mask of aon GPIOs?
 *
 * @return result
 */
u32_t MCU_get_valid_aon_gpio_wakeup_interrupt(u32_t aon_gpio_wakeup)
{
30010a2c:	b5f0      	push	{r4, r5, r6, r7, lr}
30010a2e:	46c6      	mov	lr, r8
30010a30:	b500      	push	{lr}
30010a32:	b086      	sub	sp, #24
30010a34:	0005      	movs	r5, r0
	CITADEL_PM_ISR_ARGS_s *pm_args = CRMU_GET_PM_ISR_ARGS();
	MPROC_PM_MODE_e cur_pm_state = pm_args->tgt_pm_state;
30010a36:	4b2c      	ldr	r3, [pc, #176]	; (30010ae8 <MCU_get_valid_aon_gpio_wakeup_interrupt+0xbc>)
30010a38:	791a      	ldrb	r2, [r3, #4]

	volatile u32_t aon_gpio_input = 0;
30010a3a:	2300      	movs	r3, #0
30010a3c:	9305      	str	r3, [sp, #20]
	volatile u32_t aon_gpio_mstat = 0;
30010a3e:	9304      	str	r3, [sp, #16]
	volatile u32_t aon_gpio_type = 0;
30010a40:	9303      	str	r3, [sp, #12]
	volatile u32_t aon_gpio_de = 0;
30010a42:	9302      	str	r3, [sp, #8]
	volatile u32_t aon_gpio_edge = 0;
30010a44:	9301      	str	r3, [sp, #4]
	 *
	 * TODO: Should this include DRIPS too
	 *
	 * in deepsleep, mcu already works very slow
	 */
	if (cur_pm_state != MPROC_PM_MODE__DEEPSLEEP
30010a46:	3a05      	subs	r2, #5
30010a48:	2a01      	cmp	r2, #1
30010a4a:	d903      	bls.n	30010a54 <MCU_get_valid_aon_gpio_wakeup_interrupt+0x28>
		&& cur_pm_state != MPROC_PM_MODE__DRIPS)
		MCU_delay(0x10000);
30010a4c:	2080      	movs	r0, #128	; 0x80
30010a4e:	0240      	lsls	r0, r0, #9
30010a50:	f000 fe05 	bl	3001165e <MCU_delay>
	return *(volatile u32_t *)addr;
30010a54:	4b25      	ldr	r3, [pc, #148]	; (30010aec <MCU_get_valid_aon_gpio_wakeup_interrupt+0xc0>)
30010a56:	681b      	ldr	r3, [r3, #0]

	aon_gpio_mstat = sys_read32(GP_INT_MSTAT);
30010a58:	9304      	str	r3, [sp, #16]
30010a5a:	4b25      	ldr	r3, [pc, #148]	; (30010af0 <MCU_get_valid_aon_gpio_wakeup_interrupt+0xc4>)
30010a5c:	681b      	ldr	r3, [r3, #0]
	aon_gpio_type  = sys_read32(GP_INT_TYPE);
30010a5e:	9303      	str	r3, [sp, #12]
30010a60:	4b24      	ldr	r3, [pc, #144]	; (30010af4 <MCU_get_valid_aon_gpio_wakeup_interrupt+0xc8>)
30010a62:	681b      	ldr	r3, [r3, #0]
	aon_gpio_de    = sys_read32(GP_INT_DE);
30010a64:	9302      	str	r3, [sp, #8]
30010a66:	4b24      	ldr	r3, [pc, #144]	; (30010af8 <MCU_get_valid_aon_gpio_wakeup_interrupt+0xcc>)
30010a68:	681b      	ldr	r3, [r3, #0]
	aon_gpio_edge  = sys_read32(GP_INT_EDGE);
30010a6a:	9301      	str	r3, [sp, #4]
30010a6c:	4b23      	ldr	r3, [pc, #140]	; (30010afc <MCU_get_valid_aon_gpio_wakeup_interrupt+0xd0>)
30010a6e:	681b      	ldr	r3, [r3, #0]
	aon_gpio_input = sys_read32(GP_DATA_IN);
30010a70:	9305      	str	r3, [sp, #20]
	u32_t i = 0, retval = 0;
30010a72:	2600      	movs	r6, #0

	for (i = 0; i < MPROC_AON_GPIO_END; i++) {
30010a74:	2400      	movs	r4, #0
		 * != mcu_getbit(aon_gpio_input, i))
		 * 	continue;
		 */
		} else { /* edge */
			if ((!mcu_getbit(aon_gpio_de, i)
				 && mcu_getbit(aon_gpio_edge, i))
30010a76:	2700      	movs	r7, #0
30010a78:	e010      	b.n	30010a9c <MCU_get_valid_aon_gpio_wakeup_interrupt+0x70>
30010a7a:	9801      	ldr	r0, [sp, #4]
30010a7c:	0021      	movs	r1, r4
30010a7e:	f000 fdb2 	bl	300115e6 <mcu_getbit>
30010a82:	0003      	movs	r3, r0
30010a84:	1e58      	subs	r0, r3, #1
30010a86:	4183      	sbcs	r3, r0
30010a88:	4698      	mov	r8, r3
30010a8a:	e020      	b.n	30010ace <MCU_get_valid_aon_gpio_wakeup_interrupt+0xa2>
				!= mcu_getbit(aon_gpio_input, i))
				continue;
		}

		retval = mcu_setbit(retval, i);
30010a8c:	0021      	movs	r1, r4
30010a8e:	0030      	movs	r0, r6
30010a90:	f000 fdae 	bl	300115f0 <mcu_setbit>
30010a94:	0006      	movs	r6, r0
	for (i = 0; i < MPROC_AON_GPIO_END; i++) {
30010a96:	3401      	adds	r4, #1
30010a98:	2c0b      	cmp	r4, #11
30010a9a:	d01f      	beq.n	30010adc <MCU_get_valid_aon_gpio_wakeup_interrupt+0xb0>
		if (!mcu_getbit(aon_gpio_wakeup, i)
30010a9c:	0021      	movs	r1, r4
30010a9e:	0028      	movs	r0, r5
30010aa0:	f000 fda1 	bl	300115e6 <mcu_getbit>
30010aa4:	2800      	cmp	r0, #0
30010aa6:	d0f6      	beq.n	30010a96 <MCU_get_valid_aon_gpio_wakeup_interrupt+0x6a>
			|| !mcu_getbit(aon_gpio_mstat, i))
30010aa8:	9804      	ldr	r0, [sp, #16]
30010aaa:	0021      	movs	r1, r4
30010aac:	f000 fd9b 	bl	300115e6 <mcu_getbit>
30010ab0:	2800      	cmp	r0, #0
30010ab2:	d0f0      	beq.n	30010a96 <MCU_get_valid_aon_gpio_wakeup_interrupt+0x6a>
		if (mcu_getbit(aon_gpio_type, i)) { /* level */
30010ab4:	9803      	ldr	r0, [sp, #12]
30010ab6:	0021      	movs	r1, r4
30010ab8:	f000 fd95 	bl	300115e6 <mcu_getbit>
30010abc:	2800      	cmp	r0, #0
30010abe:	d1e5      	bne.n	30010a8c <MCU_get_valid_aon_gpio_wakeup_interrupt+0x60>
			if ((!mcu_getbit(aon_gpio_de, i)
30010ac0:	9802      	ldr	r0, [sp, #8]
30010ac2:	0021      	movs	r1, r4
30010ac4:	f000 fd8f 	bl	300115e6 <mcu_getbit>
				 && mcu_getbit(aon_gpio_edge, i))
30010ac8:	46b8      	mov	r8, r7
30010aca:	2800      	cmp	r0, #0
30010acc:	d0d5      	beq.n	30010a7a <MCU_get_valid_aon_gpio_wakeup_interrupt+0x4e>
				!= mcu_getbit(aon_gpio_input, i))
30010ace:	9805      	ldr	r0, [sp, #20]
30010ad0:	0021      	movs	r1, r4
30010ad2:	f000 fd88 	bl	300115e6 <mcu_getbit>
			if ((!mcu_getbit(aon_gpio_de, i)
30010ad6:	4580      	cmp	r8, r0
30010ad8:	d1dd      	bne.n	30010a96 <MCU_get_valid_aon_gpio_wakeup_interrupt+0x6a>
30010ada:	e7d7      	b.n	30010a8c <MCU_get_valid_aon_gpio_wakeup_interrupt+0x60>
	}

	return retval;
}
30010adc:	0030      	movs	r0, r6
30010ade:	b006      	add	sp, #24
30010ae0:	bc04      	pop	{r2}
30010ae2:	4690      	mov	r8, r2
30010ae4:	bdf0      	pop	{r4, r5, r6, r7, pc}
30010ae6:	46c0      	nop			; (mov r8, r8)
30010ae8:	30010000 	.word	0x30010000
30010aec:	30024820 	.word	0x30024820
30010af0:	3002480c 	.word	0x3002480c
30010af4:	30024810 	.word	0x30024810
30010af8:	30024814 	.word	0x30024814
30010afc:	30024800 	.word	0x30024800

30010b00 <MCU_SoC_Wakeup_Handler>:
 * @return none
 */
s32_t MCU_SoC_Wakeup_Handler(MPROC_PM_MODE_e cur_pm_state,
			MPROC_PM_MODE_e prv_pm_state,
			u32_t wakeup_msg_code0, u32_t wakeup_msg_code1)
{
30010b00:	b530      	push	{r4, r5, lr}
30010b02:	b083      	sub	sp, #12
30010b04:	0014      	movs	r4, r2
30010b06:	001d      	movs	r5, r3
	volatile u32_t delay = 50000;
30010b08:	4b18      	ldr	r3, [pc, #96]	; (30010b6c <MCU_SoC_Wakeup_Handler+0x6c>)
30010b0a:	9301      	str	r3, [sp, #4]

	if (cur_pm_state >= MPROC_PM_MODE__END)
30010b0c:	2806      	cmp	r0, #6
30010b0e:	d82a      	bhi.n	30010b66 <MCU_SoC_Wakeup_Handler+0x66>
	 */
	cpu_reg32_wr(CRMU_WDT_WDOGCONTROL, 0x1);
#endif

	/* SOME times, the mailbox codes are not right... */
	if (cur_pm_state < MPROC_PM_MODE__SLEEP)
30010b10:	2803      	cmp	r0, #3
30010b12:	d909      	bls.n	30010b28 <MCU_SoC_Wakeup_Handler+0x28>
		/* just wakeup */
		MCU_send_msg_to_mproc(MAILBOX_CODE0__WAKEUP,
		MAILBOX_CODE1__WAKEUP_TEST);
	else if (cur_pm_state == MPROC_PM_MODE__SLEEP) {
30010b14:	2804      	cmp	r0, #4
30010b16:	d00d      	beq.n	30010b34 <MCU_SoC_Wakeup_Handler+0x34>
	}
	/* What Should be done when waking up from DRIPS mode?
	 * While waking out of DRIPS we are sending the same mailbox
	 * code as that of Sleep mode.
	 */
	else if (cur_pm_state == MPROC_PM_MODE__DRIPS) {
30010b18:	2805      	cmp	r0, #5
30010b1a:	d011      	beq.n	30010b40 <MCU_SoC_Wakeup_Handler+0x40>
		while(delay--)
			;
		MCU_send_msg_to_mproc(wakeup_msg_code0, wakeup_msg_code1);
	}

	return 0;
30010b1c:	2300      	movs	r3, #0
	else if (cur_pm_state == MPROC_PM_MODE__DEEPSLEEP) {
30010b1e:	2806      	cmp	r0, #6
30010b20:	d012      	beq.n	30010b48 <MCU_SoC_Wakeup_Handler+0x48>
}
30010b22:	0018      	movs	r0, r3
30010b24:	b003      	add	sp, #12
30010b26:	bd30      	pop	{r4, r5, pc}
		MCU_send_msg_to_mproc(MAILBOX_CODE0__WAKEUP,
30010b28:	4911      	ldr	r1, [pc, #68]	; (30010b70 <MCU_SoC_Wakeup_Handler+0x70>)
30010b2a:	4812      	ldr	r0, [pc, #72]	; (30010b74 <MCU_SoC_Wakeup_Handler+0x74>)
30010b2c:	f000 fe68 	bl	30011800 <MCU_send_msg_to_mproc>
	return 0;
30010b30:	2300      	movs	r3, #0
30010b32:	e7f6      	b.n	30010b22 <MCU_SoC_Wakeup_Handler+0x22>
		MCU_send_msg_to_mproc(wakeup_msg_code0, wakeup_msg_code1);
30010b34:	0029      	movs	r1, r5
30010b36:	0010      	movs	r0, r2
30010b38:	f000 fe62 	bl	30011800 <MCU_send_msg_to_mproc>
	return 0;
30010b3c:	2300      	movs	r3, #0
30010b3e:	e7f0      	b.n	30010b22 <MCU_SoC_Wakeup_Handler+0x22>
		citadel_DRIPS_exit();
30010b40:	f7ff fdaf 	bl	300106a2 <citadel_DRIPS_exit>
	return 0;
30010b44:	2300      	movs	r3, #0
30010b46:	e7ec      	b.n	30010b22 <MCU_SoC_Wakeup_Handler+0x22>
		citadel_deep_sleep_exit();
30010b48:	f7ff fe5c 	bl	30010804 <citadel_deep_sleep_exit>
		delay = 100000;
30010b4c:	4b0a      	ldr	r3, [pc, #40]	; (30010b78 <MCU_SoC_Wakeup_Handler+0x78>)
30010b4e:	9301      	str	r3, [sp, #4]
		while(delay--)
30010b50:	9b01      	ldr	r3, [sp, #4]
30010b52:	1e5a      	subs	r2, r3, #1
30010b54:	9201      	str	r2, [sp, #4]
30010b56:	2b00      	cmp	r3, #0
30010b58:	d1fa      	bne.n	30010b50 <MCU_SoC_Wakeup_Handler+0x50>
		MCU_send_msg_to_mproc(wakeup_msg_code0, wakeup_msg_code1);
30010b5a:	0029      	movs	r1, r5
30010b5c:	0020      	movs	r0, r4
30010b5e:	f000 fe4f 	bl	30011800 <MCU_send_msg_to_mproc>
	return 0;
30010b62:	2300      	movs	r3, #0
30010b64:	e7dd      	b.n	30010b22 <MCU_SoC_Wakeup_Handler+0x22>
		return -1;
30010b66:	2301      	movs	r3, #1
30010b68:	425b      	negs	r3, r3
30010b6a:	e7da      	b.n	30010b22 <MCU_SoC_Wakeup_Handler+0x22>
30010b6c:	0000c350 	.word	0x0000c350
30010b70:	44332211 	.word	0x44332211
30010b74:	11223344 	.word	0x11223344
30010b78:	000186a0 	.word	0x000186a0

30010b7c <m0_aon_gpio_handler>:
 * NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
 ******************************************************************************/
#include "M0.h"

__attribute__ ((interrupt ("IRQ"))) int m0_aon_gpio_handler(void)
{
30010b7c:	b5f0      	push	{r4, r5, r6, r7, lr}
30010b7e:	b085      	sub	sp, #20
	s32_t ret = 0;
	u32_t irq_handled = 0;
	CITADEL_PM_ISR_ARGS_s *pm_args = CRMU_GET_PM_ISR_ARGS();
	MPROC_PM_MODE_e cur_pm_state = pm_args->tgt_pm_state;
30010b80:	4b2d      	ldr	r3, [pc, #180]	; (30010c38 <m0_aon_gpio_handler+0xbc>)
30010b82:	791d      	ldrb	r5, [r3, #4]
#ifdef MPROC_PM__ADV_S_POWER_OFF_PLL
	MPROC_PM_MODE_e prv_pm_state = pm_args->prv_pm_state;
30010b84:	795e      	ldrb	r6, [r3, #5]
#else
	MPROC_PM_MODE_e prv_pm_state = MPROC_PM_MODE__END;
#endif

	u32_t aon_gpio_wakeup = pm_args->aon_gpio_settings.wakeup_src;
30010b86:	689f      	ldr	r7, [r3, #8]
30010b88:	4b2c      	ldr	r3, [pc, #176]	; (30010c3c <m0_aon_gpio_handler+0xc0>)
30010b8a:	681c      	ldr	r4, [r3, #0]
30010b8c:	4b2c      	ldr	r3, [pc, #176]	; (30010c40 <m0_aon_gpio_handler+0xc4>)
30010b8e:	681b      	ldr	r3, [r3, #0]
	/* Put some default wake up Code 1 */
	u32_t wakeup_msg_code1 = MAILBOX_CODE1__WAKEUP_TEST;

	MCU_SET_STATE_IN_WAKEUP_ENTRY_C();

	MCU_memset((void *)&wakeup_code, 0, sizeof(MPROC_PM_WAKEUP_CODE_s));
30010b90:	2210      	movs	r2, #16
30010b92:	2100      	movs	r1, #0
30010b94:	4668      	mov	r0, sp
30010b96:	f000 fd4f 	bl	30011638 <MCU_memset>

	/* AON GPIO intr from valid src */
	if (irq_status & BIT(MCU_AON_GPIO_INTR)) {
30010b9a:	0763      	lsls	r3, r4, #29
30010b9c:	d53a      	bpl.n	30010c14 <m0_aon_gpio_handler+0x98>
30010b9e:	4b29      	ldr	r3, [pc, #164]	; (30010c44 <m0_aon_gpio_handler+0xc8>)
30010ba0:	681c      	ldr	r4, [r3, #0]
		irq_handled = 1;
		/* TODO: This mask is for 6 AON GPIOs,
		 * should it be changed to 0x7ff
		 * since we have 11 AON GPIOs?
		 */
		aon_gpio_mstat = sys_read32(GP_INT_MSTAT) & AON_GPIO_INT_MASK;
30010ba2:	0564      	lsls	r4, r4, #21
30010ba4:	0d64      	lsrs	r4, r4, #21
#ifdef AON_GPIO_EDGE_SENSITIVE_WORKAROUND
		/* this must be called before clearing any aon_gpio interrupt */
		valid_aon_gpio_intr =
		MCU_get_valid_aon_gpio_wakeup_interrupt(aon_gpio_wakeup);
#else
		valid_aon_gpio_intr = aon_gpio_mstat & aon_gpio_wakeup;
30010ba6:	0022      	movs	r2, r4
30010ba8:	403a      	ands	r2, r7
#endif
		/*In RUN mode*/
		if (cur_pm_state < MPROC_PM_MODE__SLEEP) {
30010baa:	2d03      	cmp	r5, #3
30010bac:	d935      	bls.n	30010c1a <m0_aon_gpio_handler+0x9e>
			goto OK_exit;
		} else /*In LP mode*/ {
			/* 1. First check none-wakeup AON_GPIOs
			 * interrupt, don't return
			 */
			if (aon_gpio_mstat & ~aon_gpio_wakeup) {
30010bae:	43fb      	mvns	r3, r7
30010bb0:	4223      	tst	r3, r4
30010bb2:	d003      	beq.n	30010bbc <m0_aon_gpio_handler+0x40>
	*(volatile u32_t *)addr = data;
30010bb4:	4924      	ldr	r1, [pc, #144]	; (30010c48 <m0_aon_gpio_handler+0xcc>)
30010bb6:	600b      	str	r3, [r1, #0]
30010bb8:	4b24      	ldr	r3, [pc, #144]	; (30010c4c <m0_aon_gpio_handler+0xd0>)
30010bba:	601f      	str	r7, [r3, #0]
				sys_write32(aon_gpio_wakeup, GP_INT_MSK);
#endif
			}

			/* 2. Secondly check and clear wakeup AON_GPIOs interrupt */
			if (aon_gpio_mstat & aon_gpio_wakeup) {
30010bbc:	2a00      	cmp	r2, #0
30010bbe:	d029      	beq.n	30010c14 <m0_aon_gpio_handler+0x98>
30010bc0:	4b21      	ldr	r3, [pc, #132]	; (30010c48 <m0_aon_gpio_handler+0xcc>)
30010bc2:	601f      	str	r7, [r3, #0]
			/* Last check valid wakeup AON_GPIOs interrupt */
			if (valid_aon_gpio_intr) {
				if ((MCU_WAKEUP_SOURCE & BIT(MCU_NVIC_AON_GPIO_INTR))) {
					u32_t i = 0;
					MCU_SET_STATE_IN_WAKEUP_ENTRY_C();
					wakeup_code.wakeup_src        = ws_aon_gpio;
30010bc4:	2302      	movs	r3, #2
30010bc6:	4669      	mov	r1, sp
30010bc8:	700b      	strb	r3, [r1, #0]
					wakeup_code.info.aon_gpio.src = valid_aon_gpio_intr;
30010bca:	9201      	str	r2, [sp, #4]
					/* Pick the first AON GPIO that has caused this wake-up
					 * and prepare code1 of the mailbox message.
					 */
					for(i = 0; i < MPROC_AON_GPIO_END; i++) {
						if(valid_aon_gpio_intr & BIT(i)) {
30010bcc:	07d3      	lsls	r3, r2, #31
30010bce:	d42d      	bmi.n	30010c2c <m0_aon_gpio_handler+0xb0>
30010bd0:	2401      	movs	r4, #1
30010bd2:	2101      	movs	r1, #1
30010bd4:	0013      	movs	r3, r2
30010bd6:	40e3      	lsrs	r3, r4
30010bd8:	4219      	tst	r1, r3
30010bda:	d103      	bne.n	30010be4 <m0_aon_gpio_handler+0x68>
					for(i = 0; i < MPROC_AON_GPIO_END; i++) {
30010bdc:	3401      	adds	r4, #1
30010bde:	2c0b      	cmp	r4, #11
30010be0:	d1f8      	bne.n	30010bd4 <m0_aon_gpio_handler+0x58>
	u32_t wakeup_msg_code1 = MAILBOX_CODE1__WAKEUP_TEST;
30010be2:	4c1b      	ldr	r4, [pc, #108]	; (30010c50 <m0_aon_gpio_handler+0xd4>)
		|| cur_pm_state == MPROC_PM_MODE__DRIPS) {
		MCU_SET_STATE_IN_WAKEUP_ENTRY_C();
	}

	/* Copy back wakeup details */
	MCU_memcpy((void *)&pm_args->wakeup, (void *)&wakeup_code,
30010be4:	2210      	movs	r2, #16
30010be6:	4669      	mov	r1, sp
30010be8:	481a      	ldr	r0, [pc, #104]	; (30010c54 <m0_aon_gpio_handler+0xd8>)
30010bea:	f000 fd2e 	bl	3001164a <MCU_memcpy>
			   sizeof(MPROC_PM_WAKEUP_CODE_s));

	/* Do wakeup */
	ret = MCU_SoC_Wakeup_Handler(cur_pm_state, prv_pm_state, wakeup_msg_code0, wakeup_msg_code1);
30010bee:	0023      	movs	r3, r4
30010bf0:	4a19      	ldr	r2, [pc, #100]	; (30010c58 <m0_aon_gpio_handler+0xdc>)
30010bf2:	0031      	movs	r1, r6
30010bf4:	0028      	movs	r0, r5
30010bf6:	f7ff ff83 	bl	30010b00 <MCU_SoC_Wakeup_Handler>
	MCU_SET_STATE_IN_WAKEUP_ENTRY_C();

	/* Clear mailbox values, this will trigger
	 * a mbox interrupt again
	 */
	if (!ret) {
30010bfa:	2800      	cmp	r0, #0
30010bfc:	d108      	bne.n	30010c10 <m0_aon_gpio_handler+0x94>
		 * falling edge intr
		 * will reset A7 again.
		 *
		 * Can't we make this rising edge only?
		 */
		if (cur_pm_state > MPROC_PM_MODE__SLEEP)
30010bfe:	2d04      	cmp	r5, #4
30010c00:	d902      	bls.n	30010c08 <m0_aon_gpio_handler+0x8c>
			pm_args->tgt_pm_state = MPROC_PM_MODE__RUN_200;
30010c02:	2202      	movs	r2, #2
30010c04:	4b0c      	ldr	r3, [pc, #48]	; (30010c38 <m0_aon_gpio_handler+0xbc>)
30010c06:	711a      	strb	r2, [r3, #4]

		MCU_send_msg_to_mcu(MAILBOX_CODE0__NOTHING,
30010c08:	2100      	movs	r1, #0
30010c0a:	2000      	movs	r0, #0
30010c0c:	f000 fe02 	bl	30011814 <MCU_send_msg_to_mcu>
		MAILBOX_CODE1__NOTHING);
	}

	if (cur_pm_state < MPROC_PM_MODE__DEEPSLEEP)
30010c10:	2d05      	cmp	r5, #5
30010c12:	d90d      	bls.n	30010c30 <m0_aon_gpio_handler+0xb4>
	return 0;

OK_exit: /* NO VALID WAKEUP interrupt occurs, direct return */
	MCU_SET_STATE_IN_WAKEUP_ENTRY_C();
	return 0;
}
30010c14:	2000      	movs	r0, #0
30010c16:	b005      	add	sp, #20
30010c18:	bdf0      	pop	{r4, r5, r6, r7, pc}
30010c1a:	4b0b      	ldr	r3, [pc, #44]	; (30010c48 <m0_aon_gpio_handler+0xcc>)
30010c1c:	601c      	str	r4, [r3, #0]
			MCU_SYNC();
30010c1e:	f000 fcdd 	bl	300115dc <MCU_SYNC>
			MCU_send_msg_to_mproc(aon_gpio_mstat,
30010c22:	490e      	ldr	r1, [pc, #56]	; (30010c5c <m0_aon_gpio_handler+0xe0>)
30010c24:	0020      	movs	r0, r4
30010c26:	f000 fdeb 	bl	30011800 <MCU_send_msg_to_mproc>
			goto OK_exit;
30010c2a:	e7f3      	b.n	30010c14 <m0_aon_gpio_handler+0x98>
					for(i = 0; i < MPROC_AON_GPIO_END; i++) {
30010c2c:	2400      	movs	r4, #0
30010c2e:	e7d9      	b.n	30010be4 <m0_aon_gpio_handler+0x68>
		MCU_setup_wakeup_src(MPROC_EXIT_LP);
30010c30:	2000      	movs	r0, #0
30010c32:	f000 ff89 	bl	30011b48 <MCU_setup_wakeup_src>
30010c36:	e7ed      	b.n	30010c14 <m0_aon_gpio_handler+0x98>
30010c38:	30010000 	.word	0x30010000
30010c3c:	30024050 	.word	0x30024050
30010c40:	3002405c 	.word	0x3002405c
30010c44:	30024820 	.word	0x30024820
30010c48:	30024824 	.word	0x30024824
30010c4c:	30024818 	.word	0x30024818
30010c50:	44332211 	.word	0x44332211
30010c54:	30010040 	.word	0x30010040
30010c58:	11223344 	.word	0x11223344
30010c5c:	44002200 	.word	0x44002200

30010c60 <user_mbox_handler>:
 * @param None
 *
 * @return TODO (Ask CRMU ROM devs): What does return value of 1 mean?
 */
s32_t user_mbox_handler(void)
{
30010c60:	b570      	push	{r4, r5, r6, lr}
	return *(volatile u32_t *)addr;
30010c62:	4b43      	ldr	r3, [pc, #268]	; (30010d70 <user_mbox_handler+0x110>)
30010c64:	681c      	ldr	r4, [r3, #0]
30010c66:	4b43      	ldr	r3, [pc, #268]	; (30010d74 <user_mbox_handler+0x114>)
30010c68:	681d      	ldr	r5, [r3, #0]
30010c6a:	4b43      	ldr	r3, [pc, #268]	; (30010d78 <user_mbox_handler+0x118>)
30010c6c:	681a      	ldr	r2, [r3, #0]
30010c6e:	4b43      	ldr	r3, [pc, #268]	; (30010d7c <user_mbox_handler+0x11c>)
30010c70:	681b      	ldr	r3, [r3, #0]
	/* Must check MCU MPROC CRMU event status
	 * prior to decode mbox interrupt
	 * TODO: Why Event3? Is Event3 for Soft
	 * Reset? Is this still valid?
	 */
	if (eventstatus & BIT(MCU_MPROC_CRMU_EVENT3)) {
30010c72:	0319      	lsls	r1, r3, #12
30010c74:	d405      	bmi.n	30010c82 <user_mbox_handler+0x22>

#ifdef MPROC_PM__A7_SMBUS_ISR
	/* Must check MCU MPROC CRMU event
	 * status prior to decode mbox interrupt
	 */
	if (irqstatus & BIT(MCU_SMBUS_INTR)) {
30010c76:	0652      	lsls	r2, r2, #25
30010c78:	d40c      	bmi.n	30010c94 <user_mbox_handler+0x34>
		return 1;
	}
#endif

	/* Clear irq / event */
	if (eventstatus & BIT(MCU_MAILBOX_EVENT)) {
30010c7a:	2b00      	cmp	r3, #0
30010c7c:	db12      	blt.n	30010ca4 <user_mbox_handler+0x44>
	 * i.e. led debug !!!!!
	 */
	MCU_SET_STATE_IN_MBOX_ENTRY_C();

	return 1;
}
30010c7e:	2001      	movs	r0, #1
30010c80:	bd70      	pop	{r4, r5, r6, pc}
		MCU_clear_event(MCU_MPROC_CRMU_EVENT3);
30010c82:	2013      	movs	r0, #19
30010c84:	f000 fdb4 	bl	300117f0 <MCU_clear_event>
		MCU_send_msg_to_mcu(MAILBOX_CODE0_SysSoftReset,
30010c88:	2101      	movs	r1, #1
30010c8a:	4249      	negs	r1, r1
30010c8c:	2000      	movs	r0, #0
30010c8e:	f000 fdc1 	bl	30011814 <MCU_send_msg_to_mcu>
		return 1;
30010c92:	e7f4      	b.n	30010c7e <user_mbox_handler+0x1e>
		MCU_clear_irq(MCU_SMBUS_INTR);
30010c94:	2006      	movs	r0, #6
30010c96:	f000 fd7f 	bl	30011798 <MCU_clear_irq>
		MCU_send_msg_to_mproc(MAILBOX_CODE0__SMBUS_ISR,
30010c9a:	2101      	movs	r1, #1
30010c9c:	4838      	ldr	r0, [pc, #224]	; (30010d80 <user_mbox_handler+0x120>)
30010c9e:	f000 fdaf 	bl	30011800 <MCU_send_msg_to_mproc>
		return 1;
30010ca2:	e7ec      	b.n	30010c7e <user_mbox_handler+0x1e>
		MCU_clear_event(MCU_MAILBOX_EVENT);
30010ca4:	201f      	movs	r0, #31
30010ca6:	f000 fda3 	bl	300117f0 <MCU_clear_event>
		if (code1 == MAILBOX_CODE1__PM) {
30010caa:	2380      	movs	r3, #128	; 0x80
30010cac:	055b      	lsls	r3, r3, #21
30010cae:	429d      	cmp	r5, r3
30010cb0:	d00e      	beq.n	30010cd0 <user_mbox_handler+0x70>
				   && code1 == MAILBOX_CODE1__NOTHING) {
30010cb2:	002b      	movs	r3, r5
30010cb4:	4323      	orrs	r3, r4
		} else if (code0 == MAILBOX_CODE0__NOTHING
30010cb6:	d0e2      	beq.n	30010c7e <user_mbox_handler+0x1e>
		else if (code0 == MAILBOX_CODE0_SysSoftReset
30010cb8:	2c00      	cmp	r4, #0
30010cba:	d1e0      	bne.n	30010c7e <user_mbox_handler+0x1e>
				 && code1 == MAILBOX_CODE1_SysSoftReset) {
30010cbc:	1c6b      	adds	r3, r5, #1
30010cbe:	d046      	beq.n	30010d4e <user_mbox_handler+0xee>
				 && code1 == MAILBOX_CODE1_CrmuWdtReset_L1) {
30010cc0:	1cab      	adds	r3, r5, #2
30010cc2:	d048      	beq.n	30010d56 <user_mbox_handler+0xf6>
				 && code1 == MAILBOX_CODE1_SWWarmReboot_L0) {
30010cc4:	1ceb      	adds	r3, r5, #3
30010cc6:	d1da      	bne.n	30010c7e <user_mbox_handler+0x1e>
	*(volatile u32_t *)addr = data;
30010cc8:	2201      	movs	r2, #1
30010cca:	4b2e      	ldr	r3, [pc, #184]	; (30010d84 <user_mbox_handler+0x124>)
30010ccc:	601a      	str	r2, [r3, #0]
30010cce:	e7d6      	b.n	30010c7e <user_mbox_handler+0x1e>
			if (code0 == MAILBOX_CODE0__RUN_1000) {
30010cd0:	4b2d      	ldr	r3, [pc, #180]	; (30010d88 <user_mbox_handler+0x128>)
30010cd2:	429c      	cmp	r4, r3
30010cd4:	d016      	beq.n	30010d04 <user_mbox_handler+0xa4>
			else if (code0 == MAILBOX_CODE0__RUN_500) {
30010cd6:	4b2d      	ldr	r3, [pc, #180]	; (30010d8c <user_mbox_handler+0x12c>)
30010cd8:	429c      	cmp	r4, r3
30010cda:	d019      	beq.n	30010d10 <user_mbox_handler+0xb0>
			else if (code0 == MAILBOX_CODE0__RUN_187) {
30010cdc:	4b2c      	ldr	r3, [pc, #176]	; (30010d90 <user_mbox_handler+0x130>)
30010cde:	429c      	cmp	r4, r3
30010ce0:	d01c      	beq.n	30010d1c <user_mbox_handler+0xbc>
			else if (code0 == MAILBOX_CODE0__RUN_200) {
30010ce2:	4b2c      	ldr	r3, [pc, #176]	; (30010d94 <user_mbox_handler+0x134>)
30010ce4:	429c      	cmp	r4, r3
30010ce6:	d01f      	beq.n	30010d28 <user_mbox_handler+0xc8>
			} else if (code0 == MAILBOX_CODE0__SLEEP) {
30010ce8:	4b2b      	ldr	r3, [pc, #172]	; (30010d98 <user_mbox_handler+0x138>)
30010cea:	429c      	cmp	r4, r3
30010cec:	d022      	beq.n	30010d34 <user_mbox_handler+0xd4>
			} else if (code0 == MAILBOX_CODE0__DRIPS) {
30010cee:	4b2b      	ldr	r3, [pc, #172]	; (30010d9c <user_mbox_handler+0x13c>)
30010cf0:	429c      	cmp	r4, r3
30010cf2:	d027      	beq.n	30010d44 <user_mbox_handler+0xe4>
			} else if (code0 == MAILBOX_CODE0__DEEPSLEEP) {
30010cf4:	4b2a      	ldr	r3, [pc, #168]	; (30010da0 <user_mbox_handler+0x140>)
30010cf6:	429c      	cmp	r4, r3
30010cf8:	d1c1      	bne.n	30010c7e <user_mbox_handler+0x1e>
				MCU_SoC_do_policy();
30010cfa:	f000 f99f 	bl	3001103c <MCU_SoC_do_policy>
				MCU_SoC_DeepSleep_Handler();
30010cfe:	f000 fabb 	bl	30011278 <MCU_SoC_DeepSleep_Handler>
30010d02:	e01b      	b.n	30010d3c <user_mbox_handler+0xdc>
				MCU_SoC_do_policy();
30010d04:	f000 f99a 	bl	3001103c <MCU_SoC_do_policy>
				MCU_SoC_Run_Handler(MPROC_PM_MODE__RUN_1000);
30010d08:	2000      	movs	r0, #0
30010d0a:	f000 f9a5 	bl	30011058 <MCU_SoC_Run_Handler>
30010d0e:	e7b6      	b.n	30010c7e <user_mbox_handler+0x1e>
				MCU_SoC_do_policy();
30010d10:	f000 f994 	bl	3001103c <MCU_SoC_do_policy>
				MCU_SoC_Run_Handler(MPROC_PM_MODE__RUN_500);
30010d14:	2001      	movs	r0, #1
30010d16:	f000 f99f 	bl	30011058 <MCU_SoC_Run_Handler>
30010d1a:	e7b0      	b.n	30010c7e <user_mbox_handler+0x1e>
				MCU_SoC_do_policy();
30010d1c:	f000 f98e 	bl	3001103c <MCU_SoC_do_policy>
				MCU_SoC_Run_Handler(MPROC_PM_MODE__RUN_187);
30010d20:	2003      	movs	r0, #3
30010d22:	f000 f999 	bl	30011058 <MCU_SoC_Run_Handler>
30010d26:	e7aa      	b.n	30010c7e <user_mbox_handler+0x1e>
				MCU_SoC_do_policy();
30010d28:	f000 f988 	bl	3001103c <MCU_SoC_do_policy>
				MCU_SoC_Run_Handler(MPROC_PM_MODE__RUN_200);
30010d2c:	2002      	movs	r0, #2
30010d2e:	f000 f993 	bl	30011058 <MCU_SoC_Run_Handler>
30010d32:	e7a4      	b.n	30010c7e <user_mbox_handler+0x1e>
				MCU_SoC_do_policy();
30010d34:	f000 f982 	bl	3001103c <MCU_SoC_do_policy>
				MCU_SoC_Sleep_Handler();
30010d38:	f000 f995 	bl	30011066 <MCU_SoC_Sleep_Handler>
		MCU_setup_wakeup_src(MPROC_ENTER_LP);
30010d3c:	2001      	movs	r0, #1
30010d3e:	f000 ff03 	bl	30011b48 <MCU_setup_wakeup_src>
30010d42:	e79c      	b.n	30010c7e <user_mbox_handler+0x1e>
				MCU_SoC_do_policy();
30010d44:	f000 f97a 	bl	3001103c <MCU_SoC_do_policy>
				MCU_SoC_DRIPS_Handler();
30010d48:	f000 f98f 	bl	3001106a <MCU_SoC_DRIPS_Handler>
30010d4c:	e7f6      	b.n	30010d3c <user_mbox_handler+0xdc>
30010d4e:	2201      	movs	r2, #1
30010d50:	4b0c      	ldr	r3, [pc, #48]	; (30010d84 <user_mbox_handler+0x124>)
30010d52:	601a      	str	r2, [r3, #0]
30010d54:	e793      	b.n	30010c7e <user_mbox_handler+0x1e>
30010d56:	4b13      	ldr	r3, [pc, #76]	; (30010da4 <user_mbox_handler+0x144>)
30010d58:	4a13      	ldr	r2, [pc, #76]	; (30010da8 <user_mbox_handler+0x148>)
30010d5a:	601a      	str	r2, [r3, #0]
30010d5c:	2103      	movs	r1, #3
30010d5e:	4a13      	ldr	r2, [pc, #76]	; (30010dac <user_mbox_handler+0x14c>)
30010d60:	6011      	str	r1, [r2, #0]
30010d62:	3902      	subs	r1, #2
30010d64:	4a12      	ldr	r2, [pc, #72]	; (30010db0 <user_mbox_handler+0x150>)
30010d66:	6011      	str	r1, [r2, #0]
30010d68:	2200      	movs	r2, #0
30010d6a:	601a      	str	r2, [r3, #0]
30010d6c:	e787      	b.n	30010c7e <user_mbox_handler+0x1e>
30010d6e:	46c0      	nop			; (mov r8, r8)
30010d70:	30024028 	.word	0x30024028
30010d74:	3002402c 	.word	0x3002402c
30010d78:	30024050 	.word	0x30024050
30010d7c:	3002405c 	.word	0x3002405c
30010d80:	aabbccdd 	.word	0xaabbccdd
30010d84:	300240a0 	.word	0x300240a0
30010d88:	000a1001 	.word	0x000a1001
30010d8c:	000a1002 	.word	0x000a1002
30010d90:	000a1004 	.word	0x000a1004
30010d94:	000a1003 	.word	0x000a1003
30010d98:	000a1010 	.word	0x000a1010
30010d9c:	000a1020 	.word	0x000a1020
30010da0:	000a1030 	.word	0x000a1030
30010da4:	30022c00 	.word	0x30022c00
30010da8:	1acce551 	.word	0x1acce551
30010dac:	30022008 	.word	0x30022008
30010db0:	30022000 	.word	0x30022000

30010db4 <m0_wfi_handler>:
//              - Configure GPIO/timer as wakeup source for M0
//              - M0 return and goes into __wfi() sleep mode
/////////////////////////////////////////////////////////////////////////////////////////////
//
__attribute__ ((interrupt ("IRQ"))) s32_t m0_wfi_handler(void) 
{
30010db4:	b510      	push	{r4, lr}
	return *(volatile u32_t *)addr;
30010db6:	4b11      	ldr	r3, [pc, #68]	; (30010dfc <m0_wfi_handler+0x48>)
30010db8:	6819      	ldr	r1, [r3, #0]
30010dba:	4a11      	ldr	r2, [pc, #68]	; (30010e00 <m0_wfi_handler+0x4c>)
30010dbc:	6813      	ldr	r3, [r2, #0]
	
	u32_t sleep_mode = sys_read32(CRMU_IHOST_POWER_CONFIG);

    // update the log "register" with +1
	sys_write32( sys_read32(CRMU_SLEEP_EVENT_LOG_0) + 1, CRMU_SLEEP_EVENT_LOG_0);
30010dbe:	3301      	adds	r3, #1
	*(volatile u32_t *)addr = data;
30010dc0:	6013      	str	r3, [r2, #0]
	return *(volatile u32_t *)addr;
30010dc2:	4b10      	ldr	r3, [pc, #64]	; (30010e04 <m0_wfi_handler+0x50>)
30010dc4:	681a      	ldr	r2, [r3, #0]
	*(volatile u32_t *)addr = data;
30010dc6:	4b10      	ldr	r3, [pc, #64]	; (30010e08 <m0_wfi_handler+0x54>)
30010dc8:	601a      	str	r2, [r3, #0]
	
    // Save the A7 status to the log "register"
    sys_write32( sys_read32( DRIPS_OR_DEEPSLEEP_REG) , CRMU_SLEEP_EVENT_LOG_1);

    if ( sleep_mode == CPU_PW_STAT_DEEPSLEEP) {
30010dca:	2903      	cmp	r1, #3
30010dcc:	d00b      	beq.n	30010de6 <m0_wfi_handler+0x32>
         // deep sleep 
         MCU_SoC_do_policy();
         MCU_SoC_DeepSleep_Handler();
    } else if ( sleep_mode == CPU_PW_STAT_SLEEP ) {
30010dce:	2901      	cmp	r1, #1
30010dd0:	d00e      	beq.n	30010df0 <m0_wfi_handler+0x3c>
	    // Sleep 
        MCU_SoC_do_policy();
        MCU_SoC_Sleep_Handler();
    } else {
		// DRIPS mode
        MCU_SoC_do_policy();
30010dd2:	f000 f933 	bl	3001103c <MCU_SoC_do_policy>
        MCU_SoC_DRIPS_Handler();
30010dd6:	f000 f948 	bl	3001106a <MCU_SoC_DRIPS_Handler>
30010dda:	2280      	movs	r2, #128	; 0x80
30010ddc:	05d2      	lsls	r2, r2, #23
30010dde:	4b0b      	ldr	r3, [pc, #44]	; (30010e0c <m0_wfi_handler+0x58>)
30010de0:	601a      	str	r2, [r3, #0]
	}
    sys_write32((0x1<<CRMU_MCU_EVENT_CLEAR__MCU_IPROC_STANDBYWFI_EVENT_CLR), CRMU_MCU_EVENT_CLEAR); //Clear SLEEPING event

    return 1;
}
30010de2:	2001      	movs	r0, #1
30010de4:	bd10      	pop	{r4, pc}
         MCU_SoC_do_policy();
30010de6:	f000 f929 	bl	3001103c <MCU_SoC_do_policy>
         MCU_SoC_DeepSleep_Handler();
30010dea:	f000 fa45 	bl	30011278 <MCU_SoC_DeepSleep_Handler>
30010dee:	e7f4      	b.n	30010dda <m0_wfi_handler+0x26>
        MCU_SoC_do_policy();
30010df0:	f000 f924 	bl	3001103c <MCU_SoC_do_policy>
        MCU_SoC_Sleep_Handler();
30010df4:	f000 f937 	bl	30011066 <MCU_SoC_Sleep_Handler>
30010df8:	e7ef      	b.n	30010dda <m0_wfi_handler+0x26>
30010dfa:	46c0      	nop			; (mov r8, r8)
30010dfc:	30024044 	.word	0x30024044
30010e00:	30018f60 	.word	0x30018f60
30010e04:	30024c80 	.word	0x30024c80
30010e08:	30018f64 	.word	0x30018f64
30010e0c:	30024060 	.word	0x30024060

30010e10 <m0_aon_phy0_resume_handler>:
//              - Configure GPIO/timer as wakeup source for M0
//              - M0 return and goes into __wfi() sleep mode
/////////////////////////////////////////////////////////////////////////////////////////////
//
__attribute__ ((interrupt ("IRQ"))) s32_t m0_aon_phy0_resume_handler(void)
{
30010e10:	b570      	push	{r4, r5, r6, lr}
	return *(volatile u32_t *)addr;
30010e12:	4b10      	ldr	r3, [pc, #64]	; (30010e54 <m0_aon_phy0_resume_handler+0x44>)
30010e14:	681c      	ldr	r4, [r3, #0]
30010e16:	4b10      	ldr	r3, [pc, #64]	; (30010e58 <m0_aon_phy0_resume_handler+0x48>)
30010e18:	681d      	ldr	r5, [r3, #0]
30010e1a:	4b10      	ldr	r3, [pc, #64]	; (30010e5c <m0_aon_phy0_resume_handler+0x4c>)
30010e1c:	681b      	ldr	r3, [r3, #0]
	u32_t power_state2 = sys_read32(DRIPS_OR_DEEPSLEEP_REG)& PM_STATE_MASK_SET;
	// make sure we're sleeping

    // Check to see if this is resume event.  Seems to need both event bits set (TBD why)
	mask = (0x1<<(CRMU_MCU_EVENT_MASK__MCU_USBPHY0_WAKE_EVENT_MASK)) | (0x1<<(CRMU_MCU_EVENT_MASK__MCU_USBPHY0_FILTER_EVENT_MASK));
	rd_event = sys_read32(CRMU_MCU_EVENT_STATUS) & mask;
30010e1e:	22c0      	movs	r2, #192	; 0xc0
30010e20:	0192      	lsls	r2, r2, #6
30010e22:	4013      	ands	r3, r2
	*(volatile u32_t *)addr = data;
30010e24:	490e      	ldr	r1, [pc, #56]	; (30010e60 <m0_aon_phy0_resume_handler+0x50>)
30010e26:	600b      	str	r3, [r1, #0]
30010e28:	480e      	ldr	r0, [pc, #56]	; (30010e64 <m0_aon_phy0_resume_handler+0x54>)
30010e2a:	490f      	ldr	r1, [pc, #60]	; (30010e68 <m0_aon_phy0_resume_handler+0x58>)
30010e2c:	6008      	str	r0, [r1, #0]
    /* not resume event. clear and ignore. */
	sys_write32(rd_event, CRMU_MCU_EVENT_CLEAR);
	
	sys_write32(0x55aa55aa, 0x30012e40);
	/* resume event and on DRIPS mode */
	if( (rd_event == mask) && (power_state == CPU_PW_STAT_DEEPSLEEP) && (power_state2 == CPU_PW_STAT_DRIPS) )
30010e2e:	4293      	cmp	r3, r2
30010e30:	d001      	beq.n	30010e36 <m0_aon_phy0_resume_handler+0x26>
		citadel_DRIPS_exit();
		sys_write32(0x55aa55aa, 0x30012e48);
	}

	return 1;
}
30010e32:	2001      	movs	r0, #1
30010e34:	bd70      	pop	{r4, r5, r6, pc}
	if( (rd_event == mask) && (power_state == CPU_PW_STAT_DEEPSLEEP) && (power_state2 == CPU_PW_STAT_DRIPS) )
30010e36:	2c03      	cmp	r4, #3
30010e38:	d1fb      	bne.n	30010e32 <m0_aon_phy0_resume_handler+0x22>
	u32_t power_state2 = sys_read32(DRIPS_OR_DEEPSLEEP_REG)& PM_STATE_MASK_SET;
30010e3a:	23ff      	movs	r3, #255	; 0xff
30010e3c:	401d      	ands	r5, r3
	if( (rd_event == mask) && (power_state == CPU_PW_STAT_DEEPSLEEP) && (power_state2 == CPU_PW_STAT_DRIPS) )
30010e3e:	2d02      	cmp	r5, #2
30010e40:	d1f7      	bne.n	30010e32 <m0_aon_phy0_resume_handler+0x22>
30010e42:	0004      	movs	r4, r0
30010e44:	4b09      	ldr	r3, [pc, #36]	; (30010e6c <m0_aon_phy0_resume_handler+0x5c>)
30010e46:	6018      	str	r0, [r3, #0]
		citadel_DRIPS_exit();
30010e48:	f7ff fc2b 	bl	300106a2 <citadel_DRIPS_exit>
30010e4c:	4b08      	ldr	r3, [pc, #32]	; (30010e70 <m0_aon_phy0_resume_handler+0x60>)
30010e4e:	601c      	str	r4, [r3, #0]
30010e50:	e7ef      	b.n	30010e32 <m0_aon_phy0_resume_handler+0x22>
30010e52:	46c0      	nop			; (mov r8, r8)
30010e54:	30024044 	.word	0x30024044
30010e58:	30024c80 	.word	0x30024c80
30010e5c:	3002405c 	.word	0x3002405c
30010e60:	30024060 	.word	0x30024060
30010e64:	55aa55aa 	.word	0x55aa55aa
30010e68:	30012e40 	.word	0x30012e40
30010e6c:	30012e44 	.word	0x30012e44
30010e70:	30012e48 	.word	0x30012e48

30010e74 <m0_rtc_handler>:
 * NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
 ******************************************************************************/
#include "M0.h"

__attribute__ ((interrupt ("IRQ"))) int m0_rtc_handler(void)
{
30010e74:	b5f0      	push	{r4, r5, r6, r7, lr}
30010e76:	46c6      	mov	lr, r8
30010e78:	b500      	push	{lr}
30010e7a:	b084      	sub	sp, #16
	s32_t ret = 0;
	u32_t irq_handled = 0;
	CITADEL_PM_ISR_ARGS_s *pm_args = CRMU_GET_PM_ISR_ARGS();
	MPROC_PM_MODE_e cur_pm_state = pm_args->tgt_pm_state;
30010e7c:	4b2f      	ldr	r3, [pc, #188]	; (30010f3c <m0_rtc_handler+0xc8>)
30010e7e:	791d      	ldrb	r5, [r3, #4]
#ifdef MPROC_PM__ADV_S_POWER_OFF_PLL
	MPROC_PM_MODE_e prv_pm_state = pm_args->prv_pm_state;
30010e80:	795f      	ldrb	r7, [r3, #5]
#else
	MPROC_PM_MODE_e prv_pm_state = MPROC_PM_MODE__END;
#endif

#ifdef MPROC_PM_USE_RTC_AS_WAKEUP_SRC
	u32_t rtc_wakeup = pm_args->seconds_to_wakeup;
30010e82:	6a9a      	ldr	r2, [r3, #40]	; 0x28
30010e84:	4690      	mov	r8, r2
	u32_t rtc_left_time = pm_args->seconds_left;
30010e86:	6ade      	ldr	r6, [r3, #44]	; 0x2c
	return *(volatile u32_t *)addr;
30010e88:	4b2d      	ldr	r3, [pc, #180]	; (30010f40 <m0_rtc_handler+0xcc>)
30010e8a:	681b      	ldr	r3, [r3, #0]
30010e8c:	4b2d      	ldr	r3, [pc, #180]	; (30010f44 <m0_rtc_handler+0xd0>)
30010e8e:	681c      	ldr	r4, [r3, #0]
	/* Put some default wake up Code 1 */
	u32_t wakeup_msg_code1 = MAILBOX_CODE1__WAKEUP_TEST;

	MCU_SET_STATE_IN_WAKEUP_ENTRY_C();

	MCU_memset((void *)&wakeup_code, 0, sizeof(MPROC_PM_WAKEUP_CODE_s));
30010e90:	2210      	movs	r2, #16
30010e92:	2100      	movs	r1, #0
30010e94:	4668      	mov	r0, sp
30010e96:	f000 fbcf 	bl	30011638 <MCU_memset>

#ifdef MPROC_PM_USE_RTC_AS_WAKEUP_SRC
	/* SPRU RTC periodic event */
	if (event_status & BIT(MCU_SPRU_RTC_PERIODIC_EVENT)) {
30010e9a:	00e3      	lsls	r3, r4, #3
30010e9c:	d404      	bmi.n	30010ea8 <m0_rtc_handler+0x34>
	return 0;

OK_exit: /* NO VALID WAKEUP interrupt occurs, direct return */
	MCU_SET_STATE_IN_WAKEUP_ENTRY_C();
	return 0;
}
30010e9e:	2000      	movs	r0, #0
30010ea0:	b004      	add	sp, #16
30010ea2:	bc04      	pop	{r2}
30010ea4:	4690      	mov	r8, r2
30010ea6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (spru_reg_read(BBL_INTERRUPT_stat)
30010ea8:	2014      	movs	r0, #20
30010eaa:	f000 fe01 	bl	30011ab0 <spru_reg_read>
30010eae:	07c3      	lsls	r3, r0, #31
30010eb0:	d433      	bmi.n	30010f1a <m0_rtc_handler+0xa6>
		MCU_clear_event(MCU_SPRU_RTC_PERIODIC_EVENT);
30010eb2:	201c      	movs	r0, #28
30010eb4:	f000 fc9c 	bl	300117f0 <MCU_clear_event>
		if (cur_pm_state >= MPROC_PM_MODE__SLEEP
30010eb8:	1f2b      	subs	r3, r5, #4
30010eba:	2b02      	cmp	r3, #2
30010ebc:	d8ef      	bhi.n	30010e9e <m0_rtc_handler+0x2a>
			if (rtc_wakeup) {
30010ebe:	4643      	mov	r3, r8
30010ec0:	2b00      	cmp	r3, #0
30010ec2:	d0ec      	beq.n	30010e9e <m0_rtc_handler+0x2a>
				rtc_left_time--;
30010ec4:	3e01      	subs	r6, #1
				pm_args->seconds_left = rtc_left_time;
30010ec6:	4b1d      	ldr	r3, [pc, #116]	; (30010f3c <m0_rtc_handler+0xc8>)
30010ec8:	62de      	str	r6, [r3, #44]	; 0x2c
				if (!rtc_left_time) {
30010eca:	2e00      	cmp	r6, #0
30010ecc:	d1e7      	bne.n	30010e9e <m0_rtc_handler+0x2a>
					wakeup_code.wakeup_src = ws_rtc;
30010ece:	231b      	movs	r3, #27
30010ed0:	466a      	mov	r2, sp
30010ed2:	7013      	strb	r3, [r2, #0]
					MCU_enable_event(MCU_SPRU_RTC_PERIODIC_EVENT, 0);
30010ed4:	2100      	movs	r1, #0
30010ed6:	201c      	movs	r0, #28
30010ed8:	f000 fc70 	bl	300117bc <MCU_enable_event>
	if (cur_pm_state == MPROC_PM_MODE__DEEPSLEEP
30010edc:	1f6b      	subs	r3, r5, #5
30010ede:	2b01      	cmp	r3, #1
30010ee0:	d920      	bls.n	30010f24 <m0_rtc_handler+0xb0>
	MCU_memcpy((void *)&pm_args->wakeup, (void *)&wakeup_code,
30010ee2:	2210      	movs	r2, #16
30010ee4:	4669      	mov	r1, sp
30010ee6:	4818      	ldr	r0, [pc, #96]	; (30010f48 <m0_rtc_handler+0xd4>)
30010ee8:	f000 fbaf 	bl	3001164a <MCU_memcpy>
	ret = MCU_SoC_Wakeup_Handler(cur_pm_state, prv_pm_state, wakeup_msg_code0, wakeup_msg_code1);
30010eec:	2313      	movs	r3, #19
30010eee:	4a17      	ldr	r2, [pc, #92]	; (30010f4c <m0_rtc_handler+0xd8>)
30010ef0:	0039      	movs	r1, r7
30010ef2:	0028      	movs	r0, r5
30010ef4:	f7ff fe04 	bl	30010b00 <MCU_SoC_Wakeup_Handler>
	if (!ret) {
30010ef8:	2800      	cmp	r0, #0
30010efa:	d108      	bne.n	30010f0e <m0_rtc_handler+0x9a>
		if (cur_pm_state > MPROC_PM_MODE__SLEEP)
30010efc:	2d04      	cmp	r5, #4
30010efe:	d902      	bls.n	30010f06 <m0_rtc_handler+0x92>
			pm_args->tgt_pm_state = MPROC_PM_MODE__RUN_200;
30010f00:	2202      	movs	r2, #2
30010f02:	4b0e      	ldr	r3, [pc, #56]	; (30010f3c <m0_rtc_handler+0xc8>)
30010f04:	711a      	strb	r2, [r3, #4]
		MCU_send_msg_to_mcu(MAILBOX_CODE0__NOTHING,
30010f06:	2100      	movs	r1, #0
30010f08:	2000      	movs	r0, #0
30010f0a:	f000 fc83 	bl	30011814 <MCU_send_msg_to_mcu>
	if (cur_pm_state < MPROC_PM_MODE__DEEPSLEEP)
30010f0e:	2d05      	cmp	r5, #5
30010f10:	d8c5      	bhi.n	30010e9e <m0_rtc_handler+0x2a>
		MCU_setup_wakeup_src(MPROC_EXIT_LP);
30010f12:	2000      	movs	r0, #0
30010f14:	f000 fe18 	bl	30011b48 <MCU_setup_wakeup_src>
30010f18:	e7c1      	b.n	30010e9e <m0_rtc_handler+0x2a>
			spru_reg_write(BBL_INTERRUPT_clr,
30010f1a:	2101      	movs	r1, #1
30010f1c:	2018      	movs	r0, #24
30010f1e:	f000 fdd1 	bl	30011ac4 <spru_reg_write>
30010f22:	e7c6      	b.n	30010eb2 <m0_rtc_handler+0x3e>
			spru_reg_write(BBL_INTERRUPT_clr, BIT(BBL_INTERRUPT_clr__bbl_period_intr_clr));
30010f24:	2101      	movs	r1, #1
30010f26:	2018      	movs	r0, #24
30010f28:	f000 fdcc 	bl	30011ac4 <spru_reg_write>
			MCU_enable_event(MCU_SPRU_RTC_PERIODIC_EVENT, 0);
30010f2c:	2100      	movs	r1, #0
30010f2e:	201c      	movs	r0, #28
30010f30:	f000 fc44 	bl	300117bc <MCU_enable_event>
			MCU_clear_event(MCU_SPRU_RTC_PERIODIC_EVENT);
30010f34:	201c      	movs	r0, #28
30010f36:	f000 fc5b 	bl	300117f0 <MCU_clear_event>
30010f3a:	e7d2      	b.n	30010ee2 <m0_rtc_handler+0x6e>
30010f3c:	30010000 	.word	0x30010000
30010f40:	30024050 	.word	0x30024050
30010f44:	3002405c 	.word	0x3002405c
30010f48:	30010040 	.word	0x30010040
30010f4c:	11223344 	.word	0x11223344

30010f50 <user_fastxip_workaround>:
 *
 * @return N/A
 *
 */
void user_fastxip_workaround(void)
{
30010f50:	b5f0      	push	{r4, r5, r6, r7, lr}
30010f52:	46c6      	mov	lr, r8
30010f54:	b500      	push	{lr}
	*(volatile u32_t *)addr = data;
30010f56:	4b17      	ldr	r3, [pc, #92]	; (30010fb4 <user_fastxip_workaround+0x64>)
30010f58:	4698      	mov	r8, r3
30010f5a:	2300      	movs	r3, #0
30010f5c:	4642      	mov	r2, r8
30010f5e:	6013      	str	r3, [r2, #0]
	sys_write32(0 , SMU_CFG_1);

	/* the other windows */
	for (win = 1; win < SMU_CFG_NUM_WINDOWS; win++)
	{
		sys_write32(fastxip->smau_win_base_a[win - 1], SMU_WIN_BASE_0 + (win * 4));
30010f60:	4a15      	ldr	r2, [pc, #84]	; (30010fb8 <user_fastxip_workaround+0x68>)
30010f62:	2688      	movs	r6, #136	; 0x88
30010f64:	4b15      	ldr	r3, [pc, #84]	; (30010fbc <user_fastxip_workaround+0x6c>)
30010f66:	5990      	ldr	r0, [r2, r6]
30010f68:	6018      	str	r0, [r3, #0]
		sys_write32(fastxip->smau_win_size_a[win - 1], SMU_WIN_SIZE_0 + (win * 4));
30010f6a:	2594      	movs	r5, #148	; 0x94
30010f6c:	4b14      	ldr	r3, [pc, #80]	; (30010fc0 <user_fastxip_workaround+0x70>)
30010f6e:	5950      	ldr	r0, [r2, r5]
30010f70:	6018      	str	r0, [r3, #0]
		sys_write32(fastxip->smau_hmac_base_a[win - 1], SMU_HMAC_BASE_0 + (win * 4));
30010f72:	24a0      	movs	r4, #160	; 0xa0
30010f74:	4b13      	ldr	r3, [pc, #76]	; (30010fc4 <user_fastxip_workaround+0x74>)
30010f76:	5910      	ldr	r0, [r2, r4]
30010f78:	6018      	str	r0, [r3, #0]
		sys_write32(fastxip->smau_win_base_a[win - 1], SMU_WIN_BASE_0 + (win * 4));
30010f7a:	4b13      	ldr	r3, [pc, #76]	; (30010fc8 <user_fastxip_workaround+0x78>)
30010f7c:	2084      	movs	r0, #132	; 0x84
30010f7e:	4f13      	ldr	r7, [pc, #76]	; (30010fcc <user_fastxip_workaround+0x7c>)
30010f80:	5819      	ldr	r1, [r3, r0]
30010f82:	6039      	str	r1, [r7, #0]
		sys_write32(fastxip->smau_win_size_a[win - 1], SMU_WIN_SIZE_0 + (win * 4));
30010f84:	2790      	movs	r7, #144	; 0x90
30010f86:	59d9      	ldr	r1, [r3, r7]
30010f88:	4f11      	ldr	r7, [pc, #68]	; (30010fd0 <user_fastxip_workaround+0x80>)
30010f8a:	6039      	str	r1, [r7, #0]
		sys_write32(fastxip->smau_hmac_base_a[win - 1], SMU_HMAC_BASE_0 + (win * 4));
30010f8c:	279c      	movs	r7, #156	; 0x9c
30010f8e:	59d9      	ldr	r1, [r3, r7]
30010f90:	4f10      	ldr	r7, [pc, #64]	; (30010fd4 <user_fastxip_workaround+0x84>)
30010f92:	6039      	str	r1, [r7, #0]
		sys_write32(fastxip->smau_win_base_a[win - 1], SMU_WIN_BASE_0 + (win * 4));
30010f94:	599f      	ldr	r7, [r3, r6]
30010f96:	4e10      	ldr	r6, [pc, #64]	; (30010fd8 <user_fastxip_workaround+0x88>)
30010f98:	6037      	str	r7, [r6, #0]
		sys_write32(fastxip->smau_win_size_a[win - 1], SMU_WIN_SIZE_0 + (win * 4));
30010f9a:	595e      	ldr	r6, [r3, r5]
30010f9c:	4d0f      	ldr	r5, [pc, #60]	; (30010fdc <user_fastxip_workaround+0x8c>)
30010f9e:	602e      	str	r6, [r5, #0]
		sys_write32(fastxip->smau_hmac_base_a[win - 1], SMU_HMAC_BASE_0 + (win * 4));
30010fa0:	591c      	ldr	r4, [r3, r4]
30010fa2:	4b0f      	ldr	r3, [pc, #60]	; (30010fe0 <user_fastxip_workaround+0x90>)
30010fa4:	601c      	str	r4, [r3, #0]
	/* restore SMU_CFG_1:
	 * Old SMU_CFG_1 value saved at CRMU_M0_SCRAM_START+0x2C
	 *
	 * sys_write32(fastxip->qspi_ctrl_cfg, SMU_CFG_1);
	 */
	sys_write32(fastxip->smau_cfg1, SMU_CFG_1);
30010fa6:	5813      	ldr	r3, [r2, r0]
30010fa8:	4641      	mov	r1, r8
30010faa:	600b      	str	r3, [r1, #0]

	/* jump to real AAI image XIP address in flash
	 * AAI entry saved at CRMU_M0_SCRAM_START+0x3C
	 */
	((void (*)(void))fastxip->smc_cfg)();
30010fac:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
30010fae:	4798      	blx	r3
30010fb0:	e7fe      	b.n	30010fb0 <user_fastxip_workaround+0x60>
30010fb2:	46c0      	nop			; (mov r8, r8)
30010fb4:	50020404 	.word	0x50020404
30010fb8:	30018000 	.word	0x30018000
30010fbc:	50020450 	.word	0x50020450
30010fc0:	50020460 	.word	0x50020460
30010fc4:	50020440 	.word	0x50020440
30010fc8:	30018008 	.word	0x30018008
30010fcc:	50020454 	.word	0x50020454
30010fd0:	50020464 	.word	0x50020464
30010fd4:	50020444 	.word	0x50020444
30010fd8:	50020458 	.word	0x50020458
30010fdc:	50020468 	.word	0x50020468
30010fe0:	50020448 	.word	0x50020448

30010fe4 <crmu_cfg_xtal_pwr_off>:
	return *(volatile u32_t *)addr;
30010fe4:	4b06      	ldr	r3, [pc, #24]	; (30011000 <crmu_cfg_xtal_pwr_off+0x1c>)
30010fe6:	681a      	ldr	r2, [r3, #0]
	 *
	 * CRMU_XTAL_CHANNEL_CONTROL1[28] (CRMU_XTAL_PWR_DET_ENA_REG) to 0,
	 * CRMU_XTAL_CHANNEL_CONTROL1[27] (CRMU_XTAL_RESETB) to 0
	 * (0 - XTAL Channels control bits reset, 1 - XTAL Channels active)
	 */
	sys_write32(sys_read32(CRMU_XTAL_CHANNEL_CONTROL1) & (~(3 << 27)), CRMU_XTAL_CHANNEL_CONTROL1);
30010fe8:	4906      	ldr	r1, [pc, #24]	; (30011004 <crmu_cfg_xtal_pwr_off+0x20>)
30010fea:	400a      	ands	r2, r1
	*(volatile u32_t *)addr = data;
30010fec:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30010fee:	681a      	ldr	r2, [r3, #0]
	 * CRMU_XTAL_CMOS_CH_EN	3:0	Active high enables for XTAL clock.
	 * 0 - Gen PLL ref clock, 1 - USB Phy ref clock, Rest- Unused.
	 * When en=0, that particular xtal channel is gated off.
	 * Default: 0x3 (Both Gen PLL & USB Phy Ref clock channels are ON)
	 */
	sys_write32(sys_read32(CRMU_XTAL_CHANNEL_CONTROL1) & (~0xF), CRMU_XTAL_CHANNEL_CONTROL1);
30010ff0:	210f      	movs	r1, #15
30010ff2:	438a      	bics	r2, r1
	*(volatile u32_t *)addr = data;
30010ff4:	601a      	str	r2, [r3, #0]
30010ff6:	4b04      	ldr	r3, [pc, #16]	; (30011008 <crmu_cfg_xtal_pwr_off+0x24>)
30010ff8:	6019      	str	r1, [r3, #0]
30010ffa:	220e      	movs	r2, #14
30010ffc:	601a      	str	r2, [r3, #0]
	 */
	sys_write32(0xF, CRMU_XTAL_POWER_DOWN);

	/* powering down the XTAL */
	sys_write32(0xE, CRMU_XTAL_POWER_DOWN);
}
30010ffe:	4770      	bx	lr
30011000:	3001c000 	.word	0x3001c000
30011004:	e7ffffff 	.word	0xe7ffffff
30011008:	3001c060 	.word	0x3001c060

3001100c <citadel_power_off_IO_ring>:
	return *(volatile u32_t *)addr;
3001100c:	4b07      	ldr	r3, [pc, #28]	; (3001102c <citadel_power_off_IO_ring+0x20>)
3001100e:	681a      	ldr	r2, [r3, #0]
	 * drive AON GPIO 2 High to turn IO Ring Power Off. Once OTP is
	 * programmed this need to be programmed accordingly.
	 *
	 */
	/* Set Bit 2 of GP_OUT_EN register to enable output on AON GPIO 2 */
	sys_write32((sys_read32(GP_OUT_EN)) | 0x4, GP_OUT_EN);
30011010:	2104      	movs	r1, #4
30011012:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
30011014:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30011016:	4b06      	ldr	r3, [pc, #24]	; (30011030 <citadel_power_off_IO_ring+0x24>)
30011018:	681a      	ldr	r2, [r3, #0]
	/* Clear Bit 2 of GP_RES_EN register to disable pull-up / pull-down
	 * of On-Chip GPIO Pad Resister for AON GPIO 2.
	 */
	sys_write32((sys_read32(GP_RES_EN)) & 0x7fb, GP_RES_EN);
3001101a:	4806      	ldr	r0, [pc, #24]	; (30011034 <citadel_power_off_IO_ring+0x28>)
3001101c:	4002      	ands	r2, r0
	*(volatile u32_t *)addr = data;
3001101e:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30011020:	4a05      	ldr	r2, [pc, #20]	; (30011038 <citadel_power_off_IO_ring+0x2c>)
30011022:	6813      	ldr	r3, [r2, #0]
	/* Set Bit 2 of GP_DATA_OUT register to '1' to Turn Off
	 * Power to all of A7's GPIOs (non-AON).
	 */
	sys_write32((sys_read32(GP_DATA_OUT)) | 0x4, GP_DATA_OUT);
30011024:	430b      	orrs	r3, r1
	*(volatile u32_t *)addr = data;
30011026:	6013      	str	r3, [r2, #0]
#endif
}
30011028:	4770      	bx	lr
3001102a:	46c0      	nop			; (mov r8, r8)
3001102c:	30024808 	.word	0x30024808
30011030:	30024838 	.word	0x30024838
30011034:	000007fb 	.word	0x000007fb
30011038:	30024804 	.word	0x30024804

3001103c <MCU_SoC_do_policy>:
 */
s32_t MCU_SoC_do_policy(void)
{
	CITADEL_PM_ISR_ARGS_s *pm_args = CRMU_GET_PM_ISR_ARGS();

	if (pm_args->do_policy == 0 || pm_args->tgt_pm_state >= MPROC_PM_MODE__END)
3001103c:	4b05      	ldr	r3, [pc, #20]	; (30011054 <MCU_SoC_do_policy+0x18>)
3001103e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
30011040:	2000      	movs	r0, #0
30011042:	2b00      	cmp	r3, #0
30011044:	d005      	beq.n	30011052 <MCU_SoC_do_policy+0x16>
30011046:	4b03      	ldr	r3, [pc, #12]	; (30011054 <MCU_SoC_do_policy+0x18>)
30011048:	791b      	ldrb	r3, [r3, #4]
3001104a:	2206      	movs	r2, #6
3001104c:	429a      	cmp	r2, r3
3001104e:	4140      	adcs	r0, r0
30011050:	b2c0      	uxtb	r0, r0
		return 0;

	/* do all user defined policies... */

	return 1;
}
30011052:	4770      	bx	lr
30011054:	30010000 	.word	0x30010000

30011058 <MCU_SoC_Run_Handler>:
 * @param State
 *
 * @return result
 */
s32_t MCU_SoC_Run_Handler(MPROC_PM_MODE_e state)
{
30011058:	b510      	push	{r4, lr}
	s32_t ret = 0;

	/* A7 need not stay in WFI state, directly wakeup ihost in case */
	MCU_send_msg_to_mproc(MAILBOX_CODE0__NOTHING, MAILBOX_CODE0__NOTHING);
3001105a:	2100      	movs	r1, #0
3001105c:	2000      	movs	r0, #0
3001105e:	f000 fbcf 	bl	30011800 <MCU_send_msg_to_mproc>

	return ret;
}
30011062:	2000      	movs	r0, #0
30011064:	bd10      	pop	{r4, pc}

30011066 <MCU_SoC_Sleep_Handler>:
#else
	MCU_set_pdsys_master_clock_gating(1); /* simple sleep */
#endif

	return 0;
}
30011066:	2000      	movs	r0, #0
30011068:	4770      	bx	lr

3001106a <MCU_SoC_DRIPS_Handler>:
 * @param None
 *
 * @return result
 */
s32_t MCU_SoC_DRIPS_Handler(void)
{
3001106a:	b510      	push	{r4, lr}
3001106c:	b082      	sub	sp, #8
	return *(volatile u32_t *)addr;
3001106e:	4b63      	ldr	r3, [pc, #396]	; (300111fc <MCU_SoC_DRIPS_Handler+0x192>)
30011070:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(A7_CRM_DOMAIN_4_CONTROL) | (1 << A7_CRM_DOMAIN_4_CONTROL__DOMAIN_4_ISO_MEM), A7_CRM_DOMAIN_4_CONTROL);
30011072:	2140      	movs	r1, #64	; 0x40
30011074:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
30011076:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30011078:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(A7_CRM_DOMAIN_4_CONTROL) | (1 << A7_CRM_DOMAIN_4_CONTROL__DOMAIN_4_ISO_I_O), A7_CRM_DOMAIN_4_CONTROL);
3001107a:	393f      	subs	r1, #63	; 0x3f
3001107c:	430a      	orrs	r2, r1
	*(volatile u32_t *)addr = data;
3001107e:	601a      	str	r2, [r3, #0]

/* Memory bit manipulation functions */

static inline void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	u32_t temp = *(volatile u32_t *)addr;
30011080:	681a      	ldr	r2, [r3, #0]

	*(volatile u32_t *)addr = temp | (1 << bit);
30011082:	2008      	movs	r0, #8
30011084:	4302      	orrs	r2, r0
30011086:	601a      	str	r2, [r3, #0]
	u32_t temp = *(volatile u32_t *)addr;
30011088:	4a5d      	ldr	r2, [pc, #372]	; (30011200 <MCU_SoC_DRIPS_Handler+0x196>)
3001108a:	6810      	ldr	r0, [r2, #0]
	*(volatile u32_t *)addr = temp | (1 << bit);
3001108c:	2410      	movs	r4, #16
3001108e:	4320      	orrs	r0, r4
30011090:	6010      	str	r0, [r2, #0]
	u32_t temp = *(volatile u32_t *)addr;
30011092:	6810      	ldr	r0, [r2, #0]
	*(volatile u32_t *)addr = temp | (1 << bit);
30011094:	4308      	orrs	r0, r1
30011096:	6010      	str	r0, [r2, #0]
	u32_t temp = *(volatile u32_t *)addr;
30011098:	681a      	ldr	r2, [r3, #0]
	*(volatile u32_t *)addr = temp | (1 << bit);
3001109a:	2080      	movs	r0, #128	; 0x80
3001109c:	4302      	orrs	r2, r0
3001109e:	601a      	str	r2, [r3, #0]
	*(volatile u32_t *)addr = data;
300110a0:	2300      	movs	r3, #0
300110a2:	4a58      	ldr	r2, [pc, #352]	; (30011204 <MCU_SoC_DRIPS_Handler+0x19a>)
300110a4:	6013      	str	r3, [r2, #0]
300110a6:	4a58      	ldr	r2, [pc, #352]	; (30011208 <MCU_SoC_DRIPS_Handler+0x19e>)
300110a8:	6013      	str	r3, [r2, #0]
}

static inline void sys_clear_bit(mem_addr_t addr, unsigned int bit)
{
	u32_t temp = *(volatile u32_t *)addr;
300110aa:	4b58      	ldr	r3, [pc, #352]	; (3001120c <MCU_SoC_DRIPS_Handler+0x1a2>)
300110ac:	681a      	ldr	r2, [r3, #0]

	*(volatile u32_t *)addr = temp & ~(1 << bit);
300110ae:	438a      	bics	r2, r1
300110b0:	601a      	str	r2, [r3, #0]
	u32_t temp = *(volatile u32_t *)addr;
300110b2:	681a      	ldr	r2, [r3, #0]
	*(volatile u32_t *)addr = temp & ~(1 << bit);
300110b4:	3101      	adds	r1, #1
300110b6:	438a      	bics	r2, r1
300110b8:	601a      	str	r2, [r3, #0]
	local_spare0 = 0xFe;
300110ba:	23fe      	movs	r3, #254	; 0xfe
300110bc:	9300      	str	r3, [sp, #0]
	while (local_spare0 != 0x0) {
300110be:	9b00      	ldr	r3, [sp, #0]
300110c0:	2b00      	cmp	r3, #0
300110c2:	d010      	beq.n	300110e6 <MCU_SoC_DRIPS_Handler+0x7c>
	*(volatile u32_t *)addr = data;
300110c4:	4c52      	ldr	r4, [pc, #328]	; (30011210 <MCU_SoC_DRIPS_Handler+0x1a6>)
	return *(volatile u32_t *)addr;
300110c6:	4853      	ldr	r0, [pc, #332]	; (30011214 <MCU_SoC_DRIPS_Handler+0x1aa>)
		while ((sys_read32(A7_CRM_PWROK_OUT_DOMAIN_4) & 0xff)
300110c8:	31fd      	adds	r1, #253	; 0xfd
		sys_write32(local_spare0, A7_CRM_PWROK_IN_DOMAIN_4);
300110ca:	9b00      	ldr	r3, [sp, #0]
	*(volatile u32_t *)addr = data;
300110cc:	6023      	str	r3, [r4, #0]
	return *(volatile u32_t *)addr;
300110ce:	6803      	ldr	r3, [r0, #0]
			!=local_spare0)
300110d0:	9a00      	ldr	r2, [sp, #0]
		while ((sys_read32(A7_CRM_PWROK_OUT_DOMAIN_4) & 0xff)
300110d2:	400b      	ands	r3, r1
300110d4:	4293      	cmp	r3, r2
300110d6:	d1fa      	bne.n	300110ce <MCU_SoC_DRIPS_Handler+0x64>
		local_spare0 = ((local_spare0 << 1 ) & 0xff);
300110d8:	9b00      	ldr	r3, [sp, #0]
300110da:	005b      	lsls	r3, r3, #1
300110dc:	400b      	ands	r3, r1
300110de:	9300      	str	r3, [sp, #0]
	while (local_spare0 != 0x0) {
300110e0:	9b00      	ldr	r3, [sp, #0]
300110e2:	2b00      	cmp	r3, #0
300110e4:	d1f1      	bne.n	300110ca <MCU_SoC_DRIPS_Handler+0x60>
	local_spare1 = 0xFe;
300110e6:	23fe      	movs	r3, #254	; 0xfe
300110e8:	9301      	str	r3, [sp, #4]
	while (local_spare1 != 0x0) {
300110ea:	9b01      	ldr	r3, [sp, #4]
300110ec:	2b00      	cmp	r3, #0
300110ee:	d010      	beq.n	30011112 <MCU_SoC_DRIPS_Handler+0xa8>
	*(volatile u32_t *)addr = data;
300110f0:	4c49      	ldr	r4, [pc, #292]	; (30011218 <MCU_SoC_DRIPS_Handler+0x1ae>)
	return *(volatile u32_t *)addr;
300110f2:	484a      	ldr	r0, [pc, #296]	; (3001121c <MCU_SoC_DRIPS_Handler+0x1b2>)
		while ((sys_read32(A7_CRM_PWRON_OUT_DOMAIN_4) & 0xff)
300110f4:	21ff      	movs	r1, #255	; 0xff
		sys_write32(local_spare1, A7_CRM_PWRON_IN_DOMAIN_4);
300110f6:	9b01      	ldr	r3, [sp, #4]
	*(volatile u32_t *)addr = data;
300110f8:	6023      	str	r3, [r4, #0]
	return *(volatile u32_t *)addr;
300110fa:	6803      	ldr	r3, [r0, #0]
			!=local_spare1)
300110fc:	9a01      	ldr	r2, [sp, #4]
		while ((sys_read32(A7_CRM_PWRON_OUT_DOMAIN_4) & 0xff)
300110fe:	400b      	ands	r3, r1
30011100:	4293      	cmp	r3, r2
30011102:	d1fa      	bne.n	300110fa <MCU_SoC_DRIPS_Handler+0x90>
		local_spare1 = ((local_spare1 << 1 ) & 0xff);
30011104:	9b01      	ldr	r3, [sp, #4]
30011106:	005b      	lsls	r3, r3, #1
30011108:	400b      	ands	r3, r1
3001110a:	9301      	str	r3, [sp, #4]
	while (local_spare1 != 0x0) {
3001110c:	9b01      	ldr	r3, [sp, #4]
3001110e:	2b00      	cmp	r3, #0
30011110:	d1f1      	bne.n	300110f6 <MCU_SoC_DRIPS_Handler+0x8c>
30011112:	4a43      	ldr	r2, [pc, #268]	; (30011220 <MCU_SoC_DRIPS_Handler+0x1b6>)
30011114:	6813      	ldr	r3, [r2, #0]
	sys_write32(sys_read32(ADC0_ANALOG_CONTROL) & (~(0x1 << 10)), ADC0_ANALOG_CONTROL);
30011116:	4943      	ldr	r1, [pc, #268]	; (30011224 <MCU_SoC_DRIPS_Handler+0x1ba>)
30011118:	400b      	ands	r3, r1
	*(volatile u32_t *)addr = data;
3001111a:	6013      	str	r3, [r2, #0]
	return *(volatile u32_t *)addr;
3001111c:	4a42      	ldr	r2, [pc, #264]	; (30011228 <MCU_SoC_DRIPS_Handler+0x1be>)
3001111e:	6813      	ldr	r3, [r2, #0]
	sys_write32(sys_read32(ADC1_ANALOG_CONTROL) & (~(0x1 << 10)), ADC1_ANALOG_CONTROL);
30011120:	400b      	ands	r3, r1
	*(volatile u32_t *)addr = data;
30011122:	6013      	str	r3, [r2, #0]
	return *(volatile u32_t *)addr;
30011124:	4a41      	ldr	r2, [pc, #260]	; (3001122c <MCU_SoC_DRIPS_Handler+0x1c2>)
30011126:	6813      	ldr	r3, [r2, #0]
	sys_write32(sys_read32(ADC2_ANALOG_CONTROL) & (~(0x1 << 10)), ADC2_ANALOG_CONTROL);
30011128:	400b      	ands	r3, r1
	*(volatile u32_t *)addr = data;
3001112a:	6013      	str	r3, [r2, #0]
3001112c:	2207      	movs	r2, #7
3001112e:	4b40      	ldr	r3, [pc, #256]	; (30011230 <MCU_SoC_DRIPS_Handler+0x1c6>)
30011130:	601a      	str	r2, [r3, #0]
30011132:	2000      	movs	r0, #0
30011134:	4b3f      	ldr	r3, [pc, #252]	; (30011234 <MCU_SoC_DRIPS_Handler+0x1ca>)
30011136:	6018      	str	r0, [r3, #0]
	return *(volatile u32_t *)addr;
30011138:	483f      	ldr	r0, [pc, #252]	; (30011238 <MCU_SoC_DRIPS_Handler+0x1ce>)
3001113a:	6804      	ldr	r4, [r0, #0]
	sys_write32(sys_read32(CRMU_GENPLL_CONTROL1) | 0x00FC0000, CRMU_GENPLL_CONTROL1);
3001113c:	23fc      	movs	r3, #252	; 0xfc
3001113e:	041b      	lsls	r3, r3, #16
30011140:	4323      	orrs	r3, r4
	*(volatile u32_t *)addr = data;
30011142:	6003      	str	r3, [r0, #0]
	return *(volatile u32_t *)addr;
30011144:	483d      	ldr	r0, [pc, #244]	; (3001123c <MCU_SoC_DRIPS_Handler+0x1d2>)
30011146:	6804      	ldr	r4, [r0, #0]
	sys_write32(sys_read32(CRMU_ISO_CELL_CONTROL) | (1 << CRMU_ISO_CELL_CONTROL__CRMU_ISO_PDSYS_PLL_LOCKED), CRMU_ISO_CELL_CONTROL);
30011148:	2380      	movs	r3, #128	; 0x80
3001114a:	015b      	lsls	r3, r3, #5
3001114c:	4323      	orrs	r3, r4
	*(volatile u32_t *)addr = data;
3001114e:	6003      	str	r3, [r0, #0]
30011150:	2001      	movs	r0, #1
30011152:	4b3b      	ldr	r3, [pc, #236]	; (30011240 <MCU_SoC_DRIPS_Handler+0x1d6>)
30011154:	6018      	str	r0, [r3, #0]
30011156:	4b3b      	ldr	r3, [pc, #236]	; (30011244 <MCU_SoC_DRIPS_Handler+0x1da>)
30011158:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
3001115a:	4b3b      	ldr	r3, [pc, #236]	; (30011248 <MCU_SoC_DRIPS_Handler+0x1de>)
3001115c:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) & ~(1 << CRMU_CLOCK_GATE_CONTROL__CRMU_BSPI_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
3001115e:	0052      	lsls	r2, r2, #1
30011160:	0852      	lsrs	r2, r2, #1
	*(volatile u32_t *)addr = data;
30011162:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30011164:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) & ~(1 << CRMU_CLOCK_GATE_CONTROL__CRMU_UART_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
30011166:	4c39      	ldr	r4, [pc, #228]	; (3001124c <MCU_SoC_DRIPS_Handler+0x1e2>)
30011168:	4022      	ands	r2, r4
	*(volatile u32_t *)addr = data;
3001116a:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
3001116c:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) & ~(1 << CRMU_CLOCK_GATE_CONTROL__CRMU_SOTP_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
3001116e:	4011      	ands	r1, r2
	*(volatile u32_t *)addr = data;
30011170:	6019      	str	r1, [r3, #0]
	return *(volatile u32_t *)addr;
30011172:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) & ~(1 << CRMU_CLOCK_GATE_CONTROL__CRMU_SMBUS_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
30011174:	4936      	ldr	r1, [pc, #216]	; (30011250 <MCU_SoC_DRIPS_Handler+0x1e6>)
30011176:	400a      	ands	r2, r1
	*(volatile u32_t *)addr = data;
30011178:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
3001117a:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) & ~(1 << CRMU_CLOCK_GATE_CONTROL__CRMU_OTPC_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
3001117c:	4935      	ldr	r1, [pc, #212]	; (30011254 <MCU_SoC_DRIPS_Handler+0x1ea>)
3001117e:	400a      	ands	r2, r1
	*(volatile u32_t *)addr = data;
30011180:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30011182:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) & ~(1 << CRMU_CLOCK_GATE_CONTROL__CRMU_SPRU_CRMU_REF_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
30011184:	3122      	adds	r1, #34	; 0x22
30011186:	31ff      	adds	r1, #255	; 0xff
30011188:	438a      	bics	r2, r1
	*(volatile u32_t *)addr = data;
3001118a:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
3001118c:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) & ~(1 << CRMU_CLOCK_GATE_CONTROL__CRMU_CDRU_CLK_25_ENABLE), CRMU_CLOCK_GATE_CONTROL);
3001118e:	3910      	subs	r1, #16
30011190:	438a      	bics	r2, r1
	*(volatile u32_t *)addr = data;
30011192:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30011194:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) & ~(1 << CRMU_CLOCK_GATE_CONTROL__CRMU_TIM_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
30011196:	3908      	subs	r1, #8
30011198:	438a      	bics	r2, r1
	*(volatile u32_t *)addr = data;
3001119a:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
3001119c:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) & ~(1 << CRMU_CLOCK_GATE_CONTROL__CRMU_WDT_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
3001119e:	3904      	subs	r1, #4
300111a0:	438a      	bics	r2, r1
	*(volatile u32_t *)addr = data;
300111a2:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300111a4:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CRMU_CLOCK_GATE_CONTROL) & ~(1 << CRMU_CLOCK_GATE_CONTROL__CRMU_MCU_CLK_ENABLE), CRMU_CLOCK_GATE_CONTROL);
300111a6:	4382      	bics	r2, r0
	*(volatile u32_t *)addr = data;
300111a8:	601a      	str	r2, [r3, #0]
300111aa:	2249      	movs	r2, #73	; 0x49
300111ac:	4b2a      	ldr	r3, [pc, #168]	; (30011258 <MCU_SoC_DRIPS_Handler+0x1ee>)
300111ae:	601a      	str	r2, [r3, #0]
300111b0:	3a4a      	subs	r2, #74	; 0x4a
300111b2:	4b2a      	ldr	r3, [pc, #168]	; (3001125c <MCU_SoC_DRIPS_Handler+0x1f2>)
300111b4:	601a      	str	r2, [r3, #0]
300111b6:	3203      	adds	r2, #3
300111b8:	4b29      	ldr	r3, [pc, #164]	; (30011260 <MCU_SoC_DRIPS_Handler+0x1f6>)
300111ba:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300111bc:	4a29      	ldr	r2, [pc, #164]	; (30011264 <MCU_SoC_DRIPS_Handler+0x1fa>)
300111be:	6813      	ldr	r3, [r2, #0]
	while (sys_read32(CRMU_CLOCK_SWITCH_STATUS) != 0x4)
300111c0:	2b04      	cmp	r3, #4
300111c2:	d1fc      	bne.n	300111be <MCU_SoC_DRIPS_Handler+0x154>
	crmu_cfg_xtal_pwr_off();
300111c4:	f7ff ff0e 	bl	30010fe4 <crmu_cfg_xtal_pwr_off>
300111c8:	4b27      	ldr	r3, [pc, #156]	; (30011268 <MCU_SoC_DRIPS_Handler+0x1fe>)
300111ca:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CDRU_USBPHY_D_CTRL1) & (~(1 << 27)), CDRU_USBPHY_D_CTRL1); /* bit27 = 0; */
300111cc:	4927      	ldr	r1, [pc, #156]	; (3001126c <MCU_SoC_DRIPS_Handler+0x202>)
300111ce:	400a      	ands	r2, r1
	*(volatile u32_t *)addr = data;
300111d0:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300111d2:	681a      	ldr	r2, [r3, #0]
	sys_write32(sys_read32(CDRU_USBPHY_D_CTRL1) & ~(0x3), CDRU_USBPHY_D_CTRL1); /* bits[1:0] = 0x0; */
300111d4:	2103      	movs	r1, #3
300111d6:	438a      	bics	r2, r1
	*(volatile u32_t *)addr = data;
300111d8:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300111da:	4a25      	ldr	r2, [pc, #148]	; (30011270 <MCU_SoC_DRIPS_Handler+0x206>)
300111dc:	6811      	ldr	r1, [r2, #0]
	sys_write32(sys_read32(CRMU_USBPHY_D_CTRL) | 0x100000, CRMU_USBPHY_D_CTRL); /* phy_iso = 1 */
300111de:	2380      	movs	r3, #128	; 0x80
300111e0:	035b      	lsls	r3, r3, #13
300111e2:	430b      	orrs	r3, r1
	*(volatile u32_t *)addr = data;
300111e4:	6013      	str	r3, [r2, #0]
	return *(volatile u32_t *)addr;
300111e6:	4a23      	ldr	r2, [pc, #140]	; (30011274 <MCU_SoC_DRIPS_Handler+0x20a>)
300111e8:	6813      	ldr	r3, [r2, #0]
	sys_write32(sys_read32(CDRU_USBD_MISC) | 0xF, CDRU_USBD_MISC);
300111ea:	210f      	movs	r1, #15
300111ec:	430b      	orrs	r3, r1
	*(volatile u32_t *)addr = data;
300111ee:	6013      	str	r3, [r2, #0]
	citadel_power_off_IO_ring();
300111f0:	f7ff ff0c 	bl	3001100c <citadel_power_off_IO_ring>
#else
	MCU_set_pdsys_master_clock_gating(1); /* simple sleep */
#endif

	return res;
}
300111f4:	2000      	movs	r0, #0
300111f6:	b002      	add	sp, #8
300111f8:	bd10      	pop	{r4, pc}
300111fa:	46c0      	nop			; (mov r8, r8)
300111fc:	56010810 	.word	0x56010810
30011200:	560100ac 	.word	0x560100ac
30011204:	56010480 	.word	0x56010480
30011208:	56010484 	.word	0x56010484
3001120c:	56010070 	.word	0x56010070
30011210:	560108d0 	.word	0x560108d0
30011214:	560108f0 	.word	0x560108f0
30011218:	56010890 	.word	0x56010890
3001121c:	560108b0 	.word	0x560108b0
30011220:	440c0040 	.word	0x440c0040
30011224:	fffffbff 	.word	0xfffffbff
30011228:	440c00c0 	.word	0x440c00c0
3001122c:	440c0140 	.word	0x440c0140
30011230:	3001c038 	.word	0x3001c038
30011234:	3001c010 	.word	0x3001c010
30011238:	3001d004 	.word	0x3001d004
3001123c:	3001c044 	.word	0x3001c044
30011240:	3001d028 	.word	0x3001d028
30011244:	3001c020 	.word	0x3001c020
30011248:	3001c050 	.word	0x3001c050
3001124c:	bfffffff 	.word	0xbfffffff
30011250:	fffffdff 	.word	0xfffffdff
30011254:	fffffeff 	.word	0xfffffeff
30011258:	3001d038 	.word	0x3001d038
3001125c:	3001d08c 	.word	0x3001d08c
30011260:	3001c058 	.word	0x3001c058
30011264:	3001c05c 	.word	0x3001c05c
30011268:	3001d0c4 	.word	0x3001d0c4
3001126c:	f7ffffff 	.word	0xf7ffffff
30011270:	3001c024 	.word	0x3001c024
30011274:	3001d0a0 	.word	0x3001d0a0

30011278 <MCU_SoC_DeepSleep_Handler>:
 * @param None
 *
 * @return result
 */
s32_t MCU_SoC_DeepSleep_Handler(void)
{
30011278:	b510      	push	{r4, lr}
3001127a:	2101      	movs	r1, #1
3001127c:	4b2c      	ldr	r3, [pc, #176]	; (30011330 <MCU_SoC_DeepSleep_Handler+0xb8>)
3001127e:	6019      	str	r1, [r3, #0]
30011280:	2201      	movs	r2, #1
30011282:	4252      	negs	r2, r2
30011284:	4b2b      	ldr	r3, [pc, #172]	; (30011334 <MCU_SoC_DeepSleep_Handler+0xbc>)
30011286:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30011288:	4a2b      	ldr	r2, [pc, #172]	; (30011338 <MCU_SoC_DeepSleep_Handler+0xc0>)
3001128a:	6813      	ldr	r3, [r2, #0]
	rd_data = rd_data & (~(0xC000071D));
3001128c:	482b      	ldr	r0, [pc, #172]	; (3001133c <MCU_SoC_DeepSleep_Handler+0xc4>)
3001128e:	4003      	ands	r3, r0
	*(volatile u32_t *)addr = data;
30011290:	6013      	str	r3, [r2, #0]
	u32_t temp = *(volatile u32_t *)addr;
30011292:	4a2b      	ldr	r2, [pc, #172]	; (30011340 <MCU_SoC_DeepSleep_Handler+0xc8>)
30011294:	6813      	ldr	r3, [r2, #0]
	*(volatile u32_t *)addr = temp & ~(1 << bit);
30011296:	2040      	movs	r0, #64	; 0x40
30011298:	4383      	bics	r3, r0
3001129a:	6013      	str	r3, [r2, #0]
	*(volatile u32_t *)addr = data;
3001129c:	4a29      	ldr	r2, [pc, #164]	; (30011344 <MCU_SoC_DeepSleep_Handler+0xcc>)
3001129e:	4b2a      	ldr	r3, [pc, #168]	; (30011348 <MCU_SoC_DeepSleep_Handler+0xd0>)
300112a0:	601a      	str	r2, [r3, #0]
300112a2:	2280      	movs	r2, #128	; 0x80
300112a4:	4b29      	ldr	r3, [pc, #164]	; (3001134c <MCU_SoC_DeepSleep_Handler+0xd4>)
300112a6:	601a      	str	r2, [r3, #0]
300112a8:	3a74      	subs	r2, #116	; 0x74
300112aa:	4b29      	ldr	r3, [pc, #164]	; (30011350 <MCU_SoC_DeepSleep_Handler+0xd8>)
300112ac:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300112ae:	4829      	ldr	r0, [pc, #164]	; (30011354 <MCU_SoC_DeepSleep_Handler+0xdc>)
300112b0:	6803      	ldr	r3, [r0, #0]
	rd_data = rd_data & (~(1 << 10));
300112b2:	4a29      	ldr	r2, [pc, #164]	; (30011358 <MCU_SoC_DeepSleep_Handler+0xe0>)
300112b4:	4013      	ands	r3, r2
	*(volatile u32_t *)addr = data;
300112b6:	6003      	str	r3, [r0, #0]
	return *(volatile u32_t *)addr;
300112b8:	4828      	ldr	r0, [pc, #160]	; (3001135c <MCU_SoC_DeepSleep_Handler+0xe4>)
300112ba:	6803      	ldr	r3, [r0, #0]
	rd_data = rd_data & (~(1 << 10));
300112bc:	4013      	ands	r3, r2
	*(volatile u32_t *)addr = data;
300112be:	6003      	str	r3, [r0, #0]
	return *(volatile u32_t *)addr;
300112c0:	4827      	ldr	r0, [pc, #156]	; (30011360 <MCU_SoC_DeepSleep_Handler+0xe8>)
300112c2:	6803      	ldr	r3, [r0, #0]
	rd_data = rd_data & (~(1 << 10));
300112c4:	4013      	ands	r3, r2
	*(volatile u32_t *)addr = data;
300112c6:	6003      	str	r3, [r0, #0]
300112c8:	2007      	movs	r0, #7
300112ca:	4b26      	ldr	r3, [pc, #152]	; (30011364 <MCU_SoC_DeepSleep_Handler+0xec>)
300112cc:	6018      	str	r0, [r3, #0]
300112ce:	2300      	movs	r3, #0
300112d0:	4a25      	ldr	r2, [pc, #148]	; (30011368 <MCU_SoC_DeepSleep_Handler+0xf0>)
300112d2:	6013      	str	r3, [r2, #0]
300112d4:	4a25      	ldr	r2, [pc, #148]	; (3001136c <MCU_SoC_DeepSleep_Handler+0xf4>)
300112d6:	6013      	str	r3, [r2, #0]
300112d8:	4a25      	ldr	r2, [pc, #148]	; (30011370 <MCU_SoC_DeepSleep_Handler+0xf8>)
300112da:	6011      	str	r1, [r2, #0]
	return *(volatile u32_t *)addr;
300112dc:	4925      	ldr	r1, [pc, #148]	; (30011374 <MCU_SoC_DeepSleep_Handler+0xfc>)
300112de:	680a      	ldr	r2, [r1, #0]
	sys_write32(rd_data | 0x7, CRMU_PLL_AON_CTRL);
300112e0:	4302      	orrs	r2, r0
	*(volatile u32_t *)addr = data;
300112e2:	600a      	str	r2, [r1, #0]
	return *(volatile u32_t *)addr;
300112e4:	4924      	ldr	r1, [pc, #144]	; (30011378 <MCU_SoC_DeepSleep_Handler+0x100>)
300112e6:	6808      	ldr	r0, [r1, #0]
	sys_write32(rd_data | 0x1101, CRMU_ISO_CELL_CONTROL);
300112e8:	4a24      	ldr	r2, [pc, #144]	; (3001137c <MCU_SoC_DeepSleep_Handler+0x104>)
300112ea:	4302      	orrs	r2, r0
	*(volatile u32_t *)addr = data;
300112ec:	600a      	str	r2, [r1, #0]
300112ee:	4a24      	ldr	r2, [pc, #144]	; (30011380 <MCU_SoC_DeepSleep_Handler+0x108>)
300112f0:	6013      	str	r3, [r2, #0]
	return *(volatile u32_t *)addr;
300112f2:	4924      	ldr	r1, [pc, #144]	; (30011384 <MCU_SoC_DeepSleep_Handler+0x10c>)
300112f4:	680a      	ldr	r2, [r1, #0]
	sys_write32((sys_read32(GP_DATA_OUT)) & 0x7fd, GP_DATA_OUT);
300112f6:	4824      	ldr	r0, [pc, #144]	; (30011388 <MCU_SoC_DeepSleep_Handler+0x110>)
300112f8:	4002      	ands	r2, r0
	*(volatile u32_t *)addr = data;
300112fa:	600a      	str	r2, [r1, #0]
300112fc:	2120      	movs	r1, #32
300112fe:	4a23      	ldr	r2, [pc, #140]	; (3001138c <MCU_SoC_DeepSleep_Handler+0x114>)
30011300:	6011      	str	r1, [r2, #0]
30011302:	4a23      	ldr	r2, [pc, #140]	; (30011390 <MCU_SoC_DeepSleep_Handler+0x118>)
30011304:	6013      	str	r3, [r2, #0]
30011306:	2202      	movs	r2, #2
30011308:	4b22      	ldr	r3, [pc, #136]	; (30011394 <MCU_SoC_DeepSleep_Handler+0x11c>)
3001130a:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
3001130c:	4a22      	ldr	r2, [pc, #136]	; (30011398 <MCU_SoC_DeepSleep_Handler+0x120>)
3001130e:	6813      	ldr	r3, [r2, #0]
	while (sys_read32(CRMU_CLOCK_SWITCH_STATUS) != 0x4)
30011310:	2b04      	cmp	r3, #4
30011312:	d1fc      	bne.n	3001130e <MCU_SoC_DeepSleep_Handler+0x96>
	crmu_cfg_xtal_pwr_off();
30011314:	f7ff fe66 	bl	30010fe4 <crmu_cfg_xtal_pwr_off>
30011318:	4a20      	ldr	r2, [pc, #128]	; (3001139c <MCU_SoC_DeepSleep_Handler+0x124>)
3001131a:	6813      	ldr	r3, [r2, #0]
	sys_write32((sys_read32(CRMU_LDO_CTRL_REG_28_0) & 0XFFFFFFF0) | 0xB, CRMU_LDO_CTRL_REG_28_0);
3001131c:	210f      	movs	r1, #15
3001131e:	438b      	bics	r3, r1
30011320:	3904      	subs	r1, #4
30011322:	430b      	orrs	r3, r1
	*(volatile u32_t *)addr = data;
30011324:	6013      	str	r3, [r2, #0]
	citadel_power_off_IO_ring();
30011326:	f7ff fe71 	bl	3001100c <citadel_power_off_IO_ring>
	s32_t res = 0;

	res = citadel_deep_sleep_enter();

	return res;
}
3001132a:	2000      	movs	r0, #0
3001132c:	bd10      	pop	{r4, pc}
3001132e:	46c0      	nop			; (mov r8, r8)
30011330:	3001c008 	.word	0x3001c008
30011334:	3001d08c 	.word	0x3001d08c
30011338:	3001c050 	.word	0x3001c050
3001133c:	3ffff8e2 	.word	0x3ffff8e2
30011340:	44098004 	.word	0x44098004
30011344:	00166666 	.word	0x00166666
30011348:	3001c024 	.word	0x3001c024
3001134c:	3001d0d0 	.word	0x3001d0d0
30011350:	3001d0a0 	.word	0x3001d0a0
30011354:	440c0040 	.word	0x440c0040
30011358:	fffffbff 	.word	0xfffffbff
3001135c:	440c00c0 	.word	0x440c00c0
30011360:	440c0140 	.word	0x440c0140
30011364:	3001c038 	.word	0x3001c038
30011368:	3001c010 	.word	0x3001c010
3001136c:	3001c048 	.word	0x3001c048
30011370:	3001d028 	.word	0x3001d028
30011374:	3001c020 	.word	0x3001c020
30011378:	3001c044 	.word	0x3001c044
3001137c:	00001101 	.word	0x00001101
30011380:	3001c00c 	.word	0x3001c00c
30011384:	30024804 	.word	0x30024804
30011388:	000007fd 	.word	0x000007fd
3001138c:	30024844 	.word	0x30024844
30011390:	3002483c 	.word	0x3002483c
30011394:	3001c058 	.word	0x3001c058
30011398:	3001c05c 	.word	0x3001c05c
3001139c:	3001c014 	.word	0x3001c014

300113a0 <m0_smb_slave_rx_fifo_read>:
// |Read Slave Rx Fifo|
// +------------------+
// This task reads the Slave Rx Fifo and returns the data.  Only one frame is
// read at a time
void m0_smb_slave_rx_fifo_read(uint32_t *data)
{
300113a0:	b570      	push	{r4, r5, r6, lr}
    uint32_t smb_data32;
    uint32_t smb_config_reg;
    uint32_t smb_disable = 0;

    smb_data_size = 0;
300113a2:	2200      	movs	r2, #0
300113a4:	4b12      	ldr	r3, [pc, #72]	; (300113f0 <m0_smb_slave_rx_fifo_read+0x50>)
300113a6:	701a      	strb	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300113a8:	4b12      	ldr	r3, [pc, #72]	; (300113f4 <m0_smb_slave_rx_fifo_read+0x54>)
300113aa:	681d      	ldr	r5, [r3, #0]
    smb_disable   = 0;    
300113ac:	2600      	movs	r6, #0

    // Slave Rx Fifo Read cannot go through if SMBus is disabled.  Hence, if
    // SMbus is disabled, it is temporarily enabled to obtain the data
    smb_config_reg = sys_read32( CRMU_SMBUS0_SMBus_Config);

    if (!(smb_config_reg & (1U << CRMU_SMBUS0_SMBus_Config__SMB_EN)))
300113ae:	006b      	lsls	r3, r5, #1
300113b0:	d405      	bmi.n	300113be <m0_smb_slave_rx_fifo_read+0x1e>
    {
        smb_config_reg |= (1U << CRMU_SMBUS0_SMBus_Config__SMB_EN);
300113b2:	2380      	movs	r3, #128	; 0x80
300113b4:	05db      	lsls	r3, r3, #23
300113b6:	431d      	orrs	r5, r3
	*(volatile u32_t *)addr = data;
300113b8:	4b0e      	ldr	r3, [pc, #56]	; (300113f4 <m0_smb_slave_rx_fifo_read+0x54>)
300113ba:	601d      	str	r5, [r3, #0]
        sys_write32(smb_config_reg,  CRMU_SMBUS0_SMBus_Config);
        smb_disable = 1;
300113bc:	2601      	movs	r6, #1
	return *(volatile u32_t *)addr;
300113be:	4c0e      	ldr	r4, [pc, #56]	; (300113f8 <m0_smb_slave_rx_fifo_read+0x58>)
    // Read Until END-OF-FRAME is indicated
    do
    {
        // Read Slave Rx Fifo Until a complete Frame is obtained
        smb_data32 = sys_read32(CRMU_SMBUS0_SMBus_Slave_Data_Read);
        data[smb_data_size] = smb_data32;
300113c0:	490b      	ldr	r1, [pc, #44]	; (300113f0 <m0_smb_slave_rx_fifo_read+0x50>)
300113c2:	6822      	ldr	r2, [r4, #0]
300113c4:	780b      	ldrb	r3, [r1, #0]
300113c6:	009b      	lsls	r3, r3, #2
300113c8:	501a      	str	r2, [r3, r0]
        smb_data_size += 1;
300113ca:	780b      	ldrb	r3, [r1, #0]
300113cc:	3301      	adds	r3, #1
300113ce:	b2db      	uxtb	r3, r3
300113d0:	700b      	strb	r3, [r1, #0]

        if (smb_data_size > smb_buf_size)
300113d2:	780b      	ldrb	r3, [r1, #0]
300113d4:	b2db      	uxtb	r3, r3
300113d6:	2b80      	cmp	r3, #128	; 0x80
300113d8:	d802      	bhi.n	300113e0 <m0_smb_slave_rx_fifo_read+0x40>
        {
         //   printf("ISR ERROR: Slave Rx Fifo Read Size(%0d) Too high!\n",i); 
            break;
        }
    } while ( (smb_data32>>CRMU_SMBUS0_SMBus_Slave_Data_Read__SLAVE_RD_STATUS_R) != 3 );
300113da:	0f92      	lsrs	r2, r2, #30
300113dc:	2a03      	cmp	r2, #3
300113de:	d1f0      	bne.n	300113c2 <m0_smb_slave_rx_fifo_read+0x22>

    if (smb_disable)
300113e0:	2e00      	cmp	r6, #0
300113e2:	d003      	beq.n	300113ec <m0_smb_slave_rx_fifo_read+0x4c>
    {
        smb_config_reg &= ~(1U << CRMU_SMBUS0_SMBus_Config__SMB_EN);
300113e4:	4b05      	ldr	r3, [pc, #20]	; (300113fc <m0_smb_slave_rx_fifo_read+0x5c>)
300113e6:	401d      	ands	r5, r3
	*(volatile u32_t *)addr = data;
300113e8:	4b02      	ldr	r3, [pc, #8]	; (300113f4 <m0_smb_slave_rx_fifo_read+0x54>)
300113ea:	601d      	str	r5, [r3, #0]
        sys_write32(smb_config_reg,  CRMU_SMBUS0_SMBus_Config);
    }

    return;
}
300113ec:	bd70      	pop	{r4, r5, r6, pc}
300113ee:	46c0      	nop			; (mov r8, r8)
300113f0:	30018f50 	.word	0x30018f50
300113f4:	30020000 	.word	0x30020000
300113f8:	3002004c 	.word	0x3002004c
300113fc:	bfffffff 	.word	0xbfffffff

30011400 <m0_issue_ds_cmd>:

// +--------------------------+
// | Send deepsleep CMD to A7 |
// +--------------------------+
void m0_issue_ds_cmd(void)
{
30011400:	b510      	push	{r4, lr}
	return *(volatile u32_t *)addr;
30011402:	4a12      	ldr	r2, [pc, #72]	; (3001144c <m0_issue_ds_cmd+0x4c>)
30011404:	6811      	ldr	r1, [r2, #0]
    uint32_t rd_data;

   // Citadel will enter deepsleep mode, disable wakeup source for suspended sleep mode.
    rd_data  = sys_read32(CRMU_MCU_EVENT_MASK);
    rd_data |= (0x1<<(CRMU_MCU_EVENT_MASK__MCU_USBPHY0_WAKE_EVENT_MASK)) | (0x1<<(CRMU_MCU_EVENT_MASK__MCU_USBPHY0_FILTER_EVENT_MASK)) |  //USB
30011406:	2398      	movs	r3, #152	; 0x98
30011408:	025b      	lsls	r3, r3, #9
3001140a:	430b      	orrs	r3, r1
	*(volatile u32_t *)addr = data;
3001140c:	6013      	str	r3, [r2, #0]
	return *(volatile u32_t *)addr;
3001140e:	4a10      	ldr	r2, [pc, #64]	; (30011450 <m0_issue_ds_cmd+0x50>)
30011410:	6813      	ldr	r3, [r2, #0]
               (0x1<<CRMU_MCU_EVENT_MASK__MCU_MPROC_CRMU_EVENT0_MASK);  //NFC
    sys_write32(rd_data, CRMU_MCU_EVENT_MASK);
   
    rd_data = sys_read32(CRMU_MCU_INTR_MASK);
    rd_data |=  (0x1<<(CRMU_MCU_INTR_MASK__MCU_AON_GPIO_INTR_MASK));    // SC_DET
30011412:	2104      	movs	r1, #4
30011414:	430b      	orrs	r3, r1
	*(volatile u32_t *)addr = data;
30011416:	6013      	str	r3, [r2, #0]
	return *(volatile u32_t *)addr;
30011418:	4b0e      	ldr	r3, [pc, #56]	; (30011454 <m0_issue_ds_cmd+0x54>)
3001141a:	681b      	ldr	r3, [r3, #0]
    sys_write32(rd_data, CRMU_MCU_INTR_MASK);

    if ( sys_read32(CRMU_IHOST_POWER_CONFIG) == CPU_PW_STAT_SLEEP )
3001141c:	2b01      	cmp	r3, #1
3001141e:	d00c      	beq.n	3001143a <m0_issue_ds_cmd+0x3a>
30011420:	490d      	ldr	r1, [pc, #52]	; (30011458 <m0_issue_ds_cmd+0x58>)
30011422:	680b      	ldr	r3, [r1, #0]
        sys_write32(CPU_PW_STAT_DEEPSLEEP,  CRMU_IHOST_POWER_CONFIG);
        // will wake up from sleep, then A7 put itself into the deepsleep mode
        citadel_sleep_exit( 0, MPROC_DEFAULT_PM_MODE);
    } else
    {
        sys_write32((sys_read32(CRMU_IPROC_MAIL_BOX0) & MAILBOX_CODE0_mProcPowerCMDMask) | MAILBOX_CODE0_mProcDeepSleep, CRMU_IPROC_MAIL_BOX0);
30011424:	4a0d      	ldr	r2, [pc, #52]	; (3001145c <m0_issue_ds_cmd+0x5c>)
30011426:	401a      	ands	r2, r3
30011428:	2380      	movs	r3, #128	; 0x80
3001142a:	051b      	lsls	r3, r3, #20
3001142c:	4313      	orrs	r3, r2
	*(volatile u32_t *)addr = data;
3001142e:	600b      	str	r3, [r1, #0]
30011430:	2280      	movs	r2, #128	; 0x80
30011432:	0552      	lsls	r2, r2, #21
30011434:	4b0a      	ldr	r3, [pc, #40]	; (30011460 <m0_issue_ds_cmd+0x60>)
30011436:	601a      	str	r2, [r3, #0]
        sys_write32(MAILBOX_CODE1__PM, CRMU_IPROC_MAIL_BOX1);
    }
}
30011438:	bd10      	pop	{r4, pc}
3001143a:	2203      	movs	r2, #3
3001143c:	4b05      	ldr	r3, [pc, #20]	; (30011454 <m0_issue_ds_cmd+0x54>)
3001143e:	601a      	str	r2, [r3, #0]
        citadel_sleep_exit( 0, MPROC_DEFAULT_PM_MODE);
30011440:	3902      	subs	r1, #2
30011442:	2000      	movs	r0, #0
30011444:	f7ff f92c 	bl	300106a0 <citadel_sleep_exit>
30011448:	e7f6      	b.n	30011438 <m0_issue_ds_cmd+0x38>
3001144a:	46c0      	nop			; (mov r8, r8)
3001144c:	30024064 	.word	0x30024064
30011450:	30024054 	.word	0x30024054
30011454:	30024044 	.word	0x30024044
30011458:	30024030 	.word	0x30024030
3001145c:	c7ffffff 	.word	0xc7ffffff
30011460:	30024034 	.word	0x30024034

30011464 <m0_smbus_handler>:
{
30011464:	b510      	push	{r4, lr}
	return *(volatile u32_t *)addr;
30011466:	4b4e      	ldr	r3, [pc, #312]	; (300115a0 <m0_smbus_handler+0x13c>)
30011468:	681c      	ldr	r4, [r3, #0]
    if( smb_int_status & (SLAVE_RD_EVENT_INT | SLAVE_RX_EVENT_INT))
3001146a:	2390      	movs	r3, #144	; 0x90
3001146c:	045b      	lsls	r3, r3, #17
3001146e:	421c      	tst	r4, r3
30011470:	d106      	bne.n	30011480 <m0_smbus_handler+0x1c>
	*(volatile u32_t *)addr = data;
30011472:	4b4b      	ldr	r3, [pc, #300]	; (300115a0 <m0_smbus_handler+0x13c>)
30011474:	601c      	str	r4, [r3, #0]
30011476:	2240      	movs	r2, #64	; 0x40
30011478:	4b4a      	ldr	r3, [pc, #296]	; (300115a4 <m0_smbus_handler+0x140>)
3001147a:	601a      	str	r2, [r3, #0]
        return 1;
3001147c:	2001      	movs	r0, #1
}
3001147e:	bd10      	pop	{r4, pc}
        m0_smb_slave_rx_fifo_read((uint32_t*)smb_buf);
30011480:	4849      	ldr	r0, [pc, #292]	; (300115a8 <m0_smbus_handler+0x144>)
30011482:	f7ff ff8d 	bl	300113a0 <m0_smb_slave_rx_fifo_read>
        (*(volatile uint32_t*)GP_DATA_OUT) |= (1<<4); // USH_SMB_ALERT_N = 4
30011486:	4a49      	ldr	r2, [pc, #292]	; (300115ac <m0_smbus_handler+0x148>)
30011488:	6813      	ldr	r3, [r2, #0]
3001148a:	2110      	movs	r1, #16
3001148c:	430b      	orrs	r3, r1
3001148e:	6013      	str	r3, [r2, #0]
        if( smb_data_size == 1 )
30011490:	4b47      	ldr	r3, [pc, #284]	; (300115b0 <m0_smbus_handler+0x14c>)
30011492:	781b      	ldrb	r3, [r3, #0]
30011494:	2b01      	cmp	r3, #1
30011496:	d02b      	beq.n	300114f0 <m0_smbus_handler+0x8c>
        else  if ( smb_data_size >= 2 ) 
30011498:	4b45      	ldr	r3, [pc, #276]	; (300115b0 <m0_smbus_handler+0x14c>)
3001149a:	781b      	ldrb	r3, [r3, #0]
3001149c:	b2db      	uxtb	r3, r3
3001149e:	2b01      	cmp	r3, #1
300114a0:	d96c      	bls.n	3001157c <m0_smbus_handler+0x118>
	return *(volatile u32_t *)addr;
300114a2:	4b44      	ldr	r3, [pc, #272]	; (300115b4 <m0_smbus_handler+0x150>)
300114a4:	681a      	ldr	r2, [r3, #0]
            cmd = sys_read32(smb_buf + 4) & 0xff;
300114a6:	23ff      	movs	r3, #255	; 0xff
300114a8:	4013      	ands	r3, r2
            if( cmd == USH_POA_GET_CMD_STS ) goto ClearInterrupt;
300114aa:	2b09      	cmp	r3, #9
300114ac:	d070      	beq.n	30011590 <m0_smbus_handler+0x12c>
            poa_latest_cmd = (uint8_t)cmd;
300114ae:	b2d2      	uxtb	r2, r2
300114b0:	4941      	ldr	r1, [pc, #260]	; (300115b8 <m0_smbus_handler+0x154>)
300114b2:	700a      	strb	r2, [r1, #0]
            poa_ec_counter++;
300114b4:	4941      	ldr	r1, [pc, #260]	; (300115bc <m0_smbus_handler+0x158>)
300114b6:	880a      	ldrh	r2, [r1, #0]
300114b8:	3201      	adds	r2, #1
300114ba:	b292      	uxth	r2, r2
300114bc:	800a      	strh	r2, [r1, #0]
			if (cmd == USH_TURN_DEVICE_OFF) 	/* deep sleep mode */
300114be:	2b00      	cmp	r3, #0
300114c0:	d037      	beq.n	30011532 <m0_smbus_handler+0xce>
			if (cmd == USH_DISABLE_DEVICES) /* connected standby */
300114c2:	2b03      	cmp	r3, #3
300114c4:	d03b      	beq.n	3001153e <m0_smbus_handler+0xda>
			if (cmd == USH_TURN_DEVICE_ON)  /* wake up Citadel fron DS or CS mode */
300114c6:	2b01      	cmp	r3, #1
300114c8:	d03d      	beq.n	30011546 <m0_smbus_handler+0xe2>
			if (cmd == USH_SOFT_RESET_DEVICE)
300114ca:	2b04      	cmp	r3, #4
300114cc:	d04c      	beq.n	30011568 <m0_smbus_handler+0x104>
            if( cmd == USH_POA_STARTUP_FP )
300114ce:	2b02      	cmp	r3, #2
300114d0:	d155      	bne.n	3001157e <m0_smbus_handler+0x11a>
                    smb_poa_wakeup = 1;
300114d2:	2101      	movs	r1, #1
300114d4:	4a3a      	ldr	r2, [pc, #232]	; (300115c0 <m0_smbus_handler+0x15c>)
300114d6:	6011      	str	r1, [r2, #0]
                    host_cs_state = 0;
300114d8:	2100      	movs	r1, #0
300114da:	4a3a      	ldr	r2, [pc, #232]	; (300115c4 <m0_smbus_handler+0x160>)
300114dc:	6011      	str	r1, [r2, #0]
300114de:	4a3a      	ldr	r2, [pc, #232]	; (300115c8 <m0_smbus_handler+0x164>)
300114e0:	6812      	ldr	r2, [r2, #0]
                    if ( sys_read32(CRMU_IHOST_POWER_CONFIG) == CPU_PW_STAT_DEEPSLEEP )
300114e2:	2a03      	cmp	r2, #3
300114e4:	d047      	beq.n	30011576 <m0_smbus_handler+0x112>
300114e6:	4a38      	ldr	r2, [pc, #224]	; (300115c8 <m0_smbus_handler+0x164>)
300114e8:	6812      	ldr	r2, [r2, #0]
                    } else if ( sys_read32(CRMU_IHOST_POWER_CONFIG) == CPU_PW_STAT_SLEEP )
300114ea:	2a01      	cmp	r2, #1
300114ec:	d147      	bne.n	3001157e <m0_smbus_handler+0x11a>
300114ee:	e04f      	b.n	30011590 <m0_smbus_handler+0x12c>
            if ( (*(volatile uint32_t *)smb_buf) == SMB_QUICK_COMMAND_ON)
300114f0:	4b2d      	ldr	r3, [pc, #180]	; (300115a8 <m0_smbus_handler+0x144>)
300114f2:	681a      	ldr	r2, [r3, #0]
300114f4:	4b35      	ldr	r3, [pc, #212]	; (300115cc <m0_smbus_handler+0x168>)
300114f6:	429a      	cmp	r2, r3
300114f8:	d008      	beq.n	3001150c <m0_smbus_handler+0xa8>
            else if ( (*(volatile uint32_t *)smb_buf) == SMB_QUICK_COMMAND_OFF)
300114fa:	4b2b      	ldr	r3, [pc, #172]	; (300115a8 <m0_smbus_handler+0x144>)
300114fc:	6819      	ldr	r1, [r3, #0]
300114fe:	4a34      	ldr	r2, [pc, #208]	; (300115d0 <m0_smbus_handler+0x16c>)
    uint32_t cmd = 0;
30011500:	2300      	movs	r3, #0
            else if ( (*(volatile uint32_t *)smb_buf) == SMB_QUICK_COMMAND_OFF)
30011502:	4291      	cmp	r1, r2
30011504:	d13b      	bne.n	3001157e <m0_smbus_handler+0x11a>
                m0_issue_ds_cmd();
30011506:	f7ff ff7b 	bl	30011400 <m0_issue_ds_cmd>
                goto ClearInterrupt;
3001150a:	e041      	b.n	30011590 <m0_smbus_handler+0x12c>
3001150c:	4b2e      	ldr	r3, [pc, #184]	; (300115c8 <m0_smbus_handler+0x164>)
3001150e:	681b      	ldr	r3, [r3, #0]
                if ( sys_read32(CRMU_IHOST_POWER_CONFIG) == CPU_PW_STAT_DEEPSLEEP )
30011510:	2b03      	cmp	r3, #3
30011512:	d00a      	beq.n	3001152a <m0_smbus_handler+0xc6>
30011514:	4b2c      	ldr	r3, [pc, #176]	; (300115c8 <m0_smbus_handler+0x164>)
30011516:	681a      	ldr	r2, [r3, #0]
    uint32_t cmd = 0;
30011518:	2300      	movs	r3, #0
                } else if ( sys_read32(CRMU_IHOST_POWER_CONFIG) == CPU_PW_STAT_SLEEP )
3001151a:	2a01      	cmp	r2, #1
3001151c:	d12f      	bne.n	3001157e <m0_smbus_handler+0x11a>
                    citadel_sleep_exit( 0, MPROC_DEFAULT_PM_MODE );
3001151e:	2102      	movs	r1, #2
30011520:	2000      	movs	r0, #0
30011522:	f7ff f8bd 	bl	300106a0 <citadel_sleep_exit>
    uint32_t cmd = 0;
30011526:	2300      	movs	r3, #0
30011528:	e029      	b.n	3001157e <m0_smbus_handler+0x11a>
                    citadel_deep_sleep_exit();
3001152a:	f7ff f96b 	bl	30010804 <citadel_deep_sleep_exit>
    uint32_t cmd = 0;
3001152e:	2300      	movs	r3, #0
30011530:	e025      	b.n	3001157e <m0_smbus_handler+0x11a>
				smb_poa_wakeup = 0;
30011532:	2200      	movs	r2, #0
30011534:	4b22      	ldr	r3, [pc, #136]	; (300115c0 <m0_smbus_handler+0x15c>)
30011536:	601a      	str	r2, [r3, #0]
				m0_issue_ds_cmd();
30011538:	f7ff ff62 	bl	30011400 <m0_issue_ds_cmd>
				goto ClearInterrupt; //return;
3001153c:	e028      	b.n	30011590 <m0_smbus_handler+0x12c>
				host_cs_state = 1;
3001153e:	2201      	movs	r2, #1
30011540:	4b20      	ldr	r3, [pc, #128]	; (300115c4 <m0_smbus_handler+0x160>)
30011542:	601a      	str	r2, [r3, #0]
				goto ClearInterrupt; //return;
30011544:	e024      	b.n	30011590 <m0_smbus_handler+0x12c>
				smb_poa_wakeup = 0;
30011546:	2200      	movs	r2, #0
30011548:	491d      	ldr	r1, [pc, #116]	; (300115c0 <m0_smbus_handler+0x15c>)
3001154a:	600a      	str	r2, [r1, #0]
				host_cs_state = 0;
3001154c:	491d      	ldr	r1, [pc, #116]	; (300115c4 <m0_smbus_handler+0x160>)
3001154e:	600a      	str	r2, [r1, #0]
30011550:	4a1d      	ldr	r2, [pc, #116]	; (300115c8 <m0_smbus_handler+0x164>)
30011552:	6812      	ldr	r2, [r2, #0]
				if (sys_read32(CRMU_IHOST_POWER_CONFIG) == CPU_PW_STAT_DEEPSLEEP)
30011554:	2a03      	cmp	r2, #3
30011556:	d004      	beq.n	30011562 <m0_smbus_handler+0xfe>
30011558:	4a1b      	ldr	r2, [pc, #108]	; (300115c8 <m0_smbus_handler+0x164>)
3001155a:	6812      	ldr	r2, [r2, #0]
				else if (sys_read32(CRMU_IHOST_POWER_CONFIG) == CPU_PW_STAT_SLEEP)
3001155c:	2a01      	cmp	r2, #1
3001155e:	d10e      	bne.n	3001157e <m0_smbus_handler+0x11a>
30011560:	e016      	b.n	30011590 <m0_smbus_handler+0x12c>
					citadel_deep_sleep_exit();
30011562:	f7ff f94f 	bl	30010804 <citadel_deep_sleep_exit>
30011566:	e013      	b.n	30011590 <m0_smbus_handler+0x12c>
				smb_poa_wakeup = 0;
30011568:	2200      	movs	r2, #0
3001156a:	4b15      	ldr	r3, [pc, #84]	; (300115c0 <m0_smbus_handler+0x15c>)
3001156c:	601a      	str	r2, [r3, #0]
	*(volatile u32_t *)addr = data;
3001156e:	3202      	adds	r2, #2
30011570:	4b18      	ldr	r3, [pc, #96]	; (300115d4 <m0_smbus_handler+0x170>)
30011572:	601a      	str	r2, [r3, #0]
30011574:	e00c      	b.n	30011590 <m0_smbus_handler+0x12c>
                        citadel_deep_sleep_exit();
30011576:	f7ff f945 	bl	30010804 <citadel_deep_sleep_exit>
3001157a:	e009      	b.n	30011590 <m0_smbus_handler+0x12c>
    uint32_t cmd = 0;
3001157c:	2300      	movs	r3, #0
    MCU_send_msg_to_mproc(MAILBOX_CODE0__SMBUS_ISR, MAILBOX_CODE1__SMBUS_ISR | smb_data_size | cmd << 8);
3001157e:	4a0c      	ldr	r2, [pc, #48]	; (300115b0 <m0_smbus_handler+0x14c>)
30011580:	7811      	ldrb	r1, [r2, #0]
30011582:	2201      	movs	r2, #1
30011584:	4311      	orrs	r1, r2
30011586:	021b      	lsls	r3, r3, #8
30011588:	4319      	orrs	r1, r3
3001158a:	4813      	ldr	r0, [pc, #76]	; (300115d8 <m0_smbus_handler+0x174>)
3001158c:	f000 f938 	bl	30011800 <MCU_send_msg_to_mproc>
30011590:	4b03      	ldr	r3, [pc, #12]	; (300115a0 <m0_smbus_handler+0x13c>)
30011592:	601c      	str	r4, [r3, #0]
30011594:	2240      	movs	r2, #64	; 0x40
30011596:	4b03      	ldr	r3, [pc, #12]	; (300115a4 <m0_smbus_handler+0x140>)
30011598:	601a      	str	r2, [r3, #0]
   return 0;
3001159a:	2000      	movs	r0, #0
3001159c:	e76f      	b.n	3001147e <m0_smbus_handler+0x1a>
3001159e:	46c0      	nop			; (mov r8, r8)
300115a0:	3002003c 	.word	0x3002003c
300115a4:	30024058 	.word	0x30024058
300115a8:	30018ed0 	.word	0x30018ed0
300115ac:	30024804 	.word	0x30024804
300115b0:	30018f50 	.word	0x30018f50
300115b4:	30018ed4 	.word	0x30018ed4
300115b8:	30018f5a 	.word	0x30018f5a
300115bc:	30018f58 	.word	0x30018f58
300115c0:	30018f54 	.word	0x30018f54
300115c4:	300180c8 	.word	0x300180c8
300115c8:	30024044 	.word	0x30024044
300115cc:	c00000a5 	.word	0xc00000a5
300115d0:	c00000a4 	.word	0xc00000a4
300115d4:	300240a0 	.word	0x300240a0
300115d8:	aabbccdd 	.word	0xaabbccdd

300115dc <MCU_SYNC>:
	ISB
}
#else /* M0TOOL_GCC */
void MCU_SYNC(void)
{
	asm volatile("dsb");
300115dc:	f3bf 8f4f 	dsb	sy
	asm volatile("isb");
300115e0:	f3bf 8f6f 	isb	sy
}
300115e4:	4770      	bx	lr

300115e6 <mcu_getbit>:
 *
 * @return bit value
 */
u32_t mcu_getbit(u32_t data, u32_t bitno)
{
	return ((data >> bitno) & 0x1);
300115e6:	0003      	movs	r3, r0
300115e8:	40cb      	lsrs	r3, r1
300115ea:	2001      	movs	r0, #1
300115ec:	4018      	ands	r0, r3
}
300115ee:	4770      	bx	lr

300115f0 <mcu_setbit>:
 *
 * @return result
 */
u32_t mcu_setbit(u32_t data, u32_t bitno)
{
	return (data |= BIT(bitno));
300115f0:	2301      	movs	r3, #1
300115f2:	408b      	lsls	r3, r1
300115f4:	4318      	orrs	r0, r3
}
300115f6:	4770      	bx	lr

300115f8 <mcu_clrbit>:
 *
 * @return result
 */
u32_t mcu_clrbit(u32_t data, u32_t bitno)
{
	return (data &= (~BIT(bitno)));
300115f8:	2301      	movs	r3, #1
300115fa:	408b      	lsls	r3, r1
300115fc:	4398      	bics	r0, r3
}
300115fe:	4770      	bx	lr

30011600 <cpu_reg32_set_masked_bits>:
	return *(volatile u32_t *)addr;
30011600:	6803      	ldr	r3, [r0, #0]
 */
void cpu_reg32_set_masked_bits(u32_t addr, u32_t mask)
{
	u32_t regval = sys_read32(addr);

	regval |= mask;
30011602:	4319      	orrs	r1, r3
	*(volatile u32_t *)addr = data;
30011604:	6001      	str	r1, [r0, #0]

	sys_write32(regval, addr);
}
30011606:	4770      	bx	lr

30011608 <cpu_reg32_clr_masked_bits>:
	return *(volatile u32_t *)addr;
30011608:	6803      	ldr	r3, [r0, #0]
 */
void cpu_reg32_clr_masked_bits(u32_t addr, u32_t mask)
{
	u32_t regval = sys_read32(addr);

	regval &= ~mask;
3001160a:	438b      	bics	r3, r1
	*(volatile u32_t *)addr = data;
3001160c:	6003      	str	r3, [r0, #0]

	sys_write32(regval, addr);
}
3001160e:	4770      	bx	lr

30011610 <cpu_reg32_wr_masked_bits>:
	return *(volatile u32_t *)addr;
30011610:	6803      	ldr	r3, [r0, #0]
void cpu_reg32_wr_masked_bits(u32_t addr, u32_t mask, u32_t val)
{
	u32_t regval = sys_read32(addr);

	regval &= ~mask;
	regval |= (val & mask);
30011612:	405a      	eors	r2, r3
30011614:	4011      	ands	r1, r2
30011616:	4059      	eors	r1, r3
	*(volatile u32_t *)addr = data;
30011618:	6001      	str	r1, [r0, #0]

	sys_write32(regval, addr);
}
3001161a:	4770      	bx	lr

3001161c <cpu_reg32_wr_mask>:
 * @param value
 *
 * @return none
 */
void cpu_reg32_wr_mask(u32_t addr, u32_t rightbit, u32_t len, u32_t value)
{
3001161c:	b530      	push	{r4, r5, lr}
	u32_t mask       = BIT(len) - 1;
3001161e:	2401      	movs	r4, #1
30011620:	4094      	lsls	r4, r2
30011622:	0022      	movs	r2, r4
30011624:	3a01      	subs	r2, #1
	return *(volatile u32_t *)addr;
30011626:	6804      	ldr	r4, [r0, #0]
	u32_t mask_shift = mask << rightbit;
30011628:	0015      	movs	r5, r2
3001162a:	408d      	lsls	r5, r1
	u32_t curvalue = sys_read32(addr);
	u32_t tmpvalue = curvalue & (~mask_shift);
3001162c:	43ac      	bics	r4, r5
	u32_t newvalue = tmpvalue | ((value & mask) << rightbit);
3001162e:	401a      	ands	r2, r3
30011630:	408a      	lsls	r2, r1
30011632:	4322      	orrs	r2, r4
	*(volatile u32_t *)addr = data;
30011634:	6002      	str	r2, [r0, #0]

	sys_write32(newvalue, addr);
}
30011636:	bd30      	pop	{r4, r5, pc}

30011638 <MCU_memset>:
 */
void *MCU_memset(void *s, s32_t c, size_t count)
{
	char *xs = s;

	while (count--)
30011638:	2a00      	cmp	r2, #0
3001163a:	d005      	beq.n	30011648 <MCU_memset+0x10>
3001163c:	0003      	movs	r3, r0
3001163e:	1882      	adds	r2, r0, r2
		*xs++ = c;
30011640:	7019      	strb	r1, [r3, #0]
30011642:	3301      	adds	r3, #1
	while (count--)
30011644:	4293      	cmp	r3, r2
30011646:	d1fb      	bne.n	30011640 <MCU_memset+0x8>

	return s;
}
30011648:	4770      	bx	lr

3001164a <MCU_memcpy>:
 * @param count
 *
 * @return destination address
 */
void *MCU_memcpy(void *dest, const void *src, size_t count)
{
3001164a:	b510      	push	{r4, lr}
	char *tmp = dest;
	const char *s = src;

	while (count--)
3001164c:	2a00      	cmp	r2, #0
3001164e:	d005      	beq.n	3001165c <MCU_memcpy+0x12>
30011650:	2300      	movs	r3, #0
		*tmp++ = *s++;
30011652:	5ccc      	ldrb	r4, [r1, r3]
30011654:	54c4      	strb	r4, [r0, r3]
30011656:	3301      	adds	r3, #1
	while (count--)
30011658:	4293      	cmp	r3, r2
3001165a:	d1fa      	bne.n	30011652 <MCU_memcpy+0x8>

	return dest;
}
3001165c:	bd10      	pop	{r4, pc}

3001165e <MCU_delay>:
 * @param count
 *
 * @return none
 */
void MCU_delay(u32_t cnt)
{
3001165e:	b082      	sub	sp, #8
	volatile u32_t count = cnt ? cnt : 200000;
30011660:	2800      	cmp	r0, #0
30011662:	d100      	bne.n	30011666 <MCU_delay+0x8>
30011664:	4807      	ldr	r0, [pc, #28]	; (30011684 <MCU_delay+0x26>)
30011666:	9001      	str	r0, [sp, #4]
	return *(volatile u32_t *)addr;
30011668:	4b07      	ldr	r3, [pc, #28]	; (30011688 <MCU_delay+0x2a>)
3001166a:	681b      	ldr	r3, [r3, #0]

#ifdef MPROC_PM__ULTRA_LOW_POWER
	/* if clock source is spl or bbl instead of xtal, then set delay
	 * count to a much smaller value.
	 */
	if (sys_read32(CRMU_CLOCK_SWITCH_STATUS) != 1)
3001166c:	2b01      	cmp	r3, #1
3001166e:	d002      	beq.n	30011676 <MCU_delay+0x18>
		/* precise divider should be 25000000 / 32768 = 762 */
		count = (count >> 9);
30011670:	9b01      	ldr	r3, [sp, #4]
30011672:	0a5b      	lsrs	r3, r3, #9
30011674:	9301      	str	r3, [sp, #4]
#endif

	do {} while (count--);
30011676:	9b01      	ldr	r3, [sp, #4]
30011678:	1e5a      	subs	r2, r3, #1
3001167a:	9201      	str	r2, [sp, #4]
3001167c:	2b00      	cmp	r3, #0
3001167e:	d1fa      	bne.n	30011676 <MCU_delay+0x18>
}
30011680:	b002      	add	sp, #8
30011682:	4770      	bx	lr
30011684:	00030d40 	.word	0x00030d40
30011688:	3001c05c 	.word	0x3001c05c

3001168c <MCU_die>:
 * @param none
 *
 * @return none
 */
void MCU_die(void)
{
3001168c:	e7fe      	b.n	3001168c <MCU_die>

3001168e <MCU_get_timer_count>:
 * @param us
 *
 * @return result
 */
u32_t MCU_get_timer_count(u32_t us)
{
3001168e:	0002      	movs	r2, r0
30011690:	4b0b      	ldr	r3, [pc, #44]	; (300116c0 <MCU_get_timer_count+0x32>)
30011692:	681b      	ldr	r3, [r3, #0]
	u32_t clk_src = sys_read32(CRMU_CLOCK_SWITCH_STATUS);
	u32_t counts = 0;

	if (clk_src == 0x1) /* 25MHz xtal, unit is 40ns */
30011694:	2b01      	cmp	r3, #1
30011696:	d006      	beq.n	300116a6 <MCU_get_timer_count+0x18>
		counts = us * 26;
	/* TODO: Is this valid for Citadel? */
	else if (clk_src == 0x2) /* 11.5MHz spl ro, unit is 87ns */
30011698:	2b02      	cmp	r3, #2
3001169a:	d009      	beq.n	300116b0 <MCU_get_timer_count+0x22>
		counts = us * 11;
	else if (clk_src == 0x4) /* 32KHz bbl, unit is 31.25us, use 32us */
		counts = (us >> 5);

	if (!counts)
		counts = 1;
3001169c:	2001      	movs	r0, #1
	else if (clk_src == 0x4) /* 32KHz bbl, unit is 31.25us, use 32us */
3001169e:	2b04      	cmp	r3, #4
300116a0:	d105      	bne.n	300116ae <MCU_get_timer_count+0x20>
		counts = (us >> 5);
300116a2:	0950      	lsrs	r0, r2, #5
300116a4:	e001      	b.n	300116aa <MCU_get_timer_count+0x1c>
		counts = us * 26;
300116a6:	201a      	movs	r0, #26
300116a8:	4350      	muls	r0, r2
	if (!counts)
300116aa:	2800      	cmp	r0, #0
300116ac:	d005      	beq.n	300116ba <MCU_get_timer_count+0x2c>

	return counts;
}
300116ae:	4770      	bx	lr
		counts = us * 11;
300116b0:	0083      	lsls	r3, r0, #2
300116b2:	181b      	adds	r3, r3, r0
300116b4:	005b      	lsls	r3, r3, #1
300116b6:	1818      	adds	r0, r3, r0
300116b8:	e7f7      	b.n	300116aa <MCU_get_timer_count+0x1c>
		counts = 1;
300116ba:	3001      	adds	r0, #1
300116bc:	e7f7      	b.n	300116ae <MCU_get_timer_count+0x20>
300116be:	46c0      	nop			; (mov r8, r8)
300116c0:	3001c05c 	.word	0x3001c05c

300116c4 <MCU_timer_udelay>:
 * @param us
 *
 * @return none
 */
void MCU_timer_udelay(u32_t us)
{
300116c4:	b510      	push	{r4, lr}
	u32_t counts = MCU_get_timer_count(us);
300116c6:	f7ff ffe2 	bl	3001168e <MCU_get_timer_count>
	*(volatile u32_t *)addr = data;
300116ca:	4b0b      	ldr	r3, [pc, #44]	; (300116f8 <MCU_timer_udelay+0x34>)
300116cc:	6018      	str	r0, [r3, #0]
300116ce:	2201      	movs	r2, #1
300116d0:	4b0a      	ldr	r3, [pc, #40]	; (300116fc <MCU_timer_udelay+0x38>)
300116d2:	601a      	str	r2, [r3, #0]
300116d4:	3282      	adds	r2, #130	; 0x82
300116d6:	4b0a      	ldr	r3, [pc, #40]	; (30011700 <MCU_timer_udelay+0x3c>)
300116d8:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
300116da:	4a0a      	ldr	r2, [pc, #40]	; (30011704 <MCU_timer_udelay+0x40>)
300116dc:	6813      	ldr	r3, [r2, #0]
	sys_write32(0x1, CRMU_TIM_TIMER2IntClr);

	/* Only enable crmu timer */
	sys_write32(0x83, CRMU_TIM_TIMER2Control);

	while (!sys_read32(CRMU_TIM_TIMER2RIS))
300116de:	2b00      	cmp	r3, #0
300116e0:	d0fc      	beq.n	300116dc <MCU_timer_udelay+0x18>
	*(volatile u32_t *)addr = data;
300116e2:	2201      	movs	r2, #1
300116e4:	4b05      	ldr	r3, [pc, #20]	; (300116fc <MCU_timer_udelay+0x38>)
300116e6:	601a      	str	r2, [r3, #0]
300116e8:	3a02      	subs	r2, #2
300116ea:	4b03      	ldr	r3, [pc, #12]	; (300116f8 <MCU_timer_udelay+0x34>)
300116ec:	601a      	str	r2, [r3, #0]
300116ee:	2200      	movs	r2, #0
300116f0:	4b03      	ldr	r3, [pc, #12]	; (30011700 <MCU_timer_udelay+0x3c>)
300116f2:	601a      	str	r2, [r3, #0]
		;   /* Wait for timeout       */

	sys_write32(0x1, CRMU_TIM_TIMER2IntClr); /* Interrupt clear */
	sys_write32(0xFFFFFFFF, CRMU_TIM_TIMER2Load);
	sys_write32(0x0, CRMU_TIM_TIMER2Control); /* Disable timer */
}
300116f4:	bd10      	pop	{r4, pc}
300116f6:	46c0      	nop			; (mov r8, r8)
300116f8:	30023020 	.word	0x30023020
300116fc:	3002302c 	.word	0x3002302c
30011700:	30023028 	.word	0x30023028
30011704:	30023030 	.word	0x30023030

30011708 <MCU_timer_raw_delay>:
30011708:	4b0a      	ldr	r3, [pc, #40]	; (30011734 <MCU_timer_raw_delay+0x2c>)
3001170a:	6018      	str	r0, [r3, #0]
3001170c:	2201      	movs	r2, #1
3001170e:	4b0a      	ldr	r3, [pc, #40]	; (30011738 <MCU_timer_raw_delay+0x30>)
30011710:	601a      	str	r2, [r3, #0]
30011712:	3282      	adds	r2, #130	; 0x82
30011714:	4b09      	ldr	r3, [pc, #36]	; (3001173c <MCU_timer_raw_delay+0x34>)
30011716:	601a      	str	r2, [r3, #0]
	return *(volatile u32_t *)addr;
30011718:	4a09      	ldr	r2, [pc, #36]	; (30011740 <MCU_timer_raw_delay+0x38>)
3001171a:	6813      	ldr	r3, [r2, #0]
	sys_write32(counts, CRMU_TIM_TIMER2Load);
	/* Interrupt clear        */
	sys_write32(0x1, CRMU_TIM_TIMER2IntClr);
	/* Only enable crmu timer */
	sys_write32(0x83, CRMU_TIM_TIMER2Control);
	while (!sys_read32(CRMU_TIM_TIMER2RIS))
3001171c:	2b00      	cmp	r3, #0
3001171e:	d0fc      	beq.n	3001171a <MCU_timer_raw_delay+0x12>
	*(volatile u32_t *)addr = data;
30011720:	2201      	movs	r2, #1
30011722:	4b05      	ldr	r3, [pc, #20]	; (30011738 <MCU_timer_raw_delay+0x30>)
30011724:	601a      	str	r2, [r3, #0]
30011726:	3a02      	subs	r2, #2
30011728:	4b02      	ldr	r3, [pc, #8]	; (30011734 <MCU_timer_raw_delay+0x2c>)
3001172a:	601a      	str	r2, [r3, #0]
3001172c:	2200      	movs	r2, #0
3001172e:	4b03      	ldr	r3, [pc, #12]	; (3001173c <MCU_timer_raw_delay+0x34>)
30011730:	601a      	str	r2, [r3, #0]
		;   /* Wait for timeout       */

	sys_write32(0x1, CRMU_TIM_TIMER2IntClr); /* Interrupt clear */
	sys_write32(0xFFFFFFFF, CRMU_TIM_TIMER2Load);
	sys_write32(0x0, CRMU_TIM_TIMER2Control); /* Disable timer */
}
30011732:	4770      	bx	lr
30011734:	30023020 	.word	0x30023020
30011738:	3002302c 	.word	0x3002302c
3001173c:	30023028 	.word	0x30023028
30011740:	30023030 	.word	0x30023030

30011744 <MCU_get_soc_rev>:

CITADEL_REVISION_e MCU_get_soc_rev(void)
{
	CITADEL_PM_ISR_ARGS_s *pm_args = CRMU_GET_PM_ISR_ARGS();

	return pm_args->soc_rev;
30011744:	2350      	movs	r3, #80	; 0x50
30011746:	4a01      	ldr	r2, [pc, #4]	; (3001174c <MCU_get_soc_rev+0x8>)
30011748:	5cd0      	ldrb	r0, [r2, r3]
}
3001174a:	4770      	bx	lr
3001174c:	30010000 	.word	0x30010000

30011750 <MCU_get_irq>:

u32_t MCU_get_irq(DMU_MCU_IRQ_ID_e id)
{
30011750:	0002      	movs	r2, r0
	return *(volatile u32_t *)addr;
30011752:	4b03      	ldr	r3, [pc, #12]	; (30011760 <MCU_get_irq+0x10>)
30011754:	681b      	ldr	r3, [r3, #0]
	return (sys_read32(CRMU_MCU_INTR_MASK) & BIT(id));
30011756:	2001      	movs	r0, #1
30011758:	4090      	lsls	r0, r2
3001175a:	4018      	ands	r0, r3
}
3001175c:	4770      	bx	lr
3001175e:	46c0      	nop			; (mov r8, r8)
30011760:	30024054 	.word	0x30024054

30011764 <MCU_enable_irq>:

void MCU_enable_irq(DMU_MCU_IRQ_ID_e id, s32_t en)
{
	if (en)
30011764:	2900      	cmp	r1, #0
30011766:	d106      	bne.n	30011776 <MCU_enable_irq+0x12>
	u32_t temp = *(volatile u32_t *)addr;
30011768:	4a06      	ldr	r2, [pc, #24]	; (30011784 <MCU_enable_irq+0x20>)
3001176a:	6811      	ldr	r1, [r2, #0]
	*(volatile u32_t *)addr = temp | (1 << bit);
3001176c:	2301      	movs	r3, #1
3001176e:	4083      	lsls	r3, r0
30011770:	430b      	orrs	r3, r1
30011772:	6013      	str	r3, [r2, #0]
		/* unmasked */
		sys_clear_bit(CRMU_MCU_INTR_MASK, id);
	else
		/* masked*/
		sys_set_bit(CRMU_MCU_INTR_MASK, id);
}
30011774:	4770      	bx	lr
	u32_t temp = *(volatile u32_t *)addr;
30011776:	4903      	ldr	r1, [pc, #12]	; (30011784 <MCU_enable_irq+0x20>)
30011778:	680b      	ldr	r3, [r1, #0]
	*(volatile u32_t *)addr = temp & ~(1 << bit);
3001177a:	2201      	movs	r2, #1
3001177c:	4082      	lsls	r2, r0
3001177e:	4393      	bics	r3, r2
30011780:	600b      	str	r3, [r1, #0]
30011782:	e7f7      	b.n	30011774 <MCU_enable_irq+0x10>
30011784:	30024054 	.word	0x30024054

30011788 <MCU_check_irq>:
	return *(volatile u32_t *)addr;
30011788:	4b02      	ldr	r3, [pc, #8]	; (30011794 <MCU_check_irq+0xc>)
3001178a:	681b      	ldr	r3, [r3, #0]

s32_t MCU_check_irq(DMU_MCU_IRQ_ID_e id)
{
	return cpu_reg32_getbit(CRMU_MCU_INTR_STATUS, id);
3001178c:	40c3      	lsrs	r3, r0
3001178e:	2001      	movs	r0, #1
30011790:	4018      	ands	r0, r3
}
30011792:	4770      	bx	lr
30011794:	30024050 	.word	0x30024050

30011798 <MCU_clear_irq>:
void MCU_clear_irq(DMU_MCU_IRQ_ID_e id)
{
	/* ONLY write 1 to id bit to clear interrupt,
	 * other bits to 0, no effect
	 */
	sys_write32(BIT(id), CRMU_MCU_INTR_CLEAR);
30011798:	2301      	movs	r3, #1
3001179a:	4083      	lsls	r3, r0
	*(volatile u32_t *)addr = data;
3001179c:	4a01      	ldr	r2, [pc, #4]	; (300117a4 <MCU_clear_irq+0xc>)
3001179e:	6013      	str	r3, [r2, #0]
}
300117a0:	4770      	bx	lr
300117a2:	46c0      	nop			; (mov r8, r8)
300117a4:	30024058 	.word	0x30024058

300117a8 <MCU_get_event>:

u32_t MCU_get_event(DMU_MCU_EVENT_ID_e id)
{
300117a8:	0002      	movs	r2, r0
	return *(volatile u32_t *)addr;
300117aa:	4b03      	ldr	r3, [pc, #12]	; (300117b8 <MCU_get_event+0x10>)
300117ac:	681b      	ldr	r3, [r3, #0]
	return (sys_read32(CRMU_MCU_EVENT_MASK) & BIT(id));
300117ae:	2001      	movs	r0, #1
300117b0:	4090      	lsls	r0, r2
300117b2:	4018      	ands	r0, r3
}
300117b4:	4770      	bx	lr
300117b6:	46c0      	nop			; (mov r8, r8)
300117b8:	30024064 	.word	0x30024064

300117bc <MCU_enable_event>:

void MCU_enable_event(DMU_MCU_EVENT_ID_e id, s32_t en)
{
	if (en)
300117bc:	2900      	cmp	r1, #0
300117be:	d106      	bne.n	300117ce <MCU_enable_event+0x12>
	u32_t temp = *(volatile u32_t *)addr;
300117c0:	4a06      	ldr	r2, [pc, #24]	; (300117dc <MCU_enable_event+0x20>)
300117c2:	6811      	ldr	r1, [r2, #0]
	*(volatile u32_t *)addr = temp | (1 << bit);
300117c4:	2301      	movs	r3, #1
300117c6:	4083      	lsls	r3, r0
300117c8:	430b      	orrs	r3, r1
300117ca:	6013      	str	r3, [r2, #0]
		/* unmasked */
		sys_clear_bit(CRMU_MCU_EVENT_MASK, id);
	else
		/* masked */
		sys_set_bit(CRMU_MCU_EVENT_MASK, id);
}
300117cc:	4770      	bx	lr
	u32_t temp = *(volatile u32_t *)addr;
300117ce:	4903      	ldr	r1, [pc, #12]	; (300117dc <MCU_enable_event+0x20>)
300117d0:	680b      	ldr	r3, [r1, #0]
	*(volatile u32_t *)addr = temp & ~(1 << bit);
300117d2:	2201      	movs	r2, #1
300117d4:	4082      	lsls	r2, r0
300117d6:	4393      	bics	r3, r2
300117d8:	600b      	str	r3, [r1, #0]
300117da:	e7f7      	b.n	300117cc <MCU_enable_event+0x10>
300117dc:	30024064 	.word	0x30024064

300117e0 <MCU_check_event>:
	return *(volatile u32_t *)addr;
300117e0:	4b02      	ldr	r3, [pc, #8]	; (300117ec <MCU_check_event+0xc>)
300117e2:	681b      	ldr	r3, [r3, #0]

s32_t MCU_check_event(DMU_MCU_EVENT_ID_e id)
{
	return cpu_reg32_getbit(CRMU_MCU_EVENT_STATUS, id);
300117e4:	40c3      	lsrs	r3, r0
300117e6:	2001      	movs	r0, #1
300117e8:	4018      	ands	r0, r3
}
300117ea:	4770      	bx	lr
300117ec:	3002405c 	.word	0x3002405c

300117f0 <MCU_clear_event>:
void MCU_clear_event(DMU_MCU_EVENT_ID_e id)
{
	/* ONLY write 1 to id bit to clear interrupt,
	 * other bits to 0, no effect
	 */
	sys_write32(BIT(id), CRMU_MCU_EVENT_CLEAR);
300117f0:	2301      	movs	r3, #1
300117f2:	4083      	lsls	r3, r0
	*(volatile u32_t *)addr = data;
300117f4:	4a01      	ldr	r2, [pc, #4]	; (300117fc <MCU_clear_event+0xc>)
300117f6:	6013      	str	r3, [r2, #0]
}
300117f8:	4770      	bx	lr
300117fa:	46c0      	nop			; (mov r8, r8)
300117fc:	30024060 	.word	0x30024060

30011800 <MCU_send_msg_to_mproc>:
30011800:	4b02      	ldr	r3, [pc, #8]	; (3001180c <MCU_send_msg_to_mproc+0xc>)
30011802:	6018      	str	r0, [r3, #0]
30011804:	4b02      	ldr	r3, [pc, #8]	; (30011810 <MCU_send_msg_to_mproc+0x10>)
30011806:	6019      	str	r1, [r3, #0]

void MCU_send_msg_to_mproc(u32_t code0, u32_t code1)
{
	sys_write32(code0, CRMU_IPROC_MAIL_BOX0);
	sys_write32(code1, CRMU_IPROC_MAIL_BOX1);
}
30011808:	4770      	bx	lr
3001180a:	46c0      	nop			; (mov r8, r8)
3001180c:	30024030 	.word	0x30024030
30011810:	30024034 	.word	0x30024034

30011814 <MCU_send_msg_to_mcu>:
30011814:	4b02      	ldr	r3, [pc, #8]	; (30011820 <MCU_send_msg_to_mcu+0xc>)
30011816:	6018      	str	r0, [r3, #0]
30011818:	4b02      	ldr	r3, [pc, #8]	; (30011824 <MCU_send_msg_to_mcu+0x10>)
3001181a:	6019      	str	r1, [r3, #0]

void MCU_send_msg_to_mcu(u32_t code0, u32_t code1)
{
	sys_write32(code0, IPROC_CRMU_MAIL_BOX0);
	sys_write32(code1, IPROC_CRMU_MAIL_BOX1);
}
3001181c:	4770      	bx	lr
3001181e:	46c0      	nop			; (mov r8, r8)
30011820:	30024028 	.word	0x30024028
30011824:	3002402c 	.word	0x3002402c

30011828 <MCU_set_irq_user_vector>:
 *
 * @return none
 */
void MCU_set_irq_user_vector(u32_t irq, u32_t addr)
{
	if (irq < MCU_NVIC_MAXIRQs)
30011828:	281f      	cmp	r0, #31
3001182a:	d804      	bhi.n	30011836 <MCU_set_irq_user_vector+0xe>
		sys_write32(CRMU_IRQx_vector_USER(irq), addr);
3001182c:	4b02      	ldr	r3, [pc, #8]	; (30011838 <MCU_set_irq_user_vector+0x10>)
3001182e:	469c      	mov	ip, r3
30011830:	4460      	add	r0, ip
30011832:	0080      	lsls	r0, r0, #2
30011834:	6008      	str	r0, [r1, #0]
}
30011836:	4770      	bx	lr
30011838:	0c0063e0 	.word	0x0c0063e0

3001183c <MCU_set_pdsys_master_clock_gating>:
 *
 * @return none
 */
void MCU_set_pdsys_master_clock_gating(s32_t en)
{
	if (en) {
3001183c:	2800      	cmp	r0, #0
3001183e:	d107      	bne.n	30011850 <MCU_set_pdsys_master_clock_gating+0x14>
30011840:	2201      	movs	r2, #1
30011842:	4252      	negs	r2, r2
30011844:	4b06      	ldr	r3, [pc, #24]	; (30011860 <MCU_set_pdsys_master_clock_gating+0x24>)
30011846:	601a      	str	r2, [r3, #0]
30011848:	2200      	movs	r2, #0
3001184a:	4b06      	ldr	r3, [pc, #24]	; (30011864 <MCU_set_pdsys_master_clock_gating+0x28>)
3001184c:	601a      	str	r2, [r3, #0]
		/*enable master clock for PDSYS clocks*/
		sys_write32(0xffffffff, CRMU_CLOCK_GATE_CONTROL);
		/*enable MPROC clocks clock*/
		sys_write32(0x0, CDRU_CLK_DIS_CTRL);
	}
}
3001184e:	4770      	bx	lr
30011850:	223f      	movs	r2, #63	; 0x3f
30011852:	4b03      	ldr	r3, [pc, #12]	; (30011860 <MCU_set_pdsys_master_clock_gating+0x24>)
30011854:	601a      	str	r2, [r3, #0]
30011856:	3a48      	subs	r2, #72	; 0x48
30011858:	4b02      	ldr	r3, [pc, #8]	; (30011864 <MCU_set_pdsys_master_clock_gating+0x28>)
3001185a:	601a      	str	r2, [r3, #0]
3001185c:	e7f7      	b.n	3001184e <MCU_set_pdsys_master_clock_gating+0x12>
3001185e:	46c0      	nop			; (mov r8, r8)
30011860:	3001c050 	.word	0x3001c050
30011864:	3001d08c 	.word	0x3001d08c

30011868 <MCU_setup_aongpio>:
 * @param en - 1: enabled 0: disabled
 *
 * @return none
 */
void MCU_setup_aongpio(MPROC_LOW_POWER_OP_e op)
{
30011868:	b5f0      	push	{r4, r5, r6, r7, lr}
3001186a:	46c6      	mov	lr, r8
3001186c:	b500      	push	{lr}
	CITADEL_PM_ISR_ARGS_s *pm_args = CRMU_GET_PM_ISR_ARGS();
	MPROC_AON_GPIO_WAKEUP_SETTINGS_s *aon_gpio_setting;
	u32_t wakeup_src = 0, int_type = 0, int_de = 0, int_edge = 0;

	aon_gpio_setting = &pm_args->aon_gpio_settings;
	if (op == MPROC_ENTER_LP) { /*Set AON_GPIO interrupt trigger mode*/
3001186e:	2801      	cmp	r0, #1
30011870:	d002      	beq.n	30011878 <MCU_setup_aongpio+0x10>
	else {
		/* FIXME: Shouldn't the programming above be undone?
		 * Confirm requirements.
		 */
	}
}
30011872:	bc04      	pop	{r2}
30011874:	4690      	mov	r8, r2
30011876:	bdf0      	pop	{r4, r5, r6, r7, pc}
		wakeup_src = aon_gpio_setting->wakeup_src;
30011878:	4b17      	ldr	r3, [pc, #92]	; (300118d8 <MCU_setup_aongpio+0x70>)
3001187a:	689c      	ldr	r4, [r3, #8]
		int_type   = aon_gpio_setting->int_type;
3001187c:	68da      	ldr	r2, [r3, #12]
		int_de	   = aon_gpio_setting->int_de;
3001187e:	6919      	ldr	r1, [r3, #16]
30011880:	4688      	mov	r8, r1
		int_edge   = aon_gpio_setting->int_edge;
30011882:	695f      	ldr	r7, [r3, #20]
		if (wakeup_src)
30011884:	2c00      	cmp	r4, #0
30011886:	d003      	beq.n	30011890 <MCU_setup_aongpio+0x28>
	u32_t temp = *(volatile u32_t *)addr;
30011888:	4914      	ldr	r1, [pc, #80]	; (300118dc <MCU_setup_aongpio+0x74>)
3001188a:	680b      	ldr	r3, [r1, #0]
	*(volatile u32_t *)addr = temp | (1 << bit);
3001188c:	4303      	orrs	r3, r0
3001188e:	600b      	str	r3, [r1, #0]
	u32_t temp = *(volatile u32_t *)addr;
30011890:	4d13      	ldr	r5, [pc, #76]	; (300118e0 <MCU_setup_aongpio+0x78>)
30011892:	682b      	ldr	r3, [r5, #0]
	*(volatile u32_t *)addr = temp | (1 << bit);
30011894:	2604      	movs	r6, #4
30011896:	4333      	orrs	r3, r6
30011898:	602b      	str	r3, [r5, #0]
		cpu_reg32_wr_masked_bits(GP_INT_TYPE, wakeup_src, int_type);
3001189a:	0021      	movs	r1, r4
3001189c:	4811      	ldr	r0, [pc, #68]	; (300118e4 <MCU_setup_aongpio+0x7c>)
3001189e:	f7ff feb7 	bl	30011610 <cpu_reg32_wr_masked_bits>
		cpu_reg32_wr_masked_bits(GP_INT_DE, wakeup_src, int_de);
300118a2:	4642      	mov	r2, r8
300118a4:	0021      	movs	r1, r4
300118a6:	4810      	ldr	r0, [pc, #64]	; (300118e8 <MCU_setup_aongpio+0x80>)
300118a8:	f7ff feb2 	bl	30011610 <cpu_reg32_wr_masked_bits>
		cpu_reg32_wr_masked_bits(GP_INT_EDGE, wakeup_src, int_edge);
300118ac:	003a      	movs	r2, r7
300118ae:	0021      	movs	r1, r4
300118b0:	480e      	ldr	r0, [pc, #56]	; (300118ec <MCU_setup_aongpio+0x84>)
300118b2:	f7ff fead 	bl	30011610 <cpu_reg32_wr_masked_bits>
		cpu_reg32_clr_masked_bits(GP_OUT_EN, wakeup_src);
300118b6:	0021      	movs	r1, r4
300118b8:	480d      	ldr	r0, [pc, #52]	; (300118f0 <MCU_setup_aongpio+0x88>)
300118ba:	f7ff fea5 	bl	30011608 <cpu_reg32_clr_masked_bits>
	return *(volatile u32_t *)addr;
300118be:	4b0d      	ldr	r3, [pc, #52]	; (300118f4 <MCU_setup_aongpio+0x8c>)
300118c0:	681a      	ldr	r2, [r3, #0]
	regval |= mask;
300118c2:	4314      	orrs	r4, r2
	*(volatile u32_t *)addr = data;
300118c4:	601c      	str	r4, [r3, #0]
		MCU_SYNC();
300118c6:	f7ff fe89 	bl	300115dc <MCU_SYNC>
300118ca:	4a0b      	ldr	r2, [pc, #44]	; (300118f8 <MCU_setup_aongpio+0x90>)
300118cc:	4b0b      	ldr	r3, [pc, #44]	; (300118fc <MCU_setup_aongpio+0x94>)
300118ce:	601a      	str	r2, [r3, #0]
	u32_t temp = *(volatile u32_t *)addr;
300118d0:	682b      	ldr	r3, [r5, #0]
	*(volatile u32_t *)addr = temp & ~(1 << bit);
300118d2:	43b3      	bics	r3, r6
300118d4:	602b      	str	r3, [r5, #0]
}
300118d6:	e7cc      	b.n	30011872 <MCU_setup_aongpio+0xa>
300118d8:	30010000 	.word	0x30010000
300118dc:	30024004 	.word	0x30024004
300118e0:	30024054 	.word	0x30024054
300118e4:	3002480c 	.word	0x3002480c
300118e8:	30024810 	.word	0x30024810
300118ec:	30024814 	.word	0x30024814
300118f0:	30024808 	.word	0x30024808
300118f4:	30024818 	.word	0x30024818
300118f8:	000007ff 	.word	0x000007ff
300118fc:	30024824 	.word	0x30024824

30011900 <MCU_setup_usb>:
 * @param en - 1: enabled 0: disabled
 *
 * @return none
 */
void MCU_setup_usb(MPROC_LOW_POWER_OP_e op)
{
30011900:	b510      	push	{r4, lr}
	CITADEL_PM_ISR_ARGS_s *pm_args = CRMU_GET_PM_ISR_ARGS();
	MPROC_USB_WAKEUP_SETTINGS_s *usb_setting;
	u32_t wakeup_src = 0;

	usb_setting = &pm_args->usb_settings;
	if (op == MPROC_ENTER_LP) { /*Set AON_GPIO interrupt trigger mode*/
30011902:	2801      	cmp	r0, #1
30011904:	d000      	beq.n	30011908 <MCU_setup_usb+0x8>
	else {
		/* FIXME: Shouldn't the programming above be undone?
		 * Confirm requirements.
		 */
	}
}
30011906:	bd10      	pop	{r4, pc}
		wakeup_src = usb_setting->wakeup_src;
30011908:	4b0b      	ldr	r3, [pc, #44]	; (30011938 <MCU_setup_usb+0x38>)
		if (wakeup_src) {
3001190a:	699b      	ldr	r3, [r3, #24]
3001190c:	2b00      	cmp	r3, #0
3001190e:	d0fa      	beq.n	30011906 <MCU_setup_usb+0x6>
	u32_t temp = *(volatile u32_t *)addr;
30011910:	4b0a      	ldr	r3, [pc, #40]	; (3001193c <MCU_setup_usb+0x3c>)
30011912:	681a      	ldr	r2, [r3, #0]
	*(volatile u32_t *)addr = temp & ~(1 << bit);
30011914:	490a      	ldr	r1, [pc, #40]	; (30011940 <MCU_setup_usb+0x40>)
30011916:	400a      	ands	r2, r1
30011918:	601a      	str	r2, [r3, #0]
	u32_t temp = *(volatile u32_t *)addr;
3001191a:	681a      	ldr	r2, [r3, #0]
	*(volatile u32_t *)addr = temp & ~(1 << bit);
3001191c:	4909      	ldr	r1, [pc, #36]	; (30011944 <MCU_setup_usb+0x44>)
3001191e:	400a      	ands	r2, r1
30011920:	601a      	str	r2, [r3, #0]
	u32_t temp = *(volatile u32_t *)addr;
30011922:	681a      	ldr	r2, [r3, #0]
	*(volatile u32_t *)addr = temp & ~(1 << bit);
30011924:	4908      	ldr	r1, [pc, #32]	; (30011948 <MCU_setup_usb+0x48>)
30011926:	400a      	ands	r2, r1
30011928:	601a      	str	r2, [r3, #0]
	u32_t temp = *(volatile u32_t *)addr;
3001192a:	681a      	ldr	r2, [r3, #0]
	*(volatile u32_t *)addr = temp & ~(1 << bit);
3001192c:	4907      	ldr	r1, [pc, #28]	; (3001194c <MCU_setup_usb+0x4c>)
3001192e:	400a      	ands	r2, r1
30011930:	601a      	str	r2, [r3, #0]
			MCU_SYNC();
30011932:	f7ff fe53 	bl	300115dc <MCU_SYNC>
}
30011936:	e7e6      	b.n	30011906 <MCU_setup_usb+0x6>
30011938:	30010000 	.word	0x30010000
3001193c:	30024064 	.word	0x30024064
30011940:	ffffefff 	.word	0xffffefff
30011944:	ffffdfff 	.word	0xffffdfff
30011948:	ffffbfff 	.word	0xffffbfff
3001194c:	ffff7fff 	.word	0xffff7fff

30011950 <spru_interface_reset>:
 * @param none
 *
 * @return none
 */
void spru_interface_reset(void)
{
30011950:	b570      	push	{r4, r5, r6, lr}
	*(volatile u32_t *)addr = data;
30011952:	4d07      	ldr	r5, [pc, #28]	; (30011970 <spru_interface_reset+0x20>)
30011954:	2300      	movs	r3, #0
30011956:	602b      	str	r3, [r5, #0]
	sys_write32(0x0, SPRU_BBL_CMD); /* reset */
	MCU_timer_udelay(320);
30011958:	24a0      	movs	r4, #160	; 0xa0
3001195a:	0064      	lsls	r4, r4, #1
3001195c:	0020      	movs	r0, r4
3001195e:	f7ff feb1 	bl	300116c4 <MCU_timer_udelay>
30011962:	2380      	movs	r3, #128	; 0x80
30011964:	00db      	lsls	r3, r3, #3
30011966:	602b      	str	r3, [r5, #0]
	/* release reset */
	sys_write32(BIT(SPRU_BBL_CMD__IND_SOFT_RST_N), SPRU_BBL_CMD);
	MCU_timer_udelay(320);
30011968:	0020      	movs	r0, r4
3001196a:	f7ff feab 	bl	300116c4 <MCU_timer_udelay>
}
3001196e:	bd70      	pop	{r4, r5, r6, pc}
30011970:	30026004 	.word	0x30026004

30011974 <bbl_write_reg>:
 * @param data to be written
 *
 * @return result (Success / Failure)
 */
s32_t bbl_write_reg(u32_t regAddr, u32_t wrDat)
{
30011974:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
30011976:	46ce      	mov	lr, r9
30011978:	4647      	mov	r7, r8
3001197a:	b580      	push	{r7, lr}
	return *(volatile u32_t *)addr;
3001197c:	4b1c      	ldr	r3, [pc, #112]	; (300119f0 <bbl_write_reg+0x7c>)
3001197e:	681a      	ldr	r2, [r3, #0]
	return (sys_read32(CRMU_MCU_EVENT_MASK) & BIT(id));
30011980:	2380      	movs	r3, #128	; 0x80
30011982:	04db      	lsls	r3, r3, #19
30011984:	401a      	ands	r2, r3
30011986:	4690      	mov	r8, r2
	s32_t rc = -1;
	int alarm_evt;

	alarm_evt  = MCU_get_event(MCU_SPRU_ALARM_EVENT);

	if (alarm_evt != 0)
30011988:	d10a      	bne.n	300119a0 <bbl_write_reg+0x2c>
	*(volatile u32_t *)addr = data;
3001198a:	4b1a      	ldr	r3, [pc, #104]	; (300119f4 <bbl_write_reg+0x80>)
3001198c:	6019      	str	r1, [r3, #0]
3001198e:	2603      	movs	r6, #3
30011990:	4b19      	ldr	r3, [pc, #100]	; (300119f8 <bbl_write_reg+0x84>)
30011992:	4699      	mov	r9, r3
30011994:	27c0      	movs	r7, #192	; 0xc0
30011996:	013f      	lsls	r7, r7, #4
30011998:	4307      	orrs	r7, r0
	return *(volatile u32_t *)addr;
3001199a:	4d18      	ldr	r5, [pc, #96]	; (300119fc <bbl_write_reg+0x88>)
			 & 0x00000001) == en) {
3001199c:	2401      	movs	r4, #1
3001199e:	e019      	b.n	300119d4 <bbl_write_reg+0x60>
	u32_t temp = *(volatile u32_t *)addr;
300119a0:	4a13      	ldr	r2, [pc, #76]	; (300119f0 <bbl_write_reg+0x7c>)
300119a2:	6814      	ldr	r4, [r2, #0]
	*(volatile u32_t *)addr = temp | (1 << bit);
300119a4:	2380      	movs	r3, #128	; 0x80
300119a6:	04db      	lsls	r3, r3, #19
300119a8:	4323      	orrs	r3, r4
300119aa:	6013      	str	r3, [r2, #0]
300119ac:	e7ed      	b.n	3001198a <bbl_write_reg+0x16>
	spru_wr_data(wrDat);
	for (i = 0; i < 3; i++) {
		spru_wr_cmd(regAddr);
		result = spru_poll_status(1, 500);
		if (result == 0) {
			rc = 0;
300119ae:	2000      	movs	r0, #0
			break;
		}
		spru_interface_reset();
	}
	if (alarm_evt != 0)
300119b0:	4643      	mov	r3, r8
300119b2:	2b00      	cmp	r3, #0
300119b4:	d103      	bne.n	300119be <bbl_write_reg+0x4a>
		MCU_enable_event(MCU_SPRU_ALARM_EVENT, 1);

	return rc;
}
300119b6:	bc0c      	pop	{r2, r3}
300119b8:	4690      	mov	r8, r2
300119ba:	4699      	mov	r9, r3
300119bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	u32_t temp = *(volatile u32_t *)addr;
300119be:	4a0c      	ldr	r2, [pc, #48]	; (300119f0 <bbl_write_reg+0x7c>)
300119c0:	6813      	ldr	r3, [r2, #0]
	*(volatile u32_t *)addr = temp & ~(1 << bit);
300119c2:	490f      	ldr	r1, [pc, #60]	; (30011a00 <bbl_write_reg+0x8c>)
300119c4:	400b      	ands	r3, r1
300119c6:	6013      	str	r3, [r2, #0]
	return rc;
300119c8:	e7f5      	b.n	300119b6 <bbl_write_reg+0x42>
		spru_interface_reset();
300119ca:	f7ff ffc1 	bl	30011950 <spru_interface_reset>
300119ce:	3e01      	subs	r6, #1
	for (i = 0; i < 3; i++) {
300119d0:	2e00      	cmp	r6, #0
300119d2:	d00a      	beq.n	300119ea <bbl_write_reg+0x76>
	*(volatile u32_t *)addr = data;
300119d4:	464b      	mov	r3, r9
300119d6:	601f      	str	r7, [r3, #0]
300119d8:	23f6      	movs	r3, #246	; 0xf6
300119da:	33ff      	adds	r3, #255	; 0xff
	return *(volatile u32_t *)addr;
300119dc:	682a      	ldr	r2, [r5, #0]
		if (((sys_read32(SPRU_BBL_STATUS) >> SPRU_BBL_STATUS__ACC_DONE)
300119de:	4214      	tst	r4, r2
300119e0:	d1e5      	bne.n	300119ae <bbl_write_reg+0x3a>
300119e2:	3b01      	subs	r3, #1
	} while (num_tries--); /* Number of Tries */
300119e4:	2b00      	cmp	r3, #0
300119e6:	d1f9      	bne.n	300119dc <bbl_write_reg+0x68>
300119e8:	e7ef      	b.n	300119ca <bbl_write_reg+0x56>
	s32_t rc = -1;
300119ea:	2001      	movs	r0, #1
300119ec:	4240      	negs	r0, r0
300119ee:	e7df      	b.n	300119b0 <bbl_write_reg+0x3c>
300119f0:	30024064 	.word	0x30024064
300119f4:	30026000 	.word	0x30026000
300119f8:	30026004 	.word	0x30026004
300119fc:	30026008 	.word	0x30026008
30011a00:	fbffffff 	.word	0xfbffffff

30011a04 <bbl_read_reg>:
 * @param register address
 * @param return location to hold data read
 *
 * @return result (Success / Failure)
 */
s32_t bbl_read_reg(u32_t regAddr, u32_t *p_dat) {
30011a04:	b5f0      	push	{r4, r5, r6, r7, lr}
30011a06:	46d6      	mov	lr, sl
30011a08:	464f      	mov	r7, r9
30011a0a:	4646      	mov	r6, r8
30011a0c:	b5c0      	push	{r6, r7, lr}
30011a0e:	468a      	mov	sl, r1
30011a10:	4b1e      	ldr	r3, [pc, #120]	; (30011a8c <bbl_read_reg+0x88>)
30011a12:	681a      	ldr	r2, [r3, #0]
	return (sys_read32(CRMU_MCU_EVENT_MASK) & BIT(id));
30011a14:	2380      	movs	r3, #128	; 0x80
30011a16:	04db      	lsls	r3, r3, #19
30011a18:	401a      	ands	r2, r3
30011a1a:	4690      	mov	r8, r2
	s32_t i = 0;
	s32_t rc = -1;
	int alarm_evt;

	alarm_evt  = MCU_get_event(MCU_SPRU_ALARM_EVENT);
	if (alarm_evt != 0)
30011a1c:	d108      	bne.n	30011a30 <bbl_read_reg+0x2c>
s32_t bbl_read_reg(u32_t regAddr, u32_t *p_dat) {
30011a1e:	2603      	movs	r6, #3
	*(volatile u32_t *)addr = data;
30011a20:	4b1b      	ldr	r3, [pc, #108]	; (30011a90 <bbl_read_reg+0x8c>)
30011a22:	4699      	mov	r9, r3
30011a24:	27a0      	movs	r7, #160	; 0xa0
30011a26:	017f      	lsls	r7, r7, #5
30011a28:	4307      	orrs	r7, r0
	return *(volatile u32_t *)addr;
30011a2a:	4d1a      	ldr	r5, [pc, #104]	; (30011a94 <bbl_read_reg+0x90>)
			 & 0x00000001) == en) {
30011a2c:	2401      	movs	r4, #1
30011a2e:	e01e      	b.n	30011a6e <bbl_read_reg+0x6a>
	u32_t temp = *(volatile u32_t *)addr;
30011a30:	4a16      	ldr	r2, [pc, #88]	; (30011a8c <bbl_read_reg+0x88>)
30011a32:	6811      	ldr	r1, [r2, #0]
	*(volatile u32_t *)addr = temp | (1 << bit);
30011a34:	2380      	movs	r3, #128	; 0x80
30011a36:	04db      	lsls	r3, r3, #19
30011a38:	430b      	orrs	r3, r1
30011a3a:	6013      	str	r3, [r2, #0]
30011a3c:	e7ef      	b.n	30011a1e <bbl_read_reg+0x1a>
	u32_t temp = *(volatile u32_t *)addr;
30011a3e:	4a13      	ldr	r2, [pc, #76]	; (30011a8c <bbl_read_reg+0x88>)
30011a40:	6813      	ldr	r3, [r2, #0]
	*(volatile u32_t *)addr = temp & ~(1 << bit);
30011a42:	4915      	ldr	r1, [pc, #84]	; (30011a98 <bbl_read_reg+0x94>)
30011a44:	400b      	ands	r3, r1
30011a46:	6013      	str	r3, [r2, #0]
		spru_interface_reset();
	}
	if (alarm_evt != 0)
		MCU_enable_event(MCU_SPRU_ALARM_EVENT, 1);

	return rc;
30011a48:	e007      	b.n	30011a5a <bbl_read_reg+0x56>
	return *(volatile u32_t *)addr;
30011a4a:	4b14      	ldr	r3, [pc, #80]	; (30011a9c <bbl_read_reg+0x98>)
30011a4c:	681b      	ldr	r3, [r3, #0]
	*data = sys_read32(SPRU_BBL_RDATA);
30011a4e:	4652      	mov	r2, sl
30011a50:	6013      	str	r3, [r2, #0]
			rc = 0;
30011a52:	2000      	movs	r0, #0
	if (alarm_evt != 0)
30011a54:	4643      	mov	r3, r8
30011a56:	2b00      	cmp	r3, #0
30011a58:	d1f1      	bne.n	30011a3e <bbl_read_reg+0x3a>
}
30011a5a:	bc1c      	pop	{r2, r3, r4}
30011a5c:	4690      	mov	r8, r2
30011a5e:	4699      	mov	r9, r3
30011a60:	46a2      	mov	sl, r4
30011a62:	bdf0      	pop	{r4, r5, r6, r7, pc}
		spru_interface_reset();
30011a64:	f7ff ff74 	bl	30011950 <spru_interface_reset>
30011a68:	3e01      	subs	r6, #1
	for (i = 0; i < 3; i++) {
30011a6a:	2e00      	cmp	r6, #0
30011a6c:	d00a      	beq.n	30011a84 <bbl_read_reg+0x80>
	*(volatile u32_t *)addr = data;
30011a6e:	464b      	mov	r3, r9
30011a70:	601f      	str	r7, [r3, #0]
30011a72:	23f6      	movs	r3, #246	; 0xf6
30011a74:	33ff      	adds	r3, #255	; 0xff
	return *(volatile u32_t *)addr;
30011a76:	682a      	ldr	r2, [r5, #0]
		if (((sys_read32(SPRU_BBL_STATUS) >> SPRU_BBL_STATUS__ACC_DONE)
30011a78:	4214      	tst	r4, r2
30011a7a:	d1e6      	bne.n	30011a4a <bbl_read_reg+0x46>
30011a7c:	3b01      	subs	r3, #1
	} while (num_tries--); /* Number of Tries */
30011a7e:	2b00      	cmp	r3, #0
30011a80:	d1f9      	bne.n	30011a76 <bbl_read_reg+0x72>
30011a82:	e7ef      	b.n	30011a64 <bbl_read_reg+0x60>
	s32_t rc = -1;
30011a84:	2001      	movs	r0, #1
30011a86:	4240      	negs	r0, r0
30011a88:	e7e4      	b.n	30011a54 <bbl_read_reg+0x50>
30011a8a:	46c0      	nop			; (mov r8, r8)
30011a8c:	30024064 	.word	0x30024064
30011a90:	30026004 	.word	0x30026004
30011a94:	30026008 	.word	0x30026008
30011a98:	fbffffff 	.word	0xfbffffff
30011a9c:	3002600c 	.word	0x3002600c

30011aa0 <MCU_bbl_access_ok>:
 */
s32_t MCU_bbl_access_ok(void)
{
	CITADEL_PM_ISR_ARGS_s *pm_args = CRMU_GET_PM_ISR_ARGS();

	if (!pm_args->bbl_access_ok)
30011aa0:	4b02      	ldr	r3, [pc, #8]	; (30011aac <MCU_bbl_access_ok+0xc>)
30011aa2:	69d8      	ldr	r0, [r3, #28]
30011aa4:	4243      	negs	r3, r0
30011aa6:	4158      	adcs	r0, r3
30011aa8:	4240      	negs	r0, r0
		return -1;

	return 0;
}
30011aaa:	4770      	bx	lr
30011aac:	30010000 	.word	0x30010000

30011ab0 <spru_reg_read>:
 * @param addr
 *
 * @return result
 */
u32_t spru_reg_read(u32_t addr)
{
30011ab0:	b500      	push	{lr}
30011ab2:	b083      	sub	sp, #12
	u32_t regval = 0;
30011ab4:	2300      	movs	r3, #0
30011ab6:	9301      	str	r3, [sp, #4]

	bbl_read_reg(addr, &regval);
30011ab8:	a901      	add	r1, sp, #4
30011aba:	f7ff ffa3 	bl	30011a04 <bbl_read_reg>

	return regval;
}
30011abe:	9801      	ldr	r0, [sp, #4]
30011ac0:	b003      	add	sp, #12
30011ac2:	bd00      	pop	{pc}

30011ac4 <spru_reg_write>:
 * @param data
 *
 * @return result
 */
u32_t spru_reg_write(u32_t addr, u32_t data)
{
30011ac4:	b510      	push	{r4, lr}
	bbl_write_reg(addr, data);
30011ac6:	f7ff ff55 	bl	30011974 <bbl_write_reg>

	return 0;
}
30011aca:	2000      	movs	r0, #0
30011acc:	bd10      	pop	{r4, pc}

30011ace <MCU_setup_tamper>:
 * @param op
 *
 * @return none
 */
void MCU_setup_tamper(MPROC_LOW_POWER_OP_e op)
{
30011ace:	b510      	push	{r4, lr}
	if (op == MPROC_ENTER_LP) {
30011ad0:	2801      	cmp	r0, #1
30011ad2:	d006      	beq.n	30011ae2 <MCU_setup_tamper+0x14>
	u32_t temp = *(volatile u32_t *)addr;
30011ad4:	4a08      	ldr	r2, [pc, #32]	; (30011af8 <MCU_setup_tamper+0x2a>)
30011ad6:	6811      	ldr	r1, [r2, #0]
	*(volatile u32_t *)addr = temp | (1 << bit);
30011ad8:	2380      	movs	r3, #128	; 0x80
30011ada:	04db      	lsls	r3, r3, #19
30011adc:	430b      	orrs	r3, r1
30011ade:	6013      	str	r3, [r2, #0]
		MCU_enable_event(MCU_SPRU_ALARM_EVENT, 1);
		spru_reg_write(BBL_INTERRUPT_clr, 0xfc);
	} else {
		MCU_enable_event(MCU_SPRU_ALARM_EVENT, 0);
	}
}
30011ae0:	bd10      	pop	{r4, pc}
	u32_t temp = *(volatile u32_t *)addr;
30011ae2:	4a05      	ldr	r2, [pc, #20]	; (30011af8 <MCU_setup_tamper+0x2a>)
30011ae4:	6813      	ldr	r3, [r2, #0]
	*(volatile u32_t *)addr = temp & ~(1 << bit);
30011ae6:	4905      	ldr	r1, [pc, #20]	; (30011afc <MCU_setup_tamper+0x2e>)
30011ae8:	400b      	ands	r3, r1
30011aea:	6013      	str	r3, [r2, #0]
	bbl_write_reg(addr, data);
30011aec:	21fc      	movs	r1, #252	; 0xfc
30011aee:	3017      	adds	r0, #23
30011af0:	f7ff ff40 	bl	30011974 <bbl_write_reg>
30011af4:	e7f4      	b.n	30011ae0 <MCU_setup_tamper+0x12>
30011af6:	46c0      	nop			; (mov r8, r8)
30011af8:	30024064 	.word	0x30024064
30011afc:	fbffffff 	.word	0xfbffffff

30011b00 <MCU_setup_rtc>:
 * @param op
 *
 * @return none
 */
void MCU_setup_rtc(MPROC_LOW_POWER_OP_e op)
{
30011b00:	b510      	push	{r4, lr}
30011b02:	0004      	movs	r4, r0
	if (MCU_bbl_access_ok() < 0)
30011b04:	f7ff ffcc 	bl	30011aa0 <MCU_bbl_access_ok>
30011b08:	2800      	cmp	r0, #0
30011b0a:	db0f      	blt.n	30011b2c <MCU_setup_rtc+0x2c>
		return;

	if (op == MPROC_ENTER_LP) {
30011b0c:	2c01      	cmp	r4, #1
30011b0e:	d00e      	beq.n	30011b2e <MCU_setup_rtc+0x2e>
	u32_t temp = *(volatile u32_t *)addr;
30011b10:	4a0a      	ldr	r2, [pc, #40]	; (30011b3c <MCU_setup_rtc+0x3c>)
30011b12:	6811      	ldr	r1, [r2, #0]
	*(volatile u32_t *)addr = temp | (1 << bit);
30011b14:	2380      	movs	r3, #128	; 0x80
30011b16:	055b      	lsls	r3, r3, #21
30011b18:	430b      	orrs	r3, r1
30011b1a:	6013      	str	r3, [r2, #0]
	bbl_write_reg(addr, data);
30011b1c:	2101      	movs	r1, #1
30011b1e:	2018      	movs	r0, #24
30011b20:	f7ff ff28 	bl	30011974 <bbl_write_reg>
	*(volatile u32_t *)addr = data;
30011b24:	2280      	movs	r2, #128	; 0x80
30011b26:	0552      	lsls	r2, r2, #21
30011b28:	4b05      	ldr	r3, [pc, #20]	; (30011b40 <MCU_setup_rtc+0x40>)
30011b2a:	601a      	str	r2, [r3, #0]
		/* disable rtc intr now */
		MCU_enable_event(MCU_SPRU_RTC_PERIODIC_EVENT, 0);
	}
	spru_reg_write(BBL_INTERRUPT_clr, BIT(BBL_INTERRUPT_clr__bbl_period_intr_clr));
	MCU_clear_event(MCU_SPRU_RTC_PERIODIC_EVENT);
}
30011b2c:	bd10      	pop	{r4, pc}
	u32_t temp = *(volatile u32_t *)addr;
30011b2e:	4a03      	ldr	r2, [pc, #12]	; (30011b3c <MCU_setup_rtc+0x3c>)
30011b30:	6813      	ldr	r3, [r2, #0]
	*(volatile u32_t *)addr = temp & ~(1 << bit);
30011b32:	4904      	ldr	r1, [pc, #16]	; (30011b44 <MCU_setup_rtc+0x44>)
30011b34:	400b      	ands	r3, r1
30011b36:	6013      	str	r3, [r2, #0]
30011b38:	e7f0      	b.n	30011b1c <MCU_setup_rtc+0x1c>
30011b3a:	46c0      	nop			; (mov r8, r8)
30011b3c:	30024064 	.word	0x30024064
30011b40:	30024060 	.word	0x30024060
30011b44:	efffffff 	.word	0xefffffff

30011b48 <MCU_setup_wakeup_src>:
 * @param op
 *
 * @return none
 */
void MCU_setup_wakeup_src(MPROC_LOW_POWER_OP_e op)
{
30011b48:	b510      	push	{r4, lr}
#ifdef MPROC_PM_USE_RTC_AS_WAKEUP_SRC
	CITADEL_PM_ISR_ARGS_s *pm_args = CRMU_GET_PM_ISR_ARGS();
#endif

	if (op == MPROC_ENTER_LP) { /* go to low power mode */
30011b4a:	2801      	cmp	r0, #1
30011b4c:	d00c      	beq.n	30011b68 <MCU_setup_wakeup_src+0x20>
			MCU_setup_rtc(MPROC_ENTER_LP);
		else
			MCU_setup_rtc(MPROC_EXIT_LP);
#endif
	} else { /* exit from low power mode */
		MCU_setup_aongpio(MPROC_EXIT_LP);
30011b4e:	2000      	movs	r0, #0
30011b50:	f7ff fe8a 	bl	30011868 <MCU_setup_aongpio>

		/* Restore USB wake-Up Sources if any */
		MCU_setup_usb(MPROC_EXIT_LP);
30011b54:	2000      	movs	r0, #0
30011b56:	f7ff fed3 	bl	30011900 <MCU_setup_usb>

#ifdef MPROC_PM_USE_TAMPER_AS_WAKEUP_SRC
		MCU_setup_tamper(MPROC_EXIT_LP);
30011b5a:	2000      	movs	r0, #0
30011b5c:	f7ff ffb7 	bl	30011ace <MCU_setup_tamper>
#endif

#ifdef MPROC_PM_USE_RTC_AS_WAKEUP_SRC
		MCU_setup_rtc(MPROC_EXIT_LP);
30011b60:	2000      	movs	r0, #0
30011b62:	f7ff ffcd 	bl	30011b00 <MCU_setup_rtc>
#endif
	}
}
30011b66:	bd10      	pop	{r4, pc}
		MCU_setup_aongpio(MPROC_ENTER_LP);
30011b68:	f7ff fe7e 	bl	30011868 <MCU_setup_aongpio>
		MCU_setup_usb(MPROC_ENTER_LP);
30011b6c:	2001      	movs	r0, #1
30011b6e:	f7ff fec7 	bl	30011900 <MCU_setup_usb>
		MCU_setup_tamper(MPROC_ENTER_LP);
30011b72:	2001      	movs	r0, #1
30011b74:	f7ff ffab 	bl	30011ace <MCU_setup_tamper>
		if (pm_args->seconds_to_wakeup)
30011b78:	4b05      	ldr	r3, [pc, #20]	; (30011b90 <MCU_setup_wakeup_src+0x48>)
30011b7a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
30011b7c:	2b00      	cmp	r3, #0
30011b7e:	d003      	beq.n	30011b88 <MCU_setup_wakeup_src+0x40>
			MCU_setup_rtc(MPROC_ENTER_LP);
30011b80:	2001      	movs	r0, #1
30011b82:	f7ff ffbd 	bl	30011b00 <MCU_setup_rtc>
30011b86:	e7ee      	b.n	30011b66 <MCU_setup_wakeup_src+0x1e>
			MCU_setup_rtc(MPROC_EXIT_LP);
30011b88:	2000      	movs	r0, #0
30011b8a:	f7ff ffb9 	bl	30011b00 <MCU_setup_rtc>
30011b8e:	e7ea      	b.n	30011b66 <MCU_setup_wakeup_src+0x1e>
30011b90:	30010000 	.word	0x30010000

30011b94 <user_wakeup_handler>:
 * @param None
 *
 * @return TODO (Ask CRMU ROM devs): What does return value of 1 mean?
 */
s32_t user_wakeup_handler(void)
{
30011b94:	b5f0      	push	{r4, r5, r6, r7, lr}
30011b96:	46de      	mov	lr, fp
30011b98:	4657      	mov	r7, sl
30011b9a:	464e      	mov	r6, r9
30011b9c:	4645      	mov	r5, r8
30011b9e:	b5e0      	push	{r5, r6, r7, lr}
30011ba0:	b087      	sub	sp, #28
	s32_t ret = 0;
	u32_t irq_handled = 0;
	CITADEL_PM_ISR_ARGS_s *pm_args = CRMU_GET_PM_ISR_ARGS();
	MPROC_PM_MODE_e cur_pm_state = pm_args->tgt_pm_state;
30011ba2:	4b85      	ldr	r3, [pc, #532]	; (30011db8 <user_wakeup_handler+0x224>)
30011ba4:	791d      	ldrb	r5, [r3, #4]
#ifdef MPROC_PM__ADV_S_POWER_OFF_PLL
	MPROC_PM_MODE_e prv_pm_state = pm_args->prv_pm_state;
30011ba6:	795a      	ldrb	r2, [r3, #5]
30011ba8:	4690      	mov	r8, r2
#else
	MPROC_PM_MODE_e prv_pm_state = MPROC_PM_MODE__END;
#endif

	u32_t aon_gpio_wakeup = pm_args->aon_gpio_settings.wakeup_src;
30011baa:	689f      	ldr	r7, [r3, #8]
	u32_t aon_gpio_mstat = 0, valid_aon_gpio_intr = 0;

	u32_t usb_wakeup = pm_args->usb_settings.wakeup_src;
30011bac:	699e      	ldr	r6, [r3, #24]
	u32_t usb_status = 0, valid_usb_intr = 0;

#ifdef MPROC_PM_USE_RTC_AS_WAKEUP_SRC
	u32_t rtc_wakeup = pm_args->seconds_to_wakeup;
30011bae:	6a9a      	ldr	r2, [r3, #40]	; 0x28
30011bb0:	4691      	mov	r9, r2
	u32_t rtc_left_time = pm_args->seconds_left;
30011bb2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
30011bb4:	469a      	mov	sl, r3
	return *(volatile u32_t *)addr;
30011bb6:	4b81      	ldr	r3, [pc, #516]	; (30011dbc <user_wakeup_handler+0x228>)
30011bb8:	681b      	ldr	r3, [r3, #0]
30011bba:	469b      	mov	fp, r3
30011bbc:	4b80      	ldr	r3, [pc, #512]	; (30011dc0 <user_wakeup_handler+0x22c>)
30011bbe:	681c      	ldr	r4, [r3, #0]
	/* Put some default wake up Code 1 */
	u32_t wakeup_msg_code1 = MAILBOX_CODE1__WAKEUP_TEST;

	MCU_SET_STATE_IN_WAKEUP_ENTRY_C();

	MCU_memset((void *)&wakeup_code, 0, sizeof(MPROC_PM_WAKEUP_CODE_s));
30011bc0:	2210      	movs	r2, #16
30011bc2:	2100      	movs	r1, #0
30011bc4:	a802      	add	r0, sp, #8
30011bc6:	f7ff fd37 	bl	30011638 <MCU_memset>

	/* AON GPIO intr from valid src */
	if (irq_status & BIT(MCU_AON_GPIO_INTR)) {
30011bca:	465b      	mov	r3, fp
30011bcc:	075b      	lsls	r3, r3, #29
30011bce:	d553      	bpl.n	30011c78 <user_wakeup_handler+0xe4>
30011bd0:	4b7c      	ldr	r3, [pc, #496]	; (30011dc4 <user_wakeup_handler+0x230>)
30011bd2:	681b      	ldr	r3, [r3, #0]
		irq_handled = 1;
		/* TODO: This mask is for 6 AON GPIOs,
		 * should it be changed to 0x7ff
		 * since we have 11 AON GPIOs?
		 */
		aon_gpio_mstat = sys_read32(GP_INT_MSTAT) & AON_GPIO_INT_MASK;
30011bd4:	055b      	lsls	r3, r3, #21
30011bd6:	0d5b      	lsrs	r3, r3, #21
30011bd8:	469b      	mov	fp, r3
#ifdef AON_GPIO_EDGE_SENSITIVE_WORKAROUND
		/* this must be called before clearing any aon_gpio interrupt */
		valid_aon_gpio_intr =
		MCU_get_valid_aon_gpio_wakeup_interrupt(aon_gpio_wakeup);
#else
		valid_aon_gpio_intr = aon_gpio_mstat & aon_gpio_wakeup;
30011bda:	403b      	ands	r3, r7
#endif
		/*In RUN mode*/
		if (cur_pm_state < MPROC_PM_MODE__SLEEP) {
30011bdc:	2d03      	cmp	r5, #3
30011bde:	d941      	bls.n	30011c64 <user_wakeup_handler+0xd0>
			goto OK_exit;
		} else /*In LP mode*/ {
			/* 1. First check none-wakeup AON_GPIOs
			 * interrupt, don't return
			 */
			if (aon_gpio_mstat & ~aon_gpio_wakeup) {
30011be0:	43fa      	mvns	r2, r7
30011be2:	4659      	mov	r1, fp
30011be4:	420a      	tst	r2, r1
30011be6:	d003      	beq.n	30011bf0 <user_wakeup_handler+0x5c>
	*(volatile u32_t *)addr = data;
30011be8:	4977      	ldr	r1, [pc, #476]	; (30011dc8 <user_wakeup_handler+0x234>)
30011bea:	600a      	str	r2, [r1, #0]
30011bec:	4a77      	ldr	r2, [pc, #476]	; (30011dcc <user_wakeup_handler+0x238>)
30011bee:	6017      	str	r7, [r2, #0]
				sys_write32(aon_gpio_wakeup, GP_INT_MSK);
#endif
			}

			/* 2. Secondly check and clear wakeup AON_GPIOs interrupt */
			if (aon_gpio_mstat & aon_gpio_wakeup) {
30011bf0:	2b00      	cmp	r3, #0
30011bf2:	d041      	beq.n	30011c78 <user_wakeup_handler+0xe4>
30011bf4:	4a74      	ldr	r2, [pc, #464]	; (30011dc8 <user_wakeup_handler+0x234>)
30011bf6:	6017      	str	r7, [r2, #0]
			/* Last check valid wakeup AON_GPIOs interrupt */
			if (valid_aon_gpio_intr) {
				if ((MCU_WAKEUP_SOURCE & BIT(MCU_NVIC_AON_GPIO_INTR))) {
					u32_t i = 0;
					MCU_SET_STATE_IN_WAKEUP_ENTRY_C();
					wakeup_code.wakeup_src        = ws_aon_gpio;
30011bf8:	2202      	movs	r2, #2
30011bfa:	a902      	add	r1, sp, #8
30011bfc:	700a      	strb	r2, [r1, #0]
					wakeup_code.info.aon_gpio.src = valid_aon_gpio_intr;
30011bfe:	9303      	str	r3, [sp, #12]
					/* Pick the first AON GPIO that has caused this wake-up
					 * and prepare code1 of the mailbox message.
					 */
					for(i = 0; i < MPROC_AON_GPIO_END; i++) {
						if(valid_aon_gpio_intr & BIT(i)) {
30011c00:	07da      	lsls	r2, r3, #31
30011c02:	d500      	bpl.n	30011c06 <user_wakeup_handler+0x72>
30011c04:	e0a9      	b.n	30011d5a <user_wakeup_handler+0x1c6>
30011c06:	2401      	movs	r4, #1
30011c08:	2101      	movs	r1, #1
30011c0a:	001a      	movs	r2, r3
30011c0c:	40e2      	lsrs	r2, r4
30011c0e:	4211      	tst	r1, r2
30011c10:	d103      	bne.n	30011c1a <user_wakeup_handler+0x86>
					for(i = 0; i < MPROC_AON_GPIO_END; i++) {
30011c12:	3401      	adds	r4, #1
30011c14:	2c0b      	cmp	r4, #11
30011c16:	d1f8      	bne.n	30011c0a <user_wakeup_handler+0x76>
	u32_t wakeup_msg_code1 = MAILBOX_CODE1__WAKEUP_TEST;
30011c18:	4c6d      	ldr	r4, [pc, #436]	; (30011dd0 <user_wakeup_handler+0x23c>)
wakeup:
	/* TODO: Should this include DRIPS too ? */
	/* Totally disable rtc and tamper to avoid
	 * conflict with SBL
	 */
	if (cur_pm_state == MPROC_PM_MODE__DEEPSLEEP
30011c1a:	1f6b      	subs	r3, r5, #5
30011c1c:	2b01      	cmp	r3, #1
30011c1e:	d800      	bhi.n	30011c22 <user_wakeup_handler+0x8e>
30011c20:	e09d      	b.n	30011d5e <user_wakeup_handler+0x1ca>
		}
#endif
	}

	/* Copy back wakeup details */
	MCU_memcpy((void *)&pm_args->wakeup, (void *)&wakeup_code,
30011c22:	2210      	movs	r2, #16
30011c24:	a902      	add	r1, sp, #8
30011c26:	486b      	ldr	r0, [pc, #428]	; (30011dd4 <user_wakeup_handler+0x240>)
30011c28:	f7ff fd0f 	bl	3001164a <MCU_memcpy>
			   sizeof(MPROC_PM_WAKEUP_CODE_s));

	/* Do wakeup */
	ret = MCU_SoC_Wakeup_Handler(cur_pm_state, prv_pm_state, wakeup_msg_code0, wakeup_msg_code1);
30011c2c:	0023      	movs	r3, r4
30011c2e:	4a6a      	ldr	r2, [pc, #424]	; (30011dd8 <user_wakeup_handler+0x244>)
30011c30:	4641      	mov	r1, r8
30011c32:	0028      	movs	r0, r5
30011c34:	f7fe ff64 	bl	30010b00 <MCU_SoC_Wakeup_Handler>
	MCU_SET_STATE_IN_WAKEUP_ENTRY_C();

	/* Clear mailbox values, this will trigger
	 * a mbox interrupt again
	 */
	if (!ret) {
30011c38:	2800      	cmp	r0, #0
30011c3a:	d108      	bne.n	30011c4e <user_wakeup_handler+0xba>
		 * falling edge intr
		 * will reset A7 again.
		 *
		 * Can't we make this rising edge only?
		 */
		if (cur_pm_state > MPROC_PM_MODE__SLEEP)
30011c3c:	2d04      	cmp	r5, #4
30011c3e:	d902      	bls.n	30011c46 <user_wakeup_handler+0xb2>
			pm_args->tgt_pm_state = MPROC_PM_MODE__END;
30011c40:	2207      	movs	r2, #7
30011c42:	4b5d      	ldr	r3, [pc, #372]	; (30011db8 <user_wakeup_handler+0x224>)
30011c44:	711a      	strb	r2, [r3, #4]

		MCU_send_msg_to_mcu(MAILBOX_CODE0__NOTHING,
30011c46:	2100      	movs	r1, #0
30011c48:	2000      	movs	r0, #0
30011c4a:	f7ff fde3 	bl	30011814 <MCU_send_msg_to_mcu>
		MAILBOX_CODE1__NOTHING);
	}

	if (cur_pm_state < MPROC_PM_MODE__DEEPSLEEP)
30011c4e:	2d05      	cmp	r5, #5
30011c50:	d800      	bhi.n	30011c54 <user_wakeup_handler+0xc0>
30011c52:	e0ad      	b.n	30011db0 <user_wakeup_handler+0x21c>
	return 0;

OK_exit: /* NO VALID WAKEUP interrupt occurs, direct return */
	MCU_SET_STATE_IN_WAKEUP_ENTRY_C();
	return 0;
}
30011c54:	2000      	movs	r0, #0
30011c56:	b007      	add	sp, #28
30011c58:	bc3c      	pop	{r2, r3, r4, r5}
30011c5a:	4690      	mov	r8, r2
30011c5c:	4699      	mov	r9, r3
30011c5e:	46a2      	mov	sl, r4
30011c60:	46ab      	mov	fp, r5
30011c62:	bdf0      	pop	{r4, r5, r6, r7, pc}
30011c64:	4b58      	ldr	r3, [pc, #352]	; (30011dc8 <user_wakeup_handler+0x234>)
30011c66:	465a      	mov	r2, fp
30011c68:	601a      	str	r2, [r3, #0]
			MCU_SYNC();
30011c6a:	f7ff fcb7 	bl	300115dc <MCU_SYNC>
			MCU_send_msg_to_mproc(aon_gpio_mstat,
30011c6e:	495b      	ldr	r1, [pc, #364]	; (30011ddc <user_wakeup_handler+0x248>)
30011c70:	4658      	mov	r0, fp
30011c72:	f7ff fdc5 	bl	30011800 <MCU_send_msg_to_mproc>
			goto OK_exit;
30011c76:	e7ed      	b.n	30011c54 <user_wakeup_handler+0xc0>
	|| (event_status & BIT(MCU_USBPHY1_FILTER_EVENT))) {
30011c78:	23f0      	movs	r3, #240	; 0xf0
30011c7a:	021b      	lsls	r3, r3, #8
	if((event_status & BIT(MCU_USBPHY0_WAKE_EVENT))
30011c7c:	421c      	tst	r4, r3
30011c7e:	d02b      	beq.n	30011cd8 <user_wakeup_handler+0x144>
		if(event_status & BIT(MCU_USBPHY0_WAKE_EVENT))
30011c80:	04e3      	lsls	r3, r4, #19
30011c82:	0fdb      	lsrs	r3, r3, #31
		if(event_status & BIT(MCU_USBPHY0_FILTER_EVENT))
30011c84:	04a2      	lsls	r2, r4, #18
30011c86:	d501      	bpl.n	30011c8c <user_wakeup_handler+0xf8>
			usb_status |= BIT(MPROC_USB0_FLTR);
30011c88:	2202      	movs	r2, #2
30011c8a:	4313      	orrs	r3, r2
		if(event_status & BIT(MCU_USBPHY1_WAKE_EVENT))
30011c8c:	0462      	lsls	r2, r4, #17
30011c8e:	d501      	bpl.n	30011c94 <user_wakeup_handler+0x100>
			usb_status |= BIT(MPROC_USB1_WAKE);
30011c90:	2204      	movs	r2, #4
30011c92:	4313      	orrs	r3, r2
		if(event_status & BIT(MCU_USBPHY1_FILTER_EVENT))
30011c94:	0422      	lsls	r2, r4, #16
30011c96:	d501      	bpl.n	30011c9c <user_wakeup_handler+0x108>
			usb_status |= BIT(MPROC_USB1_FLTR);
30011c98:	2208      	movs	r2, #8
30011c9a:	4313      	orrs	r3, r2
		valid_usb_intr = usb_wakeup & usb_status;
30011c9c:	401e      	ands	r6, r3
		if (cur_pm_state < MPROC_PM_MODE__SLEEP) {
30011c9e:	2d03      	cmp	r5, #3
30011ca0:	d912      	bls.n	30011cc8 <user_wakeup_handler+0x134>
			if (valid_usb_intr) {
30011ca2:	2e00      	cmp	r6, #0
30011ca4:	d018      	beq.n	30011cd8 <user_wakeup_handler+0x144>
					wakeup_code.wakeup_src        = ws_usb;
30011ca6:	230f      	movs	r3, #15
30011ca8:	aa02      	add	r2, sp, #8
30011caa:	7013      	strb	r3, [r2, #0]
					wakeup_code.info.usbno.usbno = valid_usb_intr;
30011cac:	9603      	str	r6, [sp, #12]
						if(valid_usb_intr & BIT(i)) {
30011cae:	07f3      	lsls	r3, r6, #31
30011cb0:	d40f      	bmi.n	30011cd2 <user_wakeup_handler+0x13e>
30011cb2:	2401      	movs	r4, #1
30011cb4:	2201      	movs	r2, #1
30011cb6:	0033      	movs	r3, r6
30011cb8:	40e3      	lsrs	r3, r4
30011cba:	421a      	tst	r2, r3
30011cbc:	d10a      	bne.n	30011cd4 <user_wakeup_handler+0x140>
					for(i = 0; i < MPROC_USB_END; i++) {
30011cbe:	3401      	adds	r4, #1
30011cc0:	2c04      	cmp	r4, #4
30011cc2:	d1f8      	bne.n	30011cb6 <user_wakeup_handler+0x122>
	u32_t wakeup_msg_code1 = MAILBOX_CODE1__WAKEUP_TEST;
30011cc4:	4c42      	ldr	r4, [pc, #264]	; (30011dd0 <user_wakeup_handler+0x23c>)
30011cc6:	e7a8      	b.n	30011c1a <user_wakeup_handler+0x86>
			MCU_send_msg_to_mproc(MAILBOX_CODE0__USB_INTR_IN_RUN,
30011cc8:	4945      	ldr	r1, [pc, #276]	; (30011de0 <user_wakeup_handler+0x24c>)
30011cca:	4846      	ldr	r0, [pc, #280]	; (30011de4 <user_wakeup_handler+0x250>)
30011ccc:	f7ff fd98 	bl	30011800 <MCU_send_msg_to_mproc>
			goto OK_exit;
30011cd0:	e7c0      	b.n	30011c54 <user_wakeup_handler+0xc0>
					for(i = 0; i < MPROC_USB_END; i++) {
30011cd2:	2400      	movs	r4, #0
							wakeup_msg_code1 = MAILBOX_CODE1__WAKEUP_USB0_WAKE + i;
30011cd4:	340c      	adds	r4, #12
							break;
30011cd6:	e7a0      	b.n	30011c1a <user_wakeup_handler+0x86>
	if (event_status & BIT(MCU_SPRU_ALARM_EVENT)) {
30011cd8:	0163      	lsls	r3, r4, #5
30011cda:	d41e      	bmi.n	30011d1a <user_wakeup_handler+0x186>
	if (event_status & BIT(MCU_SPRU_RTC_PERIODIC_EVENT)) {
30011cdc:	00e3      	lsls	r3, r4, #3
30011cde:	d5b9      	bpl.n	30011c54 <user_wakeup_handler+0xc0>
		if (spru_reg_read(BBL_INTERRUPT_stat)
30011ce0:	2014      	movs	r0, #20
30011ce2:	f7ff fee5 	bl	30011ab0 <spru_reg_read>
30011ce6:	07c3      	lsls	r3, r0, #31
30011ce8:	d432      	bmi.n	30011d50 <user_wakeup_handler+0x1bc>
		MCU_clear_event(MCU_SPRU_RTC_PERIODIC_EVENT);
30011cea:	201c      	movs	r0, #28
30011cec:	f7ff fd80 	bl	300117f0 <MCU_clear_event>
		if (cur_pm_state >= MPROC_PM_MODE__SLEEP
30011cf0:	1f2b      	subs	r3, r5, #4
30011cf2:	2b02      	cmp	r3, #2
30011cf4:	d8ae      	bhi.n	30011c54 <user_wakeup_handler+0xc0>
			if (rtc_wakeup) {
30011cf6:	464b      	mov	r3, r9
30011cf8:	2b00      	cmp	r3, #0
30011cfa:	d0ab      	beq.n	30011c54 <user_wakeup_handler+0xc0>
				rtc_left_time--;
30011cfc:	4653      	mov	r3, sl
30011cfe:	3b01      	subs	r3, #1
				pm_args->seconds_left = rtc_left_time;
30011d00:	4a2d      	ldr	r2, [pc, #180]	; (30011db8 <user_wakeup_handler+0x224>)
30011d02:	62d3      	str	r3, [r2, #44]	; 0x2c
				if (!rtc_left_time) {
30011d04:	2b00      	cmp	r3, #0
30011d06:	d1a5      	bne.n	30011c54 <user_wakeup_handler+0xc0>
					wakeup_code.wakeup_src = ws_rtc;
30011d08:	331b      	adds	r3, #27
30011d0a:	aa02      	add	r2, sp, #8
30011d0c:	7013      	strb	r3, [r2, #0]
					MCU_enable_event(MCU_SPRU_RTC_PERIODIC_EVENT, 0);
30011d0e:	2100      	movs	r1, #0
30011d10:	201c      	movs	r0, #28
30011d12:	f7ff fd53 	bl	300117bc <MCU_enable_event>
					wakeup_msg_code1 = MAILBOX_CODE1__WAKEUP_RTC;
30011d16:	2413      	movs	r4, #19
					goto wakeup;
30011d18:	e77f      	b.n	30011c1a <user_wakeup_handler+0x86>
		tamper_timestamp   = spru_reg_read(BBL_TAMPER_TIMESTAMP);
30011d1a:	2020      	movs	r0, #32
30011d1c:	f7ff fec8 	bl	30011ab0 <spru_reg_read>
30011d20:	9001      	str	r0, [sp, #4]
		tamper_src_state   = spru_reg_read(BBL_TAMPER_SRC_STAT);
30011d22:	2028      	movs	r0, #40	; 0x28
30011d24:	f7ff fec4 	bl	30011ab0 <spru_reg_read>
30011d28:	0006      	movs	r6, r0
		tamper_src_state_1 = spru_reg_read(BBL_TAMPER_SRC_STAT_1);
30011d2a:	2034      	movs	r0, #52	; 0x34
30011d2c:	f7ff fec0 	bl	30011ab0 <spru_reg_read>
30011d30:	0007      	movs	r7, r0
		MCU_clear_event(MCU_SPRU_ALARM_EVENT);
30011d32:	201a      	movs	r0, #26
30011d34:	f7ff fd5c 	bl	300117f0 <MCU_clear_event>
		if (tamper_src_state || tamper_src_state_1) {
30011d38:	0033      	movs	r3, r6
30011d3a:	433b      	orrs	r3, r7
30011d3c:	d0ce      	beq.n	30011cdc <user_wakeup_handler+0x148>
			wakeup_code.wakeup_src       = ws_tamper;
30011d3e:	231a      	movs	r3, #26
30011d40:	aa02      	add	r2, sp, #8
30011d42:	7013      	strb	r3, [r2, #0]
			wakeup_code.info.tamper.time = tamper_timestamp;
30011d44:	9b01      	ldr	r3, [sp, #4]
30011d46:	9303      	str	r3, [sp, #12]
			wakeup_code.info.tamper.src  = tamper_src_state;
30011d48:	9604      	str	r6, [sp, #16]
			wakeup_code.info.tamper.src1 = tamper_src_state_1;
30011d4a:	9705      	str	r7, [sp, #20]
			wakeup_msg_code1 = MAILBOX_CODE1__WAKEUP_TAMPER;
30011d4c:	2411      	movs	r4, #17
			goto wakeup;
30011d4e:	e764      	b.n	30011c1a <user_wakeup_handler+0x86>
			spru_reg_write(BBL_INTERRUPT_clr,
30011d50:	2101      	movs	r1, #1
30011d52:	2018      	movs	r0, #24
30011d54:	f7ff feb6 	bl	30011ac4 <spru_reg_write>
30011d58:	e7c7      	b.n	30011cea <user_wakeup_handler+0x156>
					for(i = 0; i < MPROC_AON_GPIO_END; i++) {
30011d5a:	2400      	movs	r4, #0
30011d5c:	e75d      	b.n	30011c1a <user_wakeup_handler+0x86>
			spru_reg_write(BBL_INTERRUPT_clr, BIT(BBL_INTERRUPT_clr__bbl_period_intr_clr));
30011d5e:	2101      	movs	r1, #1
30011d60:	2018      	movs	r0, #24
30011d62:	f7ff feaf 	bl	30011ac4 <spru_reg_write>
			MCU_enable_event(MCU_SPRU_RTC_PERIODIC_EVENT, 0);
30011d66:	2100      	movs	r1, #0
30011d68:	201c      	movs	r0, #28
30011d6a:	f7ff fd27 	bl	300117bc <MCU_enable_event>
			MCU_clear_event(MCU_SPRU_RTC_PERIODIC_EVENT);
30011d6e:	201c      	movs	r0, #28
30011d70:	f7ff fd3e 	bl	300117f0 <MCU_clear_event>
			spru_reg_write(BBL_INTERRUPT_EN,		0x0);
30011d74:	2100      	movs	r1, #0
30011d76:	2010      	movs	r0, #16
30011d78:	f7ff fea4 	bl	30011ac4 <spru_reg_write>
			spru_reg_write(BBL_TAMPER_SRC_ENABLE,	0x0);
30011d7c:	2100      	movs	r1, #0
30011d7e:	2024      	movs	r0, #36	; 0x24
30011d80:	f7ff fea0 	bl	30011ac4 <spru_reg_write>
			spru_reg_write(BBL_TAMPER_SRC_ENABLE_1, 0x0);
30011d84:	2100      	movs	r1, #0
30011d86:	2030      	movs	r0, #48	; 0x30
30011d88:	f7ff fe9c 	bl	30011ac4 <spru_reg_write>
			spru_reg_write(BBL_TAMPER_SRC_CLEAR,	0xffffffff);
30011d8c:	2601      	movs	r6, #1
30011d8e:	4276      	negs	r6, r6
30011d90:	0031      	movs	r1, r6
30011d92:	202c      	movs	r0, #44	; 0x2c
30011d94:	f7ff fe96 	bl	30011ac4 <spru_reg_write>
			spru_reg_write(BBL_TAMPER_SRC_CLEAR_1,	0xffffffff);
30011d98:	0031      	movs	r1, r6
30011d9a:	2038      	movs	r0, #56	; 0x38
30011d9c:	f7ff fe92 	bl	30011ac4 <spru_reg_write>
			MCU_enable_event(MCU_SPRU_ALARM_EVENT,	0);
30011da0:	2100      	movs	r1, #0
30011da2:	201a      	movs	r0, #26
30011da4:	f7ff fd0a 	bl	300117bc <MCU_enable_event>
			MCU_clear_event(MCU_SPRU_ALARM_EVENT);
30011da8:	201a      	movs	r0, #26
30011daa:	f7ff fd21 	bl	300117f0 <MCU_clear_event>
30011dae:	e738      	b.n	30011c22 <user_wakeup_handler+0x8e>
		MCU_setup_wakeup_src(MPROC_EXIT_LP);
30011db0:	2000      	movs	r0, #0
30011db2:	f7ff fec9 	bl	30011b48 <MCU_setup_wakeup_src>
30011db6:	e74d      	b.n	30011c54 <user_wakeup_handler+0xc0>
30011db8:	30010000 	.word	0x30010000
30011dbc:	30024050 	.word	0x30024050
30011dc0:	3002405c 	.word	0x3002405c
30011dc4:	30024820 	.word	0x30024820
30011dc8:	30024824 	.word	0x30024824
30011dcc:	30024818 	.word	0x30024818
30011dd0:	44332211 	.word	0x44332211
30011dd4:	30010040 	.word	0x30010040
30011dd8:	11223344 	.word	0x11223344
30011ddc:	44002200 	.word	0x44002200
30011de0:	77003300 	.word	0x77003300
30011de4:	22005500 	.word	0x22005500
