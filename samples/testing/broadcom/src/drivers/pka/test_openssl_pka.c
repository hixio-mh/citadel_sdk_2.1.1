/******************************************************************************
 *  Copyright (C) 2018 Broadcom. The term "Broadcom" refers to Broadcom Limited
 *  and/or its subsidiaries.
 *
 *  This program is the proprietary software of Broadcom and/or its licensors,
 *  and may only be used, duplicated, modified or distributed pursuant to the
 *  terms and conditions of a separate, written license agreement executed
 *  between you and Broadcom (an "Authorized License").  Except as set forth in
 *  an Authorized License, Broadcom grants no license (express or implied),
 *  right to use, or waiver of any kind with respect to the Software, and
 *  Broadcom expressly reserves all rights in and to the Software and all
 *  intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE,
 *  THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD
 *  IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
 *
 *  Except as expressly set forth in the Authorized License,
 *
 *  1.     This program, including its structure, sequence and organization,
 *  constitutes the valuable trade secrets of Broadcom, and you shall use all
 *  reasonable efforts to protect the confidentiality thereof, and to use this
 *  information only in connection with your use of Broadcom integrated circuit
 *  products.
 *
 *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
 *  "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS
 *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH
 *  RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL
 *  IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A
 *  PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET
 *  ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE
 *  ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 *
 *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
 *  ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL,
 *  INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY
 *  RELATING TO YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
 *  HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN
 *  EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1,
 *  WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY
 *  FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
 ******************************************************************************/
#include <board.h>
#include <device.h>
#include <misc/printk.h>
#include <ztest.h>
#include <test.h>
#include <crypto/crypto.h>
#include <crypto/crypto_smau.h>
#include <crypto/crypto_rng.h>
#include <broadcom/dma.h>
#include <pka/crypto_pka.h>
#include <pka/crypto_pka_util.h>
#include <crypto/crypto_symmetric.h>
#include <clock_a7.h>

#ifndef PATH_TO_KEYS
#define PATH_TO_KEYS
#endif

#define SHA_512_HASH_SIZE SHA3_512_HASH_SIZE
/* SHA2-512 digest software implementation
 * Because hardware only supports SHA3-512
 */
u8_t *SHA512(const u8_t *d, size_t n, u8_t *md);
u8_t *SHA384(const u8_t *d, size_t n, u8_t *md);

static u8_t cryptoHandle[CRYPTO_LIB_HANDLE_SIZE] = {0};
static fips_rng_context rngctx;

/* Bits to words with round up */
#define BIT_TO_WORD(N)	((N + 31) / 32)

/* Object size in words */
#define WORD_SIZE(A)	(sizeof(A)/sizeof(u32_t))

static void dump_array(void *p, u32_t size, const char *name)
{
	u32_t i;

	TC_PRINT("%s\n", name ? name : "(No name)");
	TC_PRINT("===============================================\n");
	for (i = 0; i < size; i++) {
		TC_PRINT("%02x ", *((u8_t *)p + i));
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	if (size & 0xF)
		TC_PRINT("\n");
	TC_PRINT("===============================================\n");
}

static void init_crypto(void)
{
	BCM_SCAPI_STATUS ret;
	static bool crypto_init_done = false;

	if (!crypto_init_done) {
		crypto_init((crypto_lib_handle *)&cryptoHandle);
		ret = crypto_rng_init((crypto_lib_handle *)&cryptoHandle, &rngctx, 1,
			    NULL, 0, NULL, 0, NULL, 0);
		zassert_equal(ret, 0, "crypto rng initialization failed");
		crypto_init_done = true;
	}
}

/*****************************************/
/************** RSA 2K TEST **************/
/*****************************************/
#define TEST_MESSAGE_FILE	"keys/test_message.txt"
/* Modulus generated by the below command:
 * openssl rsa -in private_key.pem -noout -text | \
 *	sed -n '/modulus:/,/publicExponent:/{//!p}'  | \
 *	sed -E 's/:/ /g' | xxd -r -p  > modulus.bin
 */
#define RSA_MOD_FILE		"keys/modulus.bin"
/* Private Exponent generated by the below command:
 * openssl rsa -in private_key.pem -noout -text | \
 *	sed -n '/privateExponent:/,/prime1:/{//!p}'  | \
 *	sed -E 's/:/ /g' | xxd -r -p > priv_exp.bin
 */
#define RSA_PRIV_EXP_FILE	"keys/priv_exp.bin"
/* Signature generated by the below commands:
 * # First generate sha256 digest
 * openssl dgst -sha256 -binary -out sha256.hash test_message.txt
 * # Then sign it with pkcs padding
 * openssl rsautl -sign -pkcs -in sha256.hash -inkey private_key.pem \
 *	-out signature.bin
 */
#define RSA_SIGNATURE_FILE	"keys/signature.bin"

/* Test message */
extern uint8_t test_message;
extern uint8_t test_message_end;
__asm__ (
	"test_message:\n"
	"   .incbin \"" PATH_TO_KEYS TEST_MESSAGE_FILE "\"\n"
	"test_message_end:" /* To get the file size */
);

/* RSA 2k Modulus message */
extern uint8_t modulus_start;
extern uint8_t modulus_end;
__asm__ (
	".section \".data.modulus\"\n"
	"modulus_start:\n"
	"   .incbin \"" PATH_TO_KEYS RSA_MOD_FILE "\"\n"
	"modulus_end:" /* To get the file size */
);

/* RSA 2K Private Key Exponent */
extern uint8_t priv_exp_start;
extern uint8_t priv_exp_end;
__asm__ (
	".section \".data.priv_exp\"\n"
	"priv_exp_start:\n"
	"   .incbin \"" PATH_TO_KEYS RSA_PRIV_EXP_FILE "\"\n"
	"priv_exp_end:" /* To get the file size */
);

/* RSA 2K Signature - Generated by openssl - Used for verification */
extern uint8_t rsa_2k_sign;
extern uint8_t rsa_2k_sign_end;
__asm__ (
	"rsa_2k_sign:\n"
	"   .incbin \"" PATH_TO_KEYS RSA_SIGNATURE_FILE "\"\n"
	"rsa_2k_sign_end:" /* To get the file size */
);
#define RSA_SIGNATURE_SIZE	((u32_t)&rsa_2k_sign_end - (u32_t)&rsa_2k_sign)

#define PADDED_HASH_SIZE_RSA_2K	256

/*
 * @brief Match Openssl generated RSA2K signature with brcm api output
 * @details In this test, the private/public key pair used is generated by
 *	    openssl and included in to the test as binary blobs. In addition
 *	    to this, a sample test message and the RSA 2k signature generated
 *	    on its hash by openssl rsautl is also included as a binary blob.
 *	    The goal of this test is to take the modulus and private exponent
 *	    of the key pair generated by opensssl and sign the sample test
 *	    message. Failure to match the signature generated by the brcm api
 *	    with openssl signature qualifies the test as a failure. Following
 *	    the signing the verification is also performed for completeness
 *	    and the verify output is matched with the input that was signed
 */
static void rsa_2k_openssl_sign_brcm_verify(void)
{
	BCM_SCAPI_STATUS status;
	u8_t *msg = &test_message;
	u32_t size, brcm_sign_size, outlen;
	u8_t *modulus = &modulus_start;
	u8_t *priv_exp = &priv_exp_start;
	u8_t padded_hash[PADDED_HASH_SIZE_RSA_2K];
	u8_t verify_out[PADDED_HASH_SIZE_RSA_2K];
	u32_t modulus_size, priv_exp_size;
	/* Public exponent is 0x10001 */
	u8_t pub_exp[4] = {0x00, 0x01, 0x00, 0x01};
	static bool mod_exp_reversed = false;

	u8_t *hash = cache_line_aligned_alloc(SHA256_HASH_SIZE);
	u8_t *brcm_sign = cache_line_aligned_alloc(RSA_SIGNATURE_SIZE);

	zassert_not_null(hash, "Out of memory!");
	zassert_not_null(brcm_sign, "Out of memory!");

	/* If first byte is 0 ignore it */
	if (modulus[0] == 0)
		modulus++;

	/* If first byte is 0 ignore it */
	if (priv_exp[0] == 0)
		priv_exp++;

	modulus_size = (u32_t)&modulus_end - (u32_t)modulus;
	priv_exp_size = (u32_t)&priv_exp_end - (u32_t)priv_exp;

	zassert_equal(modulus_size, 256, NULL);
	zassert_equal(priv_exp_size, 256, NULL);

	/* Initalize crypto */
	init_crypto();
	size = (u32_t)&test_message_end - (u32_t)&test_message;

	/* Generate the SHA256 hash for the test message */
	status = crypto_symmetric_hmac_sha256((crypto_lib_handle *)cryptoHandle,
					      msg, size, NULL, 0, hash, TRUE);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "SHA256 generation failed");

	dump_array(hash, SHA256_HASH_SIZE, "SHA256 Hash");

	/* Generate the RSA 2K signature for the test message hash
	 * (using PKCS v1.5 padding method)
	 */
	/* First add padding */
	status = crypto_pka_emsa_pkcs1_v15_encode_hash(
			NULL, 0, /* No preamble */
			hash, SHA256_HASH_SIZE,
			PADDED_HASH_SIZE_RSA_2K, padded_hash);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "PKCS1 padding failed!");

	/* Then sign - Note that all input (padded hash, mod, priv exp) and
	 * output (sign) arrays are reversed and their sizes are specified in
	 * bits for the crypto_pka_rsa_mod_exp() api
	 */
	secure_memrev(padded_hash, padded_hash, PADDED_HASH_SIZE_RSA_2K);
	/* Reverse only once if not subsequent test run will re-reverse it */
	if (!mod_exp_reversed) {
		secure_memrev(modulus, modulus, modulus_size);
		secure_memrev(priv_exp, priv_exp, priv_exp_size);
		/* Set the flag to avoid reversing inputs on subsequent runs */
		mod_exp_reversed = true;
	}
	status = crypto_pka_rsa_mod_exp((crypto_lib_handle *)cryptoHandle,
			padded_hash, PADDED_HASH_SIZE_RSA_2K*8, /* Msg size in bits */
			modulus, modulus_size*8, /* Modulus Size in bits */
			priv_exp, priv_exp_size*8, /* Exponent size in bits */
			brcm_sign, &brcm_sign_size,
			NULL, NULL); /* No callback needed */
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "Signing failed!");

	/* Restore the padded hash to the original order, as it is used for
	 * comparison at the verify step.
	 */
	secure_memrev(padded_hash, padded_hash, PADDED_HASH_SIZE_RSA_2K);

	/* Reverse the output and compare the signature with the one
	 * generated by openssl command
	 */
	secure_memrev(brcm_sign, brcm_sign, brcm_sign_size);
	zassert_equal(memcmp(brcm_sign, &rsa_2k_sign, brcm_sign_size), 0,
		      "Generated signature not matching openssl signature!");
	TC_PRINT("Signature matches between OpenSSL and BRCM RSA API!!!\n");
	dump_array(brcm_sign, brcm_sign_size, "Signature");

	/* Now, verify the signature by getting the message (padded hash) back
	 * Modulus is already reversed, signature and public exponent needs to
	 * be reversed
	 */
	/* The signature was returned reversed by crypto_pka_rsa_mod_exp() api,
	 * but it was reversed again for comparision with openssl output sign
	 * Reversing it here to restore it to the order in which it was output
	 */
	secure_memrev(brcm_sign, brcm_sign, brcm_sign_size);
	secure_memrev(pub_exp, pub_exp, sizeof(pub_exp));
	status = crypto_pka_math_accelerate((crypto_lib_handle *)cryptoHandle,
			BCM_SCAPI_MATH_MODEXP,
			modulus, modulus_size*8, /* Modulus size in bits */
			brcm_sign, brcm_sign_size*8, /* Signature size in bits*/
			pub_exp, sizeof(pub_exp)*8, /* Public Exponent in bits*/
			verify_out, &outlen, /* Output message */
			NULL, NULL);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "Verification failed!");

	/* Compare the verify output and confim it matches the input
	 * (padded hash). Verify output needs to be reversed first
	 */
	secure_memrev(verify_out, verify_out, outlen);
	zassert_equal(memcmp(padded_hash, verify_out, outlen), 0,
		"Verification failed: Output does not match signed message!");
	TC_PRINT("SUCCESS: Verify output matches input padded hash\n");

	cache_line_aligned_free(hash);
	cache_line_aligned_free(brcm_sign);
}

/*
 * @brief Match Openssl generated signature with brcm api using brcm api
 *	  generated RSA 2K keys
 * @details In this test, the private/public key pair used is generated by
 *	    brcm apis. A sample test message is included as a binary blob.
 *	    This test generates the RSA 2K signature and output the signature
 *	    along with the equivalent openssl commands. The tester is required
 *	    to run these openssl commands and verify the signature matches.
 *	    This is a manual test.
 */
#define RSA2K_MODULUS_SIZE 256
static void rsa_2k_brcm_sign_openssl_verify(void)
{
	unsigned int i;
	BCM_SCAPI_STATUS status;
	u8_t *msg = &test_message;
	u32_t size, brcm_sign_size;
	u8_t padded_hash[PADDED_HASH_SIZE_RSA_2K];

	u8_t *hash, *brcm_sign;
	u8_t modulus[RSA2K_MODULUS_SIZE];
	u8_t pub_exp[4];
	u8_t priv_exp[RSA2K_MODULUS_SIZE];
	u8_t exp1[RSA2K_MODULUS_SIZE/2];
	u8_t exp2[RSA2K_MODULUS_SIZE/2];
	u8_t co_eff[RSA2K_MODULUS_SIZE/2];

	/* The brcm crypto api to generate keys has a known issue
	 * due to which it does not generate primes within a definite time
	 * So we use input primes to generate the RSA key pair.
	 */
	u8_t prime_p[RSA2K_MODULUS_SIZE/2];
	u8_t prime_q[RSA2K_MODULUS_SIZE/2];

	u32_t mod_bits, pub_exp_bits, priv_exp_bits, exp1_bits, exp2_bits;
	u32_t co_eff_bits, prime_p_bits, prime_q_bits;

	/* Initalize crypto */
	init_crypto();
	size = (u32_t)&test_message_end - (u32_t)&test_message;

	/* Generate the SHA256 hash for the test message */
	hash = cache_line_aligned_alloc(SHA256_HASH_SIZE);
	brcm_sign = cache_line_aligned_alloc(RSA_SIGNATURE_SIZE);
	status = crypto_symmetric_hmac_sha256((crypto_lib_handle *)cryptoHandle,
					      msg, size, NULL, 0, hash, TRUE);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "SHA256 generation failed");
	dump_array(hash, SHA256_HASH_SIZE, "SHA256 Hash");

	/* Generate the RSA 2K signature for the test message hash
	 * (using PKCS v1.5 padding method)
	 */
	/* First add padding */
	status = crypto_pka_emsa_pkcs1_v15_encode_hash(
			NULL, 0, /* No preamble */
			hash, SHA256_HASH_SIZE,
			PADDED_HASH_SIZE_RSA_2K, padded_hash);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "PKCS1 padding failed!");

	/* Generate keys - pub exp need to be reversed as they are input arrays
	 * pub_exp -> 0x10001
	 */
	pub_exp[0] = 0x0;
	pub_exp[1] = 0x1;
	pub_exp[2] = 0x0;
	pub_exp[3] = 0x1;
	secure_memrev(pub_exp, pub_exp, sizeof(pub_exp));
	pub_exp_bits = 17;
	prime_p_bits = prime_q_bits = 0;
	status = crypto_pka_rsa_key_generate((crypto_lib_handle *)cryptoHandle,
			2048, /* RSA 2K modulus size */
			&pub_exp_bits, pub_exp,
			&prime_p_bits, prime_p,
			&prime_q_bits, prime_q,
			&mod_bits, modulus,
			&priv_exp_bits, priv_exp,
			&exp1_bits, exp1,
			&exp2_bits, exp2,
			&co_eff_bits, co_eff);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "RSA key gen failed!");

	/* Now sign - Note that all input (padded hash, mod, priv exp) and
	 * output (sign) arrays are reversed and their sizes are specified in
	 * bits for the crypto_pka_rsa_mod_exp() api
	 */
	secure_memrev(padded_hash, padded_hash, PADDED_HASH_SIZE_RSA_2K);

	status = crypto_pka_rsa_mod_exp((crypto_lib_handle *)cryptoHandle,
			padded_hash, PADDED_HASH_SIZE_RSA_2K*8, /* Msg size in bits */
			modulus, sizeof(modulus)*8, /* Modulus Size in bits */
			priv_exp, sizeof(priv_exp)*8, /* Exponent size in bits */
			brcm_sign, &brcm_sign_size,
			NULL, NULL); /* No callback needed */
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "Signing failed!");

	/* Restore the padded hash to the original order, as it is used for
	 * generating openssl verify commands.
	 */
	secure_memrev(padded_hash, padded_hash, PADDED_HASH_SIZE_RSA_2K);

	/* Reverse modulus */
	secure_memrev(modulus, modulus, RSA2K_MODULUS_SIZE);

	/* Reverse the signature for generating openssl verification commands */
	secure_memrev(brcm_sign, brcm_sign, brcm_sign_size);

	/* Commands to create the public key file (DER) */
	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to create public key\n# --------------\n");
	TC_PRINT("echo \"30820122300d06092a864886f70d0101"
		 "0105000382010f003082010a0282010100\n");
	for (i = 0; i < RSA2K_MODULUS_SIZE; i++) {
		TC_PRINT("%02X", modulus[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("0203010001\n");
	TC_PRINT("\" | xxd -r -p > brcm_pub_key_rsa_2k.der\n");
	TC_PRINT("#######################################\n");

	/* Commands to create the input hash file (DER) */
	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to create brcm hash file\n# --------------\n");
	TC_PRINT("echo \"\n");
	for (i = 0; i < SHA256_HASH_SIZE; i++) {
		TC_PRINT("%02x", hash[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("\" | xxd -r -p > rsa2k_brcm_hash.bin\n");
	TC_PRINT("#######################################\n");

	/* Commands to create the signature file (DER) */
	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to create signature file\n# --------------\n");
	TC_PRINT("echo \"\n");
	for (i = 0; i < RSA_SIGNATURE_SIZE; i++) {
		TC_PRINT("%02x", brcm_sign[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("\" | xxd -r -p > brcm_sign_rsa_2k.bin\n");
	TC_PRINT("#######################################\n");

	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to verify the RSA2K signature\n# --------------\n");
	TC_PRINT("openssl rsautl -verify -pkcs -in brcm_sign_rsa_2k.bin \\\n"
		 "-pubin -inkey brcm_pub_key_rsa_2k.der -keyform DER \\\n"
		 "> rsa2k_openssl_hash.bin\n");
	TC_PRINT("cmp --silent rsa2k_openssl_hash.bin rsa2k_brcm_hash.bin &&\\\n"
		 "echo 'Signatures Match!!!' || echo 'Signature mismatch!'\n");

	TC_PRINT("#######################################\n");
	TC_PRINT("[MANUAL MODE]: Run the above commands on a linux server"
		 "to verify the RSA 2K signature\n");
	k_sleep(3000);

	cache_line_aligned_free(hash);
	cache_line_aligned_free(brcm_sign);
}

#define RSA4K_MODULUS_SIZE	512
static void rsa_4k_key_gen(void)
{
	unsigned int i;
	BCM_SCAPI_STATUS status;

	u8_t modulus[RSA4K_MODULUS_SIZE];
	u8_t pub_exp[4];
	u8_t priv_exp[RSA4K_MODULUS_SIZE];
	u8_t exp1[RSA4K_MODULUS_SIZE/2];
	u8_t exp2[RSA4K_MODULUS_SIZE/2];
	u8_t co_eff[RSA4K_MODULUS_SIZE/2];
	u8_t prime_p[RSA4K_MODULUS_SIZE/2];
	u8_t prime_q[RSA4K_MODULUS_SIZE/2];
	u32_t mod_bits, pub_exp_bits = 0, priv_exp_bits = 0, exp1_bits = 0, exp2_bits = 0;
	u32_t co_eff_bits = 0, prime_p_bits, prime_q_bits;

	TC_PRINT("RSA 4K key may take upto a minute ... Please be patient\n");
	/* Generate keys - public key 0x10001 needs to be reversed as it is
	 * an input array
	 */
	pub_exp[0] = 0x0;
	pub_exp[1] = 0x1;
	pub_exp[2] = 0x0;
	pub_exp[3] = 0x1;
	secure_memrev(pub_exp, pub_exp, sizeof(pub_exp));
	pub_exp_bits = 17;
	prime_p_bits = prime_q_bits = 0;
	status = crypto_pka_rsa_key_generate((crypto_lib_handle *)cryptoHandle,
			4096, /* RSA 4K modulus size */
			&pub_exp_bits, pub_exp,
			&prime_p_bits, prime_p,
			&prime_q_bits, prime_q,
			&mod_bits, modulus,
			&priv_exp_bits, priv_exp,
			&exp1_bits, exp1,
			&exp2_bits, exp2,
			&co_eff_bits, co_eff);
	TC_PRINT("status = %x\n", status);

	zassert_equal(status, BCM_SCAPI_STATUS_OK, "RSA key gen failed!");

#define LOG_KEY_GEN_CMDS
#ifdef LOG_KEY_GEN_CMDS
	/* Reverse all the arrays, since the pka api returns rsa key components
	 * in LSByte-first order.
	 */
	/* Linux commands to create the 4K RSA key pair (DER) */
	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Commands to create RSA 4K key file (DER)\n# -----------\n");
	TC_PRINT("echo \"3082092a0201000282020100\n");
	secure_memrev(modulus, modulus, RSA4K_MODULUS_SIZE);
	for (i = 0; i < RSA4K_MODULUS_SIZE; i++) {
		TC_PRINT("%02x", modulus[i]);
	}
	secure_memrev(modulus, modulus, RSA4K_MODULUS_SIZE);

	TC_PRINT("0204\n");
	secure_memrev(pub_exp, pub_exp, sizeof(pub_exp));
	for (i = 0; i < sizeof(pub_exp); i++) {
		TC_PRINT("%02x", pub_exp[i]);
	}
	secure_memrev(pub_exp, pub_exp, sizeof(pub_exp));

	TC_PRINT("02820200\n");
	secure_memrev(priv_exp, priv_exp, RSA4K_MODULUS_SIZE);
	for (i = 0; i < RSA4K_MODULUS_SIZE; i++) {
		TC_PRINT("%02x", priv_exp[i]);
	}
	secure_memrev(priv_exp, priv_exp, RSA4K_MODULUS_SIZE);

	TC_PRINT("0282010100\n");
	secure_memrev(prime_p, prime_p, RSA4K_MODULUS_SIZE/2);
	for (i = 0; i < RSA4K_MODULUS_SIZE/2; i++) {
		TC_PRINT("%02x", prime_p[i]);
	}
	secure_memrev(prime_p, prime_p, RSA4K_MODULUS_SIZE/2);

	TC_PRINT("0282010100\n");
	secure_memrev(prime_q, prime_q, RSA4K_MODULUS_SIZE/2);
	for (i = 0; i < RSA4K_MODULUS_SIZE/2; i++) {
		TC_PRINT("%02x", prime_q[i]);
	}
	secure_memrev(prime_q, prime_q, RSA4K_MODULUS_SIZE/2);

	TC_PRINT("0282010100\n");
	secure_memrev(exp1, exp1, RSA4K_MODULUS_SIZE/2);
	for (i = 0; i < RSA4K_MODULUS_SIZE/2; i++) {
		TC_PRINT("%02x", exp1[i]);
	}
	secure_memrev(exp1, exp1, RSA4K_MODULUS_SIZE/2);

	TC_PRINT("02820100\n");
	secure_memrev(exp2, exp2, RSA4K_MODULUS_SIZE/2);
	for (i = 0; i < RSA4K_MODULUS_SIZE/2; i++) {
		TC_PRINT("%02x", exp2[i]);
	}
	secure_memrev(exp2, exp2, RSA4K_MODULUS_SIZE/2);

	TC_PRINT("0282010100\n");
	secure_memrev(co_eff, co_eff, RSA4K_MODULUS_SIZE/2);
	for (i = 0; i < RSA4K_MODULUS_SIZE/2; i++) {
		TC_PRINT("%02x", co_eff[i]);
	}
	secure_memrev(co_eff, co_eff, RSA4K_MODULUS_SIZE/2);
	TC_PRINT("\" | xxd -r -p > rsa_4k_key.der\n");
	TC_PRINT("#######################################\n");
	TC_PRINT("# Command to convert DER format to PEM format\n");
	TC_PRINT("#######################################\n");
	TC_PRINT("openssl rsa -in rsa_4k_key.der -inform DER -out rsa_4k_key.pem\n");
	TC_PRINT("#######################################\n");
	TC_PRINT("# Command to sign and verify using the 4k RSA key\n");
	TC_PRINT("#######################################\n");
	TC_PRINT("echo \"Hello World\" > test_message.txt\n");
	TC_PRINT("openssl dgst -sha512 -binary -out sha512.hash test_message.txt\n");
	TC_PRINT("openssl rsautl -sign -pkcs -in sha512.hash -inkey rsa_4k_key.pem -out rsa_4k_sign.bin\n");
	TC_PRINT("openssl rsautl -verify -pkcs -in rsa_4k_sign.bin -inkey rsa_4k_key.pem -out out.hash\n");
	TC_PRINT("cmp --silent sha512.hash out.hash &&\\\n"
		 "echo 'Verification OK!!!' || echo 'Verification Failed!'\n");
#else
	TC_PRINT("asn1=SEQUENCE:rsa_key\n");
	TC_PRINT("[rsa_key]\n");
	TC_PRINT("version=INTEGER:0)\n\n");
	/* Print Modulus */
	TC_PRINT("\nn=INTEGER:\n");
	secure_memrev(modulus, modulus, mod_bits/8);
	for (i = 0; i < mod_bits/8; i++) {
		TC_PRINT("%02x", modulus[i]);
	}
	secure_memrev(modulus, modulus, mod_bits/8);
	/* Print Public Exponent */
	secure_memrev(pub_exp, pub_exp, pub_exp_bits/8);
	TC_PRINT("\ne=INTEGER:\n");
	for (i = 0; i < (pub_exp_bits+7)/8; i++) {
		TC_PRINT("%02x", pub_exp[i]);
	}
	secure_memrev(pub_exp, pub_exp, pub_exp_bits/8);
	/* Print Private Exponent */
	secure_memrev(priv_exp, priv_exp, priv_exp_bits/8);
	TC_PRINT("\nd=INTEGER:\n");
	for (i = 0; i < priv_exp_bits/8; i++) {
		TC_PRINT("%02x", priv_exp[i]);
	}
	secure_memrev(priv_exp, priv_exp, priv_exp_bits/8);
	/* Print Prime P */
	secure_memrev(prime_p, prime_p, prime_p_bits/8);
	TC_PRINT("\np=INTEGER:\n");
	for (i = 0; i < prime_p_bits/8; i++) {
		TC_PRINT("%02x", prime_p[i]);
	}
	secure_memrev(prime_p, prime_p, prime_p_bits/8);
	/* Print Prime q */
	secure_memrev(prime_q, prime_q, prime_q_bits/8);
	TC_PRINT("\nq=INTEGER:\n");
	for (i = 0; i < prime_q_bits/8; i++) {
		TC_PRINT("%02x", prime_q[i]);
	}
	secure_memrev(prime_q, prime_q, prime_q_bits/8);
	/* Print Exponent 1 */
	secure_memrev(exp1, exp1, exp1_bits/8);
	TC_PRINT("\nexp1=INTEGER:\n");
	for (i = 0; i < exp1_bits/8; i++) {
		TC_PRINT("%02x", exp1[i]);
	}
	secure_memrev(exp1, exp1, exp1_bits/8);
	/* Print Exponent 2 */
	secure_memrev(exp2, exp2, exp2_bits/8);
	TC_PRINT("\nexp2=INTEGER:\n");
	for (i = 0; i < exp2_bits/8; i++) {
		TC_PRINT("%02x", exp2[i]);
	}
	secure_memrev(exp2, exp2, exp2_bits/8);
	/* Print Coefficient */
	secure_memrev(co_eff, co_eff, co_eff_bits/8);
	TC_PRINT("\ncoeff=INTEGER:\n");
	for (i = 0; i < co_eff_bits/8; i++) {
		TC_PRINT("%02x", co_eff[i]);
	}
	secure_memrev(co_eff, co_eff, co_eff_bits/8);
#endif
}

/*****************************************/
/************** ECDSA P256 ***************/
/*****************************************/
/* Generated with the following openssl commands
 * openssl ecparam -genkey -name prime256v1 -noout \
 *	-out private_key_ecdsa_p256.pem
 * openssl ec -in private_key_ecdsa_p256.pem -noout -text 2>&1 | \
 *	sed -n '/priv:/,/pub:/{//!p}' | \
 *	sed -E 's/:/ /g' | \
 *	xxd -r -p > private_key_ecdsa_p256.bin
 */
#define PRIV_KEY_ECDSA_P256 "keys/private_key_ecdsa_p256.bin"
/* Generated with the following openssl commands
 * openssl ec -in private_key_ecdsa_p256.pem -pubout \
 *	-out public_key_ecdsa_p256.pem
 * openssl ec -in public_key_ecdsa_p256.pem -pubin -noout -text 2>&1 | \
 *	sed -n '/pub:/,/ASN1/{//!p}' | \
 *	sed -E 's/:/ /g' | \
 *	xxd -r -p > public_key_ecdsa_p256.bin
 */
#define PUB_KEY_ECDSA_P256 "keys/public_key_ecdsa_p256.bin"
/* Generated with the following openssl command
 * openssl dgst -sha256 -sign private_key_ecdsa_p256.pem \
 *	-out signature_ecdsa_p256.bin test_message.txt
 * openssl asn1parse -inform DER -in signature_ecdsa_p256.bin | \
 *	grep INTEGER | cut -d":" -f4 | head -1 | \
 *	xxd -r -p > ecdsa_p256_sig_r.bin
 * openssl asn1parse -inform DER -in signature_ecdsa_p256.bin | \
 *	grep INTEGER | cut -d":" -f4 | tail -1 | \
 *	xxd -r -p > ecdsa_p256_sig_s.bin
 */
#define ECDSA_P256_SIGN_R_FILE	"keys/ecdsa_p256_sig_r.bin"
#define ECDSA_P256_SIGN_S_FILE	"keys/ecdsa_p256_sig_s.bin"

/* ECDSA Private key (P256) */
extern uint8_t priv_key_ecdsa_p256_start;
extern uint8_t priv_key_ecdsa_p256_end;
__asm__ (
	".section \".data.priv_key_ecdsa_p256_start\"\n"
	"priv_key_ecdsa_p256_start:\n"
	"   .incbin \"" PATH_TO_KEYS PRIV_KEY_ECDSA_P256 "\"\n"
	"priv_key_ecdsa_p256_end:" /* To get the file size */
);

/* ECDSA Public key (P256) */
extern uint8_t pub_key_ecdsa_p256_start;
extern uint8_t pub_key_ecdsa_p256_end;
__asm__ (
	".section \".data.pub_key_ecdsa_p256_start\"\n"
	"pub_key_ecdsa_p256_start:\n"
	"   .incbin \"" PATH_TO_KEYS PUB_KEY_ECDSA_P256 "\"\n"
	"pub_key_ecdsa_p256_end:" /* To get the file size */
);
/* -1 to ignore the first byte (0x4) in the public key */
#define PUB_KEY_ECDSA_P256_SIZE	\
	((u32_t)&pub_key_ecdsa_p256_end - (u32_t)&pub_key_ecdsa_p256_start - 1)

/* ECDSA Signature (r) (P256) */
extern uint8_t ecdsa_p256_sign_r_start;
extern uint8_t ecdsa_p256_sign_r_end;
__asm__ (
	".section \".data.ecdsa_p256_sign_r_start\"\n"
	"ecdsa_p256_sign_r_start:\n"
	"   .incbin \"" PATH_TO_KEYS ECDSA_P256_SIGN_R_FILE "\"\n"
	"ecdsa_p256_sign_r_end:" /* To get the file size */
);
#define ECDSA_P256_SIGN_R_SIZE	\
	((u32_t)&ecdsa_p256_sign_r_end - (u32_t)&ecdsa_p256_sign_r_start)

/* ECDSA Signature (s) (P256) */
extern uint8_t ecdsa_p256_sign_s_start;
extern uint8_t ecdsa_p256_sign_s_end;
__asm__ (
	".section \".data.ecdsa_p256_sign_s_start\"\n"
	"ecdsa_p256_sign_s_start:\n"
	"   .incbin \"" PATH_TO_KEYS ECDSA_P256_SIGN_S_FILE "\"\n"
	"ecdsa_p256_sign_s_end:" /* To get the file size */
);
#define ECDSA_P256_SIGN_S_SIZE	\
	((u32_t)&ecdsa_p256_sign_s_end - (u32_t)&ecdsa_p256_sign_s_start)

static void get_ec_p256_params(u32_t *A, u32_t *B, u32_t *p, u32_t *n,
			       u32_t *GX, u32_t *GY)
{
	/* ECC curve vectors from FIPS 186-2-change1.pdf, Page 29, Curve P-256,
	and represented here in BIGNUM format */
	A[0] = 0xffffffff;
	A[1] = 0x00000001;
	A[2] = 0x00000000;
	A[3] = 0x00000000;
	A[4] = 0x00000000;
	A[5] = 0xffffffff;
	A[6] = 0xffffffff;
	A[7] = 0xfffffffc;

	B[0] = 0x5ac635d8;
	B[1] = 0xaa3a93e7;
	B[2] = 0xb3ebbd55;
	B[3] = 0x769886bc;
	B[4] = 0x651d06b0;
	B[5] = 0xcc53b0f6;
	B[6] = 0x3bce3c3e;
	B[7] = 0x27d2604b;

	p[0] = 0xffffffff;
	p[1] = 0x00000001;
	p[2] = 0x00000000;
	p[3] = 0x00000000;
	p[4] = 0x00000000;
	p[5] = 0xffffffff;
	p[6] = 0xffffffff;
	p[7] = 0xffffffff;

	n[0] = 0xffffffff;
	n[1] = 0x00000000;
	n[2] = 0xffffffff;
	n[3] = 0xffffffff;
	n[4] = 0xbce6faad;
	n[5] = 0xa7179e84;
	n[6] = 0xf3b9cac2;
	n[7] = 0xfc632551;

	GX[0] = 0x6b17d1f2;
	GX[1] = 0xe12c4247;
	GX[2] = 0xf8bce6e5;
	GX[3] = 0x63a440f2;
	GX[4] = 0x77037d81;
	GX[5] = 0x2deb33a0;
	GX[6] = 0xf4a13945;
	GX[7] = 0xd898c296;

	GY[0] = 0x4fe342e2;
	GY[1] = 0xfe1a7f9b;
	GY[2] = 0x8ee7eb4a;
	GY[3] = 0x7c0f9e16;
	GY[4] = 0x2bce3357;
	GY[5] = 0x6b315ece;
	GY[6] = 0xcbb64068;
	GY[7] = 0x37bf51f5;
}

static void memrev_word(u32_t *to, u32_t *from, u32_t size_in_words)
{
	u32_t tmp, i;

	for (i = 0; i < (size_in_words+1)/2; i++) {
		tmp = from[i];
		to[i] = from[size_in_words - i - 1];
		to[size_in_words - i - 1] = tmp;
	}
}

/*
 * @brief Verify Openssl generated ECDSA P-256 signature with brcm api
 * @details In this test, the private/public key pair used is generated by
 *	    openssl and included in to the test as binary blobs. In addition
 *	    to this, a sample test message and the ECDS P256 signature generated
 *	    on the message hash by openssl is also included as a binary blob.
 *	    The goal of this test is to take use the public key from the ECDSA
 *	    key and verify that the signature is a valid signature. While the
 *	    crypto driver does provide apis to generate the signature, it won't
 *	    be possible to match the signature with the openssl signature,
 *	    because the signature generation take a random number as an input
 *	    and it is not possible to retrieve this random number from openssl.
 *	    Hence only verification is tested.
 */
#define ECDSA_256_BITLEN           256
#define ECDSA_256_PARAM_SIZE_WORDS BIT_TO_WORD(ECDSA_256_BITLEN)
#define ECDSA_256_SIGN_SIZE_BYTES (BIT_TO_WORD(ECDSA_256_BITLEN)*sizeof(u32_t))
#define ECDSA_256_KEY_SIZE_BYTES  (BIT_TO_WORD(ECDSA_256_BITLEN)*sizeof(u32_t))

static void ecdsa_p256_openssl_sign_brcm_verify(void)
{
	BCM_SCAPI_STATUS status;
	u8_t *pub_key = (u8_t *)&pub_key_ecdsa_p256_start;

	u32_t size;
	u8_t *msg = &test_message;

	u32_t A[ECDSA_256_PARAM_SIZE_WORDS], B[ECDSA_256_PARAM_SIZE_WORDS],
	      p[ECDSA_256_PARAM_SIZE_WORDS], n[ECDSA_256_PARAM_SIZE_WORDS],
	      GX[ECDSA_256_PARAM_SIZE_WORDS], GY[ECDSA_256_PARAM_SIZE_WORDS],
	      QZ[ECDSA_256_PARAM_SIZE_WORDS];

	u8_t *hash;
	u8_t sig_r[ECDSA_256_SIGN_SIZE_BYTES] = {0};
	u8_t sig_s[ECDSA_256_SIGN_SIZE_BYTES] = {0};

	u8_t pub_k_x[ECDSA_256_KEY_SIZE_BYTES] = {0};
	u8_t pub_k_y[ECDSA_256_KEY_SIZE_BYTES] = {0};

	/* Ignore the first 0x4 in public key (if present) */
	if (pub_key[0] == 0x04)
		pub_key++;

	/* Get P-256 Curve params */
	get_ec_p256_params(A, B, p, n, GX, GY);
	memset(QZ, 0, sizeof(QZ));
	QZ[0] = 0x00000001;

	hash = cache_line_aligned_alloc(SHA256_HASH_SIZE);
	zassert_not_null(hash, "Out of memory!");

	/* Initalize crypto */
	init_crypto();
	size = (u32_t)&test_message_end - (u32_t)&test_message;

	/* Generate the SHA256 hash for the test message */
	status = crypto_symmetric_hmac_sha256((crypto_lib_handle *)cryptoHandle,
					      msg, size, NULL, 0, hash, TRUE);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "SHA256 generation failed");
	dump_array(hash, SHA256_HASH_SIZE, "SHA256 Hash");

	/* Verify openssl signature (all params need to be reversed */
	secure_memrev(sig_r, &ecdsa_p256_sign_r_start, ECDSA_P256_SIGN_R_SIZE);
	secure_memrev(sig_s, &ecdsa_p256_sign_s_start, ECDSA_P256_SIGN_S_SIZE);
	/* QX, QY need to be seprately reversed in the public key */
	secure_memrev(pub_k_x, pub_key, PUB_KEY_ECDSA_P256_SIZE / 2);
	secure_memrev(pub_k_y, pub_key + PUB_KEY_ECDSA_P256_SIZE / 2,
		      PUB_KEY_ECDSA_P256_SIZE / 2);
	secure_memrev(hash, hash, SHA256_HASH_SIZE);

	/* The curve params need to be given in reverse (word wise) LSW first */
	memrev_word(A, A, WORD_SIZE(A));
	memrev_word(B, B, WORD_SIZE(B));
	memrev_word(p, p, WORD_SIZE(p));
	memrev_word(n, n, WORD_SIZE(n));
	memrev_word(GX, GX, WORD_SIZE(GX));
	memrev_word(GY, GY, WORD_SIZE(GY));

	status = crypto_pka_ecp_ecdsa_verify((crypto_lib_handle *)cryptoHandle,
			hash, SHA256_HASH_SIZE, 0, /* Type - Prime field */
			(u8_t *)p, ECDSA_256_BITLEN,
			(u8_t *)A, (u8_t *)B, (u8_t *)n,
			(u8_t *)GX, (u8_t *)GY,
			pub_k_x, pub_k_y, (u8_t *)QZ,
			sig_r, sig_s,
			NULL, NULL);

	zassert_equal(status, BCM_SCAPI_STATUS_OK, "ECDSA Verify failed!");

	cache_line_aligned_free(hash);
}

/*
 * @brief Verify BRCM API generated ECDSA P-256 signature with openssl
 * @details In this test, the private/public key pair used is generated by
 *	    brcm api. The sample message is signed by the private key
 *	    generated and the signature and the public key are emitted to the
 *	    console in ASN1 syntax. The tester is expected to convert this
 *	    to a .der file and verify the signature using the public key
 *	    through openssl commands.
 */
static void ecdsa_p256_brcm_sign_openssl_verify(void)
{
	u32_t i;
	BCM_SCAPI_STATUS status;
	u8_t priv_key[32];
	u8_t pub_key[64];

	u32_t size;
	u8_t *msg = &test_message;

	u32_t A[8], B[8], p[8], n[8], GX[8], GY[8];

	u8_t k[32];

	u8_t *hash;
	u8_t sig_r[ECDSA_P256_SIGN_R_SIZE];
	u8_t sig_s[ECDSA_P256_SIGN_S_SIZE];

	/* Get P-256 Curve params */
	get_ec_p256_params(A, B, p, n, GX, GY);

	hash = cache_line_aligned_alloc(SHA256_HASH_SIZE);
	zassert_not_null(hash, "Out of memory!");

	/* Initalize crypto */
	init_crypto();
	size = (u32_t)&test_message_end - (u32_t)&test_message;

	/* Generate the SHA256 hash for the test message */
	status = crypto_symmetric_hmac_sha256((crypto_lib_handle *)cryptoHandle,
					      msg, size, NULL, 0, hash, TRUE);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "SHA256 generation failed");
	dump_array(hash, SHA256_HASH_SIZE, "SHA256 Hash");

	/* Generate the keys (Word reverse all key params) */
	memrev_word(A, A, sizeof(A)/4);
	memrev_word(B, B, sizeof(B)/4);
	memrev_word(p, p, sizeof(p)/4);
	memrev_word(n, n, sizeof(n)/4);
	memrev_word(GX, GX, sizeof(GX)/4);
	memrev_word(GY, GY, sizeof(GY)/4);
	status = crypto_pka_ecp_ecdsa_key_generate(
				(crypto_lib_handle *)cryptoHandle,
				0, /* Type - Prime field */
				(u8_t *)p, sizeof(p)*8,
				(u8_t *)A, (u8_t *)B, (u8_t *)n,
				(u8_t *)GX, (u8_t *)GY,
				priv_key, 0, /* Generate private key */
				pub_key,
				pub_key + sizeof(pub_key)/2,
				NULL, NULL);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "ECDSA P256 Key gen failed");

	/* Sign the hash (Reverse hash only, Private/Public keys are already
	 * reversed)
	 */
	secure_memrev(hash, hash, SHA256_HASH_SIZE);
	status = crypto_pka_ecp_ecdsa_sign((crypto_lib_handle *)cryptoHandle,
			hash, SHA256_HASH_SIZE, 0, /* Type - Prime Field */
			(u8_t *)p, sizeof(p)*8, /* P length in bits */
			(u8_t *)A, (u8_t *)B, (u8_t *)n,
			(u8_t *)GX, (u8_t *)GY,
			k, 0, /* K invalid */
			priv_key,
			sig_r, sig_s,
			NULL, NULL);

	/* Verify brcm signature with brcm verify api - redundant check
	 * but it verifies the correctness anyway
	 */
	u32_t QZ[8] = {0x1, 0, 0, 0, 0, 0, 0, 0};
	status = crypto_pka_ecp_ecdsa_verify((crypto_lib_handle *)cryptoHandle,
			hash, SHA256_HASH_SIZE, 0, /* Type - Prime field */
			(u8_t *)p, sizeof(p)*8,
			(u8_t *)A, (u8_t *)B, (u8_t *)n,
			(u8_t *)GX, (u8_t *)GY,
			pub_key, pub_key + sizeof(pub_key)/2, (u8_t *)QZ,
			sig_r, sig_s,
			NULL, NULL);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "ECDSA Verify failed!");


	/* Dump the public key and Signature to console */
	/* Reverse the private/public key (X, Y), signature (R,S) and re-reverse
	 * the hash
	 */
	secure_memrev(hash, hash, SHA256_HASH_SIZE);
	secure_memrev(priv_key, priv_key, sizeof(priv_key)); /* QX */
	secure_memrev(pub_key, pub_key, sizeof(pub_key)/2); /* QX */
	secure_memrev(pub_key + sizeof(pub_key)/2, pub_key + sizeof(pub_key)/2,
		      sizeof(pub_key)/2); /* QY */
	secure_memrev(sig_r, sig_r, sizeof(sig_r));
	secure_memrev(sig_s, sig_s, sizeof(sig_s));

	dump_array(sig_r, sizeof(sig_r), "Signature (R)");
	dump_array(sig_s, sizeof(sig_s), "Signature (S)");
	dump_array(priv_key, sizeof(priv_key), "Private Key");
	dump_array(pub_key, sizeof(pub_key), "Public Key");
	dump_array(hash, SHA256_HASH_SIZE, "Hash");
	secure_memrev((u8_t *)k, (u8_t *)k, sizeof(k));
	dump_array(k, sizeof(k), "Random number");

	/* Commands to create the public key file (DER) */
	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to create public key\n# --------------\n");
	TC_PRINT("echo \"30770201010420\n");
	for (i = 0; i < sizeof(priv_key); i++) {
		TC_PRINT("%02X", priv_key[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("a00a06082a8648ce3d030107a14403420004\n");
	for (i = 0; i < sizeof(pub_key); i++) {
		TC_PRINT("%02X", pub_key[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("\" | xxd -r -p > brcm_priv_key_ecdsa_p256.der\n");
	TC_PRINT("openssl ec -inform DER -in brcm_priv_key_ecdsa_p256.der \\\n"
		 "-pubout -out brcm_pub_key_ecdsa_p256.pem\n");
	TC_PRINT("#######################################\n");

	/* Commands to create the signature file (DER) */
	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to create signature file\n# --------------\n");
	TC_PRINT("echo \"30\n");
	/* To prefix extra 0x00 if the first bit is '1' */
	TC_PRINT("%x\n", 0x44 + (sig_r[0] >> 7) + (sig_s[0] >> 7));
	TC_PRINT("02%s\n", (sig_r[0] & 0x80) ? "2100" : "20");
	for (i = 0; i < sizeof(sig_r); i++) {
		TC_PRINT("%02x", sig_r[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("02%s\n", (sig_s[0] & 0x80) ? "2100" : "20");
	for (i = 0; i < sizeof(sig_s); i++) {
		TC_PRINT("%02x", sig_s[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("\" | xxd -r -p > sign_ecdsa_p256.der\n");
	TC_PRINT("#######################################\n");

	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to verify the ECDSA signature\n# --------------\n");
	TC_PRINT("openssl dgst -sha256 -verify brcm_pub_key_ecdsa_p256.pem \\\n"
		 "-signature sign_ecdsa_p256.der test_message.txt\n");
	TC_PRINT("#######################################\n");
	TC_PRINT("[MANUAL MODE]: Run the above commands on a linux server"
		 "to verify the ECDSA P256 signature\n");
	k_sleep(3000);

	cache_line_aligned_free(hash);
}

/*****************************************/
/************** ECDSA P521 ***************/
/*****************************************/
/* Generated with the following openssl commands
 * openssl ecparam -genkey -name secp521r1 -noout \
 *	-out private_key_ecdsa_p521.pem
 * openssl ec -in private_key_ecdsa_p521.pem -noout -text 2>&1 | \
 *	sed -n '/priv:/,/pub:/{//!p}' | \
 *	sed -E 's/:/ /g' | \
 *	xxd -r -p > private_key_ecdsa_p521.bin
 */
#define PRIV_KEY_ECDSA_P521 "keys/private_key_ecdsa_p521.bin"
/* Generated with the following openssl commands
 * openssl ec -in private_key_ecdsa_p521.pem -pubout \
 *	-out public_key_ecdsa_p521.pem
 * openssl ec -in public_key_ecdsa_p521.pem -pubin -noout -text 2>&1 | \
 *	sed -n '/pub:/,/ASN1/{//!p}' | \
 *	sed -E 's/:/ /g' | \
 *	xxd -r -p > public_key_ecdsa_p521.bin
 */
#define PUB_KEY_ECDSA_P521 "keys/public_key_ecdsa_p521.bin"
/* Generated with the following openssl command
 * openssl dgst -sha512 -sign private_key_ecdsa_p521.pem \
 *	-out signature_ecdsa_p521.bin test_message.txt
 * openssl asn1parse -inform DER -in signature_ecdsa_p521.bin | \
 *	grep INTEGER | cut -d":" -f4 | head -1 | \
 *	xxd -r -p > ecdsa_p521_sig_r.bin
 * openssl asn1parse -inform DER -in signature_ecdsa_p521.bin | \
 *	grep INTEGER | cut -d":" -f4 | tail -1 | \
 *	xxd -r -p > ecdsa_p521_sig_s.bin
 */
#define ECDSA_P521_SIGN_R_FILE	"keys/ecdsa_p521_sig_r.bin"
#define ECDSA_P521_SIGN_S_FILE	"keys/ecdsa_p521_sig_s.bin"

/* ECDSA Private key (P521) */
extern uint8_t priv_key_ecdsa_p521_start;
extern uint8_t priv_key_ecdsa_p521_end;
__asm__ (
	".section \".data.priv_key_ecdsa_p521_start\"\n"
	"priv_key_ecdsa_p521_start:\n"
	"   .incbin \"" PATH_TO_KEYS PRIV_KEY_ECDSA_P521 "\"\n"
	"priv_key_ecdsa_p521_end:" /* To get the file size */
);

/* ECDSA Public key (P521) */
extern uint8_t pub_key_ecdsa_p521_start;
extern uint8_t pub_key_ecdsa_p521_end;
__asm__ (
	".section \".data.pub_key_ecdsa_p521_start\"\n"
	"pub_key_ecdsa_p521_start:\n"
	"   .incbin \"" PATH_TO_KEYS PUB_KEY_ECDSA_P521 "\"\n"
	"pub_key_ecdsa_p521_end:" /* To get the file size */
);
/* -1 to ignore the first byte (0x4) in the public key */
#define PUB_KEY_ECDSA_P521_SIZE	\
	((u32_t)&pub_key_ecdsa_p521_end - (u32_t)&pub_key_ecdsa_p521_start - 1)

/* ECDSA Signature (r) (P521) */
extern uint8_t ecdsa_p521_sign_r_start;
extern uint8_t ecdsa_p521_sign_r_end;
__asm__ (
	"ecdsa_p521_sign_r_start:\n"
	"   .incbin \"" PATH_TO_KEYS ECDSA_P521_SIGN_R_FILE "\"\n"
	"ecdsa_p521_sign_r_end:" /* To get the file size */
);
#define ECDSA_P521_SIGN_R_SIZE	\
	((u32_t)&ecdsa_p521_sign_r_end - (u32_t)&ecdsa_p521_sign_r_start)

/* ECDSA Signature (s) (P521) */
extern uint8_t ecdsa_p521_sign_s_start;
extern uint8_t ecdsa_p521_sign_s_end;
__asm__ (
	"ecdsa_p521_sign_s_start:\n"
	"   .incbin \"" PATH_TO_KEYS ECDSA_P521_SIGN_S_FILE "\"\n"
	"ecdsa_p521_sign_s_end:" /* To get the file size */
);
#define ECDSA_P521_SIGN_S_SIZE	\
	((u32_t)&ecdsa_p521_sign_s_end - (u32_t)&ecdsa_p521_sign_s_start)

static void get_ec_p521_params(u32_t *A, u32_t *B, u32_t *p, u32_t *n,
			       u32_t *GX, u32_t *GY)
{
	/* ECC curve vectors from FIPS 186-2-change1.pdf, Page 29, Curve P-512,
	and represented here in BIGNUM format */

	A[0] = 0x01FF;
	A[1] = 0xFFFFFFFF;
	A[2] = 0xFFFFFFFF;
	A[3] = 0xFFFFFFFF;
	A[4] = 0xFFFFFFFF;
	A[5] = 0xFFFFFFFF;
	A[6] = 0xFFFFFFFF;
	A[7] = 0xFFFFFFFF;
	A[8] = 0xFFFFFFFF;
	A[9] = 0xFFFFFFFF;
	A[10] = 0xFFFFFFFF;
	A[11] = 0xFFFFFFFF;
	A[12] = 0xFFFFFFFF;
	A[13] = 0xFFFFFFFF;
	A[14] = 0xFFFFFFFF;
	A[15] = 0xFFFFFFFF;
	A[16] = 0xFFFFFFFC;

	B[0] = 0x51;
	B[1] = 0x953EB961;
	B[2] = 0x8E1C9A1F;
	B[3] = 0x929A21A0;
	B[4] = 0xB68540EE;
	B[5] = 0xA2DA725B;
	B[6] = 0x99B315F3;
	B[7] = 0xB8B48991;
	B[8] = 0x8EF109E1;
	B[9] = 0x56193951;
	B[10] = 0xEC7E937B;
	B[11] = 0x1652C0BD;
	B[12] = 0x3BB1BF07;
	B[13] = 0x3573DF88;
	B[14] = 0x3D2C34F1;
	B[15] = 0xEF451FD4;
	B[16] = 0x6B503F00;

	GX[0] = 0x00C6,
	GX[1] = 0x858E06B7;
	GX[2] = 0x0404E9CD;
	GX[3] = 0x9E3ECB66;
	GX[4] = 0x2395B442;
	GX[5] = 0x9C648139;
	GX[6] = 0x053FB521;
	GX[7] = 0xF828AF60;
	GX[8] = 0x6B4D3DBA;
	GX[9] = 0xA14B5E77;
	GX[10] = 0xEFE75928;
	GX[11] = 0xFE1DC127;
	GX[12] = 0xA2FFA8DE;
	GX[13] = 0x3348B3C1;
	GX[14] = 0x856A429B;
	GX[15] = 0xF97E7E31;
	GX[16] = 0xC2E5BD66;

	GY[0] = 0x0118;
	GY[1] = 0x39296A78;
	GY[2] = 0x9A3BC004;
	GY[3] = 0x5C8A5FB4;
	GY[4] = 0x2C7D1BD9;
	GY[5] = 0x98F54449;
	GY[6] = 0x579B4468;
	GY[7] = 0x17AFBD17;
	GY[8] = 0x273E662C;
	GY[9] = 0x97EE7299;
	GY[10] = 0x5EF42640;
	GY[11] = 0xC550B901;
	GY[12] = 0x3FAD0761;
	GY[13] = 0x353C7086;
	GY[14] = 0xA272C240;
	GY[15] = 0x88BE9476;
	GY[16] = 0x9FD16650;

	p[0] = 0x01FF;
	p[1] = 0xFFFFFFFF;
	p[2] = 0xFFFFFFFF;
	p[3] = 0xFFFFFFFF;
	p[4] = 0xFFFFFFFF;
	p[5] = 0xFFFFFFFF;
	p[6] = 0xFFFFFFFF;
	p[7] = 0xFFFFFFFF;
	p[8] = 0xFFFFFFFF;
	p[9] = 0xFFFFFFFF;
	p[10] = 0xFFFFFFFF;
	p[11] = 0xFFFFFFFF;
	p[12] = 0xFFFFFFFF;
	p[13] = 0xFFFFFFFF;
	p[14] = 0xFFFFFFFF;
	p[15] = 0xFFFFFFFF;
	p[16] = 0xFFFFFFFF;

	n[0] = 0x01FF;
	n[1] = 0xFFFFFFFF;
	n[2] = 0xFFFFFFFF;
	n[3] = 0xFFFFFFFF;
	n[4] = 0xFFFFFFFF;
	n[5] = 0xFFFFFFFF;
	n[6] = 0xFFFFFFFF;
	n[7] = 0xFFFFFFFF;
	n[8] = 0xFFFFFFFA;
	n[9] = 0x51868783;
	n[10] = 0xBF2F966B;
	n[11] = 0x7FCC0148;
	n[12] = 0xF709A5D0;
	n[13] = 0x3BB5C9B8;
	n[14] = 0x899C47AE;
	n[15] = 0xBB6FB71E;
	n[16] = 0x91386409;
}

#define ECDSA_521_BITLEN           521
#define ECDSA_521_PARAM_SIZE_WORDS BIT_TO_WORD(ECDSA_521_BITLEN)
#define ECDSA_521_SIGN_SIZE_BYTES (BIT_TO_WORD(ECDSA_521_BITLEN)*sizeof(u32_t))
#define ECDSA_521_KEY_SIZE_BYTES  (BIT_TO_WORD(ECDSA_521_BITLEN)*sizeof(u32_t))
/*
 * @brief Verify Openssl generated ECDSA P-512 signature with brcm api
 * @details In this test, the private/public key pair used is generated by
 *	    openssl and included in to the test as binary blobs. In addition
 *	    to this, a sample test message and the ECDS P512 signature generated
 *	    on the message hash by openssl is also included as a binary blob.
 *	    The goal of this test is to take use the public key from the ECDSA
 *	    key and verify that the signature is a valid signature. While the
 *	    crypto driver does provide apis to generate the signature, it won't
 *	    be possible to match the signature with the openssl signature,
 *	    because the signature generation take a random number as an input
 *	    and it is not possible to retrieve this random number from openssl.
 *	    Hence only verification is tested.
 */
static void ecdsa_p521_openssl_sign_brcm_verify(void)
{
	BCM_SCAPI_STATUS status;
	u8_t *pub_key = (u8_t *)&pub_key_ecdsa_p521_start;

	u32_t size;
	u8_t *msg = &test_message;

	u32_t A[ECDSA_521_PARAM_SIZE_WORDS], B[ECDSA_521_PARAM_SIZE_WORDS],
	      p[ECDSA_521_PARAM_SIZE_WORDS], n[ECDSA_521_PARAM_SIZE_WORDS],
	      GX[ECDSA_521_PARAM_SIZE_WORDS], GY[ECDSA_521_PARAM_SIZE_WORDS],
	      QZ[ECDSA_521_PARAM_SIZE_WORDS];

	u8_t *hash;
	u8_t sig_r[ECDSA_521_SIGN_SIZE_BYTES] = {0};
	u8_t sig_s[ECDSA_521_SIGN_SIZE_BYTES] = {0};

	/* The size for keys (QX, QY) and signature needs to be a multiple of
	 * 4 bytes and the leading bytes needs to be zeroed as the value may not
	 * always be 66 bytes (BIT_TO_BYTE(521))
	 */
	u8_t pub_k_x[ECDSA_521_KEY_SIZE_BYTES] = {0};
	u8_t pub_k_y[ECDSA_521_KEY_SIZE_BYTES] = {0};

	/* Ignore the first 0x4 in public key (if present) */
	if (pub_key[0] == 0x04)
		pub_key++;

	/* Get P-521 Curve params */
	get_ec_p521_params(A, B, p, n, GX, GY);
	memset(QZ, 0, sizeof(QZ));
	QZ[0] = 0x00000001;

	hash = cache_line_aligned_alloc(SHA_512_HASH_SIZE);
	zassert_not_null(hash, "Out of memory!");

	/* Initalize crypto */
	init_crypto();
	size = (u32_t)&test_message_end - (u32_t)&test_message;

	/* Generate the SHA512 hash for the test message:
	 * Openssl does not support sign/verify with SHA3-512 hash
	 * and brcm crypto hw dose not support SHA2-512 hash generation.
	 * So we use the sw implementation of SHA2-512 hash to match
	 * open ssl output.
	 */
	SHA512(msg, size, hash);
	dump_array(hash, SHA_512_HASH_SIZE, "SHA512 Hash");

	/* Verify openssl signature (all params need to be reversed */
	secure_memrev(sig_r, &ecdsa_p521_sign_r_start, ECDSA_P521_SIGN_R_SIZE);
	secure_memrev(sig_s, &ecdsa_p521_sign_s_start, ECDSA_P521_SIGN_S_SIZE);
	/* QX, QY need to be seprately reversed in the public key */
	secure_memrev(pub_k_x, pub_key, PUB_KEY_ECDSA_P521_SIZE / 2);
	secure_memrev(pub_k_y, pub_key + PUB_KEY_ECDSA_P521_SIZE / 2,
		      PUB_KEY_ECDSA_P521_SIZE / 2);
	secure_memrev(hash, hash, SHA_512_HASH_SIZE);

	/* The curve params need to be given in reverse (word wise) LSW first */
	memrev_word(A, A, WORD_SIZE(A));
	memrev_word(B, B, WORD_SIZE(B));
	memrev_word(p, p, WORD_SIZE(p));
	memrev_word(n, n, WORD_SIZE(n));
	memrev_word(GX, GX, WORD_SIZE(GX));
	memrev_word(GY, GY, WORD_SIZE(GY));

	status = crypto_pka_ecp_ecdsa_verify((crypto_lib_handle *)cryptoHandle,
			hash, SHA_512_HASH_SIZE, 0, /* Type - Prime field */
			(u8_t *)p, ECDSA_521_BITLEN,
			(u8_t *)A, (u8_t *)B, (u8_t *)n,
			(u8_t *)GX, (u8_t *)GY,
			pub_k_x, pub_k_y, (u8_t *)QZ,
			sig_r, sig_s,
			NULL, NULL);

	zassert_equal(status, BCM_SCAPI_STATUS_OK, "ECDSA Verify failed!");

	cache_line_aligned_free(hash);
}

/*
 * @brief Verify BRCM API generated ECDSA P-521 signature with openssl
 * @details In this test, the private/public key pair used is generated by
 *	    brcm api. The sample message is signed by the private key
 *	    generated and the signature and the public key are emitted to the
 *	    console in ASN1 syntax. The tester is expected to convert this
 *	    to a .der file and verify the signature using the public key
 *	    through openssl commands.
 */
static void ecdsa_p521_brcm_sign_openssl_verify(void)
{
	u32_t i;
	BCM_SCAPI_STATUS status;
	u8_t priv_key[ECDSA_521_KEY_SIZE_BYTES];

	u32_t size, sig_size;
	u8_t *msg = &test_message;

	u32_t A[ECDSA_521_PARAM_SIZE_WORDS], B[ECDSA_521_PARAM_SIZE_WORDS],
	      p[ECDSA_521_PARAM_SIZE_WORDS], n[ECDSA_521_PARAM_SIZE_WORDS],
	      GX[ECDSA_521_PARAM_SIZE_WORDS], GY[ECDSA_521_PARAM_SIZE_WORDS],
	      k[ECDSA_521_PARAM_SIZE_WORDS];

	u8_t *hash;
	u8_t sig_r[ECDSA_521_SIGN_SIZE_BYTES];
	u8_t sig_s[ECDSA_521_SIGN_SIZE_BYTES];

	u8_t pub_k_x[ECDSA_521_KEY_SIZE_BYTES];
	u8_t pub_k_y[ECDSA_521_KEY_SIZE_BYTES];

	/* Get P-521 Curve params */
	get_ec_p521_params(A, B, p, n, GX, GY);

	hash = cache_line_aligned_alloc(SHA_512_HASH_SIZE);
	zassert_not_null(hash, "Out of memory!");

	/* Initalize crypto */
	init_crypto();
	size = (u32_t)&test_message_end - (u32_t)&test_message;

	/* Generate the SHA512 hash for the test message:
	 * Openssl does not support sign/verify with SHA3-512 hash
	 * and brcm crypto hw dose not support SHA2-512 hash generation.
	 * So we use the sw implementation of SHA2-512 hash to match
	 * open ssl output.
	 */
	SHA512(msg, size, hash);
	dump_array(hash, SHA_512_HASH_SIZE, "SHA512 Hash");

	/* Generate the keys (Word reverse all key params) */
	memrev_word(A, A, WORD_SIZE(A));
	memrev_word(B, B, WORD_SIZE(B));
	memrev_word(p, p, WORD_SIZE(p));
	memrev_word(n, n, WORD_SIZE(n));
	memrev_word(GX, GX, WORD_SIZE(GX));
	memrev_word(GY, GY, WORD_SIZE(GY));
	status = crypto_pka_ecp_ecdsa_key_generate(
				(crypto_lib_handle *)cryptoHandle,
				0, /* Type - Prime field */
				(u8_t *)p, ECDSA_521_BITLEN,
				(u8_t *)A, (u8_t *)B, (u8_t *)n,
				(u8_t *)GX, (u8_t *)GY,
				priv_key, 0, /* Generate private key */
				pub_k_x,
				pub_k_y,
				NULL, NULL);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "ECDSA P521 Key gen failed");

	/* Sign the hash (Reverse hash only, Private/Public keys are already
	 * reversed)
	 */
	secure_memrev(hash, hash, SHA_512_HASH_SIZE);
	status = crypto_pka_ecp_ecdsa_sign((crypto_lib_handle *)cryptoHandle,
			hash, SHA_512_HASH_SIZE, 0, /* Type - Prime Field */
			(u8_t *)p, ECDSA_521_BITLEN, /* P length in bits */
			(u8_t *)A, (u8_t *)B, (u8_t *)n,
			(u8_t *)GX, (u8_t *)GY,
			(u8_t *)k, 0, /* K invalid */
			priv_key,
			sig_r, sig_s,
			NULL, NULL);

	/* Verify brcm signature with brcm verify api - redundant check
	 * but it verifies the correctness anyway
	 */
	u32_t QZ[ECDSA_521_PARAM_SIZE_WORDS];
	memset(QZ, 0, sizeof(QZ));
	QZ[0] = 0x1;
	status = crypto_pka_ecp_ecdsa_verify((crypto_lib_handle *)cryptoHandle,
			hash, SHA_512_HASH_SIZE, 0, /* Type - Prime field */
			(u8_t *)p, ECDSA_521_BITLEN,
			(u8_t *)A, (u8_t *)B, (u8_t *)n,
			(u8_t *)GX, (u8_t *)GY,
			pub_k_x, pub_k_y, (u8_t *)QZ,
			sig_r, sig_s,
			NULL, NULL);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "ECDSA Verify failed!");

	/* Dump the public key and Signature to console */
	/* Reverse the private/public key (X, Y), signature (R,S) and re-reverse
	 * the hash
	 */
	secure_memrev(hash, hash, SHA_512_HASH_SIZE);
	secure_memrev(priv_key, priv_key, sizeof(priv_key)); /* D */
	secure_memrev(pub_k_x, pub_k_x, sizeof(pub_k_x)); /* QX */
	secure_memrev(pub_k_y, pub_k_y, sizeof(pub_k_y)); /* QY */

	secure_memrev(sig_r, sig_r, sizeof(sig_r));
	secure_memrev(sig_s, sig_s, sizeof(sig_s));

	dump_array(sig_r, sizeof(sig_r), "Signature (R)");
	dump_array(sig_s, sizeof(sig_s), "Signature (S)");
	dump_array(priv_key, sizeof(priv_key), "Private Key");
	dump_array(pub_k_x, sizeof(pub_k_x), "Public Key (QX)");
	dump_array(pub_k_y, sizeof(pub_k_y), "Public Key (QY)");
	dump_array(hash, SHA_512_HASH_SIZE, "Hash");
	secure_memrev((u8_t *)k, (u8_t *)k, sizeof(k));
	dump_array(k, sizeof(k), "Random number");

	/* Commands to create the public key file (DER) */
	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to create public key\n# --------------\n");
	TC_PRINT("echo \"3081dc0201010442\n");
	for (i = 2; i < sizeof(priv_key); i++) {
		TC_PRINT("%02X", priv_key[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("a00706052b81040023a181890381860004\n");
	for (i = 2; i < sizeof(pub_k_x); i++) {
		TC_PRINT("%02X", pub_k_x[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	for (i = 2; i < sizeof(pub_k_y); i++) {
		TC_PRINT("%02X", pub_k_y[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("\" | xxd -r -p > brcm_priv_key_ecdsa_p521.der\n");
	TC_PRINT("openssl ec -inform DER -in brcm_priv_key_ecdsa_p521.der \\\n"
		 "-pubout -out brcm_pub_key_ecdsa_p521.pem\n");
	TC_PRINT("#######################################\n");

	/* Commands to create the signature file (DER) */
	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to create signature file\n# --------------\n");
	sig_size = 0x88;
	sig_size += (sig_r[2] >> 7) + (sig_s[2] >> 7);
	if ((sig_r[2] == 0x0) && ((sig_r[3] >> 7) == 0)) sig_size--;
	if ((sig_s[2] == 0x0) && ((sig_s[3] >> 7) == 0)) sig_size--;
	TC_PRINT("echo \"3081%02X\n", sig_size);
	/* SIG R */
	i = 2; /* 66 of 68 bytes needed (i=2) */
	if (sig_r[2] & 0x80) {
		TC_PRINT("024300\n");
	} else if ((sig_r[2] == 0x0) && ((sig_r[3] >> 7) == 0)) {
		TC_PRINT("0241\n");
		i++;
	} else
		TC_PRINT("0242\n");
	for (; i < sizeof(sig_r); i++) {
		TC_PRINT("%02x", sig_r[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	/* SIG S */
	i = 2; /* 66 of 68 bytes needed (i=2) */
	if (sig_s[2] & 0x80) {
		TC_PRINT("024300\n");
	} else if ((sig_s[2] == 0x0) && ((sig_s[3] >> 7) == 0)) {
		TC_PRINT("0241\n");
		i++;
	} else
		TC_PRINT("0242\n");
	for (; i < sizeof(sig_s); i++) {
		TC_PRINT("%02x", sig_s[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("\" | xxd -r -p > sign_ecdsa_p521.der\n");
	TC_PRINT("#######################################\n");

	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to verify the ECDSA signature\n# --------------\n");
	TC_PRINT("openssl dgst -sha512 -verify brcm_pub_key_ecdsa_p521.pem \\\n"
		 "-signature sign_ecdsa_p521.der test_message.txt\n");
	TC_PRINT("#######################################\n");
	TC_PRINT("[MANUAL MODE]: Run the above commands on a linux server"
		 "to verify the ECDSA P521 signature\n");
	k_sleep(3000);

	cache_line_aligned_free(hash);
}

/*****************************************/
/************** ECDSA P384 ***************/
/*****************************************/
/* Generated with the following openssl commands
 * openssl ecparam -genkey -name secp384r1 -noout \
 *	-out private_key_ecdsa_p384.pem
 * openssl ec -in private_key_ecdsa_p384.pem -noout -text 2>&1 | \
 *	sed -n '/priv:/,/pub:/{//!p}' | \
 *	sed -E 's/:/ /g' | \
 *	xxd -r -p > private_key_ecdsa_p384.bin
 */
#define PRIV_KEY_ECDSA_P384 "keys/private_key_ecdsa_p384.bin"
/* Generated with the following openssl commands
 * openssl ec -in private_key_ecdsa_p384.pem -pubout \
 *	-out public_key_ecdsa_p384.pem
 * openssl ec -in public_key_ecdsa_p384.pem -pubin -noout -text 2>&1 | \
 *	sed -n '/pub:/,/ASN1/{//!p}' | \
 *	sed -E 's/:/ /g' | \
 *	xxd -r -p > public_key_ecdsa_p384.bin
 */
#define PUB_KEY_ECDSA_P384 "keys/public_key_ecdsa_p384.bin"
/* Generated with the following openssl command
 * openssl dgst -sha384 -sign private_key_ecdsa_p384.pem \
 *	-out signature_ecdsa_p384.bin test_message.txt
 * openssl asn1parse -inform DER -in signature_ecdsa_p384.bin | \
 *	grep INTEGER | cut -d":" -f4 | head -1 | \
 *	xxd -r -p > ecdsa_p384_sig_r.bin
 * openssl asn1parse -inform DER -in signature_ecdsa_p384.bin | \
 *	grep INTEGER | cut -d":" -f4 | tail -1 | \
 *	xxd -r -p > ecdsa_p384_sig_s.bin
 */
#define ECDSA_P384_SIGN_R_FILE	"keys/ecdsa_p384_sig_r.bin"
#define ECDSA_P384_SIGN_S_FILE	"keys/ecdsa_p384_sig_s.bin"

/* ECDSA Private key (P384) */
extern uint8_t priv_key_ecdsa_p384_start;
extern uint8_t priv_key_ecdsa_p384_end;
__asm__ (
	".section \".data.priv_key_ecdsa_p384_start\"\n"
	"priv_key_ecdsa_p384_start:\n"
	"   .incbin \"" PATH_TO_KEYS PRIV_KEY_ECDSA_P384 "\"\n"
	"priv_key_ecdsa_p384_end:" /* To get the file size */
);

/* ECDSA Public key (P384) */
extern uint8_t pub_key_ecdsa_p384_start;
extern uint8_t pub_key_ecdsa_p384_end;
__asm__ (
	".section \".data.pub_key_ecdsa_p384_start\"\n"
	"pub_key_ecdsa_p384_start:\n"
	"   .incbin \"" PATH_TO_KEYS PUB_KEY_ECDSA_P384 "\"\n"
	"pub_key_ecdsa_p384_end:" /* To get the file size */
);
/* -1 to ignore the first byte (0x4) in the public key */
#define PUB_KEY_ECDSA_P384_SIZE	\
	((u32_t)&pub_key_ecdsa_p384_end - (u32_t)&pub_key_ecdsa_p384_start - 1)

/* ECDSA Signature (r) (P384) */
extern uint8_t ecdsa_p384_sign_r_start;
extern uint8_t ecdsa_p384_sign_r_end;
__asm__ (
	"ecdsa_p384_sign_r_start:\n"
	"   .incbin \"" PATH_TO_KEYS ECDSA_P384_SIGN_R_FILE "\"\n"
	"ecdsa_p384_sign_r_end:" /* To get the file size */
);
#define ECDSA_P384_SIGN_R_SIZE	\
	((u32_t)&ecdsa_p384_sign_r_end - (u32_t)&ecdsa_p384_sign_r_start)

/* ECDSA Signature (s) (P384) */
extern uint8_t ecdsa_p384_sign_s_start;
extern uint8_t ecdsa_p384_sign_s_end;
__asm__ (
	"ecdsa_p384_sign_s_start:\n"
	"   .incbin \"" PATH_TO_KEYS ECDSA_P384_SIGN_S_FILE "\"\n"
	"ecdsa_p384_sign_s_end:" /* To get the file size */
);
#define ECDSA_P384_SIGN_S_SIZE	\
	((u32_t)&ecdsa_p384_sign_s_end - (u32_t)&ecdsa_p384_sign_s_start)

static void get_ec_p384_params(u32_t *A, u32_t *B, u32_t *p, u32_t *n,
			       u32_t *GX, u32_t *GY)
{
	/* ECC curve vectors from FIPS 186-2-change1.pdf, Page 29, Curve P-384,
	and represented here in BIGNUM format */

	A[0] = 0xFFFFFFFF;
	A[1] = 0xFFFFFFFF;
	A[2] = 0xFFFFFFFF;
	A[3] = 0xFFFFFFFF;
	A[4] = 0xFFFFFFFF;
	A[5] = 0xFFFFFFFF;
	A[6] = 0xFFFFFFFF;
	A[7] = 0xFFFFFFFE;
	A[8] = 0xFFFFFFFF;
	A[9] = 0x00000000;
	A[10] = 0x00000000;
	A[11] = 0xFFFFFFFC;

	B[0] = 0xB3312FA7;
	B[1] = 0xE23EE7E4;
	B[2] = 0x988E056B;
	B[3] = 0xE3F82D19;
	B[4] = 0x181D9C6E;
	B[5] = 0xFE814112;
	B[6] = 0x0314088F;
	B[7] = 0x5013875A;
	B[8] = 0xC656398D;
	B[9] = 0x8A2ED19D;
	B[10] = 0x2A85C8ED;
	B[11] = 0xD3EC2AEF;

	GX[0] = 0xAA87CA22;
	GX[1] = 0xBE8B0537;
	GX[2] = 0x8EB1C71E;
	GX[3] = 0xF320AD74;
	GX[4] = 0x6E1D3B62;
	GX[5] = 0x8BA79B98;
	GX[6] = 0x59F741E0;
	GX[7] = 0x82542A38;
	GX[8] = 0x5502F25D;
	GX[9] = 0xBF55296C;
	GX[10] = 0x3A545E38;
	GX[11] = 0x72760AB7;

	GY[0] = 0x3617DE4A;
	GY[1] = 0x96262C6F;
	GY[2] = 0x5D9E98BF;
	GY[3] = 0x9292DC29;
	GY[4] = 0xF8F41DBD;
	GY[5] = 0x289A147C;
	GY[6] = 0xE9DA3113;
	GY[7] = 0xB5F0B8C0;
	GY[8] = 0x0A60B1CE;
	GY[9] = 0x1D7E819D;
	GY[10] = 0x7A431D7C;
	GY[11] = 0x90EA0E5F;

	p[0] = 0xFFFFFFFF;
	p[1] = 0xFFFFFFFF;
	p[2] = 0xFFFFFFFF;
	p[3] = 0xFFFFFFFF;
	p[4] = 0xFFFFFFFF;
	p[5] = 0xFFFFFFFF;
	p[6] = 0xFFFFFFFF;
	p[7] = 0xFFFFFFFE;
	p[8] = 0xFFFFFFFF;
	p[9] = 0x00000000;
	p[10] = 0x00000000;
	p[11] = 0xFFFFFFFF;

	n[0] = 0xFFFFFFFF;
	n[1] = 0xFFFFFFFF;
	n[2] = 0xFFFFFFFF;
	n[3] = 0xFFFFFFFF;
	n[4] = 0xFFFFFFFF;
	n[5] = 0xFFFFFFFF;
	n[6] = 0xC7634D81;
	n[7] = 0xF4372DDF;
	n[8] = 0x581A0DB2;
	n[9] = 0x48B0A77A;
	n[10] = 0xECEC196A;
	n[11] = 0xCCC52973;
}

#define ECDSA_384_BITLEN           384
#define ECDSA_384_PARAM_SIZE_WORDS BIT_TO_WORD(ECDSA_384_BITLEN)
#define ECDSA_384_SIGN_SIZE_BYTES (BIT_TO_WORD(ECDSA_384_BITLEN)*sizeof(u32_t))
#define ECDSA_384_KEY_SIZE_BYTES  (BIT_TO_WORD(ECDSA_384_BITLEN)*sizeof(u32_t))
/*
 * @brief Verify Openssl generated ECDSA P-384 signature with brcm api
 * @details In this test, the private/public key pair used is generated by
 *	    openssl and included in to the test as binary blobs. In addition
 *	    to this, a sample test message and the ECDS P384 signature generated
 *	    on the message hash by openssl is also included as a binary blob.
 *	    The goal of this test is to take use the public key from the ECDSA
 *	    key and verify that the signature is a valid signature. While the
 *	    crypto driver does provide apis to generate the signature, it won't
 *	    be possible to match the signature with the openssl signature,
 *	    because the signature generation take a random number as an input
 *	    and it is not possible to retrieve this random number from openssl.
 *	    Hence only verification is tested.
 */
static void ecdsa_p384_openssl_sign_brcm_verify(void)
{
	BCM_SCAPI_STATUS status;
	u8_t *pub_key = (u8_t *)&pub_key_ecdsa_p384_start;

	u32_t size;
	u8_t *msg = &test_message;

	u32_t A[ECDSA_384_PARAM_SIZE_WORDS], B[ECDSA_384_PARAM_SIZE_WORDS],
	      p[ECDSA_384_PARAM_SIZE_WORDS], n[ECDSA_384_PARAM_SIZE_WORDS],
	      GX[ECDSA_384_PARAM_SIZE_WORDS], GY[ECDSA_384_PARAM_SIZE_WORDS],
	      QZ[ECDSA_384_PARAM_SIZE_WORDS];

	u8_t *hash;
	u8_t sig_r[ECDSA_384_SIGN_SIZE_BYTES] = {0};
	u8_t sig_s[ECDSA_384_SIGN_SIZE_BYTES] = {0};
	u8_t pub_k_x[ECDSA_384_KEY_SIZE_BYTES] = {0};
	u8_t pub_k_y[ECDSA_384_KEY_SIZE_BYTES] = {0};

	/* Ignore the first 0x4 in public key (if present) */
	if (pub_key[0] == 0x04)
		pub_key++;

	/* Get P-384 Curve params */
	get_ec_p384_params(A, B, p, n, GX, GY);
	memset(QZ, 0, sizeof(QZ));
	QZ[0] = 0x00000001;

	hash = cache_line_aligned_alloc(SHA3_384_HASH_SIZE);
	zassert_not_null(hash, "Out of memory!");

	/* Initalize crypto */
	init_crypto();
	size = (u32_t)&test_message_end - (u32_t)&test_message;

	/* Generate the SHA384 hash for the test message:
	 * Openssl does not support sign/verify with SHA3-384 hash
	 * and brcm crypto hw dose not support SHA2-384 hash generation.
	 * So we use the sw implementation of SHA2-384 hash to match
	 * open ssl output.
	 */
	SHA384(msg, size, hash);
	dump_array(hash, SHA3_384_HASH_SIZE, "SHA384 Hash");

	/* Verify openssl signature (all params need to be reversed */
	secure_memrev(sig_r, &ecdsa_p384_sign_r_start, ECDSA_P384_SIGN_R_SIZE);
	secure_memrev(sig_s, &ecdsa_p384_sign_s_start, ECDSA_P384_SIGN_S_SIZE);
	/* QX, QY need to be seprately reversed in the public key */
	secure_memrev(pub_k_x, pub_key, PUB_KEY_ECDSA_P384_SIZE / 2);
	secure_memrev(pub_k_y, pub_key + PUB_KEY_ECDSA_P384_SIZE / 2,
		      PUB_KEY_ECDSA_P384_SIZE / 2);
	secure_memrev(hash, hash, SHA3_384_HASH_SIZE);

	/* The curve params need to be given in reverse (word wise) LSW first */
	memrev_word(A, A, WORD_SIZE(A));
	memrev_word(B, B, WORD_SIZE(B));
	memrev_word(p, p, WORD_SIZE(p));
	memrev_word(n, n, WORD_SIZE(n));
	memrev_word(GX, GX, WORD_SIZE(GX));
	memrev_word(GY, GY, WORD_SIZE(GY));
	status = crypto_pka_ecp_ecdsa_verify((crypto_lib_handle *)cryptoHandle,
			hash, SHA3_384_HASH_SIZE, 0, /* Type - Prime field */
			(u8_t *)p, ECDSA_384_BITLEN,
			(u8_t *)A, (u8_t *)B, (u8_t *)n,
			(u8_t *)GX, (u8_t *)GY,
			pub_k_x, pub_k_y, (u8_t *)QZ,
			sig_r, sig_s,
			NULL, NULL);

	zassert_equal(status, BCM_SCAPI_STATUS_OK, "ECDSA Verify failed!");

	cache_line_aligned_free(hash);
}

/*
 * @brief Verify BRCM API generated ECDSA P-384 signature with openssl
 * @details In this test, the private/public key pair used is generated by
 *	    brcm api. The sample message is signed by the private key
 *	    generated and the signature and the public key are emitted to the
 *	    console in ASN1 syntax. The tester is expected to convert this
 *	    to a .der file and verify the signature using the public key
 *	    through openssl commands.
 */
static void ecdsa_p384_brcm_sign_openssl_verify(void)
{
	u32_t i, size;
	BCM_SCAPI_STATUS status;
	u8_t priv_key[ECDSA_384_KEY_SIZE_BYTES];

	u8_t *msg = &test_message;

	u32_t A[ECDSA_384_PARAM_SIZE_WORDS], B[ECDSA_384_PARAM_SIZE_WORDS],
	      p[ECDSA_384_PARAM_SIZE_WORDS], n[ECDSA_384_PARAM_SIZE_WORDS],
	      GX[ECDSA_384_PARAM_SIZE_WORDS], GY[ECDSA_384_PARAM_SIZE_WORDS],
	      k[ECDSA_384_PARAM_SIZE_WORDS];

	u8_t *hash;
	u8_t sig_r[ECDSA_384_SIGN_SIZE_BYTES];
	u8_t sig_s[ECDSA_384_SIGN_SIZE_BYTES];

	u8_t pub_k_x[ECDSA_384_KEY_SIZE_BYTES];
	u8_t pub_k_y[ECDSA_384_KEY_SIZE_BYTES];

	/* Get P-384 Curve params */
	get_ec_p384_params(A, B, p, n, GX, GY);

	hash = cache_line_aligned_alloc(SHA3_384_HASH_SIZE);
	zassert_not_null(hash, "Out of memory!");

	/* Initalize crypto */
	init_crypto();
	size = (u32_t)&test_message_end - (u32_t)&test_message;

	/* Generate the SHA384 hash for the test message:
	 * Openssl does not support sign/verify with SHA3-384 hash
	 * and brcm crypto hw dose not support SHA2-384 hash generation.
	 * So we use the sw implementation of SHA2-384 hash to match
	 * open ssl output.
	 */
	SHA384(msg, size, hash);
	dump_array(hash, SHA3_384_HASH_SIZE, "SHA384 Hash");

	/* Generate the keys (Word reverse all key params) */
	memrev_word(A, A, WORD_SIZE(A));
	memrev_word(B, B, WORD_SIZE(B));
	memrev_word(p, p, WORD_SIZE(p));
	memrev_word(n, n, WORD_SIZE(n));
	memrev_word(GX, GX, WORD_SIZE(GX));
	memrev_word(GY, GY, WORD_SIZE(GY));
	status = crypto_pka_ecp_ecdsa_key_generate(
				(crypto_lib_handle *)cryptoHandle,
				0, /* Type - Prime field */
				(u8_t *)p, ECDSA_384_BITLEN,
				(u8_t *)A, (u8_t *)B, (u8_t *)n,
				(u8_t *)GX, (u8_t *)GY,
				priv_key, 0, /* Generate private key */
				pub_k_x,
				pub_k_y,
				NULL, NULL);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "ECDSA P384 Key gen failed");

	/* Sign the hash (Reverse hash only, Private/Public keys are already
	 * reversed)
	 */
	secure_memrev(hash, hash, SHA3_384_HASH_SIZE);
	status = crypto_pka_ecp_ecdsa_sign((crypto_lib_handle *)cryptoHandle,
			hash, SHA3_384_HASH_SIZE, 0, /* Type - Prime Field */
			(u8_t *)p, ECDSA_384_BITLEN, /* P length in bits */
			(u8_t *)A, (u8_t *)B, (u8_t *)n,
			(u8_t *)GX, (u8_t *)GY,
			(u8_t *)k, 0, /* K invalid */
			priv_key,
			sig_r, sig_s,
			NULL, NULL);

	/* Verify brcm signature with brcm verify api - redundant check
	 * but it verifies the correctness anyway
	 */
	u32_t QZ[ECDSA_384_PARAM_SIZE_WORDS];
	memset(QZ, 0, sizeof(QZ));
	QZ[0] = 0x1;
	status = crypto_pka_ecp_ecdsa_verify((crypto_lib_handle *)cryptoHandle,
			hash, SHA3_384_HASH_SIZE, 0, /* Type - Prime field */
			(u8_t *)p, ECDSA_384_BITLEN,
			(u8_t *)A, (u8_t *)B, (u8_t *)n,
			(u8_t *)GX, (u8_t *)GY,
			pub_k_x, pub_k_y, (u8_t *)QZ,
			sig_r, sig_s,
			NULL, NULL);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "ECDSA Verify failed!");

	/* Dump the public key and Signature to console */
	/* Reverse the private/public key (X, Y), signature (R,S) and re-reverse
	 * the hash
	 */
	secure_memrev(hash, hash, SHA3_384_HASH_SIZE);
	secure_memrev(priv_key, priv_key, sizeof(priv_key)); /* D */
	secure_memrev(pub_k_x, pub_k_x, sizeof(pub_k_x)); /* QX */
	secure_memrev(pub_k_y, pub_k_y, sizeof(pub_k_y)); /* QY */

	secure_memrev(sig_r, sig_r, sizeof(sig_r));
	secure_memrev(sig_s, sig_s, sizeof(sig_s));

	dump_array(sig_r, sizeof(sig_r), "Signature (R)");
	dump_array(sig_s, sizeof(sig_s), "Signature (S)");
	dump_array(priv_key, sizeof(priv_key), "Private Key");
	dump_array(pub_k_x, sizeof(pub_k_x), "Public Key (QX)");
	dump_array(pub_k_y, sizeof(pub_k_y), "Public Key (QY)");
	dump_array(hash, SHA3_384_HASH_SIZE, "Hash");
	secure_memrev((u8_t *)k, (u8_t *)k, sizeof(k));
	dump_array(k, sizeof(k), "Random number");

	/* Commands to create the public key file (DER) */
	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to create public key\n# --------------\n");
	TC_PRINT("echo \"3081a40201010430\n");
	for (i = 0; i < sizeof(priv_key); i++) {
		TC_PRINT("%02X", priv_key[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("a00706052b81040022a16403620004\n");
	for (i = 0; i < sizeof(pub_k_x); i++) {
		TC_PRINT("%02X", pub_k_x[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	for (i = 0; i < sizeof(pub_k_y); i++) {
		TC_PRINT("%02X", pub_k_y[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("\" | xxd -r -p > brcm_priv_key_ecdsa_p384.der\n");
	TC_PRINT("openssl ec -inform DER -in brcm_priv_key_ecdsa_p384.der \\\n"
		 "-pubout -out brcm_pub_key_ecdsa_p384.pem\n");
	TC_PRINT("#######################################\n");

	/* Commands to create the signature file (DER) */
	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to create signature file\n# --------------\n");
	TC_PRINT("echo \"30\n");
	/* To prefix extra 0x00 if the first bit is '1' */
	TC_PRINT("%x\n", 0x64 + (sig_r[0] >> 7) + (sig_s[0] >> 7));
	TC_PRINT("02%s\n", (sig_r[0] & 0x80) ? "3100" : "30");
	/* SIG R */
	for (i = 0; i < sizeof(sig_r); i++) {
		TC_PRINT("%02x", sig_r[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	/* SIG S */
	TC_PRINT("02%s\n", (sig_s[0] & 0x80) ? "3100" : "30");
	for (i = 0; i < sizeof(sig_s); i++) {
		TC_PRINT("%02x", sig_s[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("\" | xxd -r -p > sign_ecdsa_p384.der\n");
	TC_PRINT("#######################################\n");

	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to verify the ECDSA signature\n# --------------\n");
	TC_PRINT("openssl dgst -sha384 -verify brcm_pub_key_ecdsa_p384.pem \\\n"
		 "-signature sign_ecdsa_p384.der test_message.txt\n");
	TC_PRINT("#######################################\n");
	TC_PRINT("[MANUAL MODE]: Run the above commands on a linux server"
		 "to verify the ECDSA P384 signature\n");
	k_sleep(3000);

	cache_line_aligned_free(hash);
}


/*****************************************/
/************** ECDH P384 ***************/
/*****************************************/
/* Generated with the following openssl commands
 * openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:P-384 \
 *	-pkeyopt ec_param_enc:named_curve > openssl_dhk_p384.pem
 * openssl ec -in openssl_dhk_p384.pem -pubout -noout -text 2>&1 | \
 *	sed -n '/pub:/,/ASN1/{//!p}' | \
 *	sed -E 's/:/ /g' | \
 *	xxd -r -p > openssl_dhpubk_p384.bin
 */
#define PUB_KEY_ECDH_P384 "keys/openssl_dhpubk_p384.bin"

/* ECDSA Public key (P384) */
extern uint8_t pub_key_ecdh_p384_start;
extern uint8_t pub_key_ecdh_p384_end;
__asm__ (
	".section \".data.pub_key_ecdh_p384_start\"\n"
	"pub_key_ecdh_p384_start:\n"
	"   .incbin \"" PATH_TO_KEYS PUB_KEY_ECDH_P384 "\"\n"
	"pub_key_ecdh_p384_end:" /* To get the file size */
);
/* -1 to ignore the first byte (0x4) in the public key */
#define PUB_KEY_ECDH_P384_SIZE	\
	((u32_t)&pub_key_ecdh_p384_end - (u32_t)&pub_key_ecdh_p384_start - 1)

void ecdh_p384_match_shared_secret(void)
{
	u32_t i;
	BCM_SCAPI_STATUS status;
	u8_t priv_key[ECDSA_384_KEY_SIZE_BYTES];
	u8_t shared_secret[ECDSA_384_KEY_SIZE_BYTES];
	u8_t shared_secret_y[ECDSA_384_KEY_SIZE_BYTES];

	u8_t *openssl_pubkey_x, *openssl_pubkey_y;

	u32_t A[ECDSA_384_PARAM_SIZE_WORDS], B[ECDSA_384_PARAM_SIZE_WORDS],
	      p[ECDSA_384_PARAM_SIZE_WORDS], n[ECDSA_384_PARAM_SIZE_WORDS],
	      GX[ECDSA_384_PARAM_SIZE_WORDS], GY[ECDSA_384_PARAM_SIZE_WORDS];

	u8_t pub_k_x[ECDSA_384_KEY_SIZE_BYTES];
	u8_t pub_k_y[ECDSA_384_KEY_SIZE_BYTES];

	/* Initalize crypto */
	init_crypto();

	openssl_pubkey_x = &pub_key_ecdh_p384_start;
	/* Ignore the first 0x4 in public key (if present) */
	if (openssl_pubkey_x[0] == 0x04)
		openssl_pubkey_x++;
	openssl_pubkey_y = openssl_pubkey_x + PUB_KEY_ECDH_P384_SIZE/2;

	/* Get P-384 Curve params */
	get_ec_p384_params(A, B, p, n, GX, GY);

	/* Generate the keys (Word reverse all key params) */
	memrev_word(A, A, WORD_SIZE(A));
	memrev_word(B, B, WORD_SIZE(B));
	memrev_word(p, p, WORD_SIZE(p));
	memrev_word(n, n, WORD_SIZE(n));
	memrev_word(GX, GX, WORD_SIZE(GX));
	memrev_word(GY, GY, WORD_SIZE(GY));
	status = crypto_pka_ecp_ecdsa_key_generate(
				(crypto_lib_handle *)cryptoHandle,
				0, /* Type - Prime field */
				(u8_t *)p, ECDSA_384_BITLEN,
				(u8_t *)A, (u8_t *)B, (u8_t *)n,
				(u8_t *)GX, (u8_t *)GY,
				priv_key, 0, /* Generate private key */
				pub_k_x,
				pub_k_y,
				NULL, NULL);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "ECDH P384 Key gen failed");

	/* Reverse the openssl public key (X, Y) */
	secure_memrev(openssl_pubkey_x, openssl_pubkey_x,
		      ECDSA_384_KEY_SIZE_BYTES);
	secure_memrev(openssl_pubkey_y, openssl_pubkey_y,
		      ECDSA_384_KEY_SIZE_BYTES);

	/* Compute shared secret */
	status = crypto_pka_ecp_diffie_hellman_shared_secret(
				(crypto_lib_handle *)cryptoHandle,
				0, /* Type - Prime field */
				(u8_t*)(p), ECDSA_384_BITLEN,
				(u8_t*)(A), (u8_t*)(B), (u8_t*)(n),
				priv_key, openssl_pubkey_x,
				openssl_pubkey_y, shared_secret,
				shared_secret_y,
				NULL, NULL);
	zassert_equal(status, BCM_SCAPI_STATUS_OK, "Shared secret gen failed");

	/* Reverse the public and private key byte order (after shared secret
	 * generation, since the shared secret is generated using the byte
	 * order as generated by crypto_pka_ecp_ecdsa_key_generate())
	 */
	secure_memrev(priv_key, priv_key, sizeof(priv_key)); /* D */
	secure_memrev(pub_k_x, pub_k_x, sizeof(pub_k_x)); /* QX */
	secure_memrev(pub_k_y, pub_k_y, sizeof(pub_k_y)); /* QY */

	/* Reverse the secret to match openssl byte order */
	secure_memrev(shared_secret, shared_secret, sizeof(shared_secret));

	/* Dump shared secret and public key to console */
	/* Commands to create brcm shared secret file */
	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to create brcm shared secret\n# --------------\n");
	TC_PRINT("echo \"\n");
	for (i = 0; i < sizeof(shared_secret); i++) {
		TC_PRINT("%02x", shared_secret[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("\" | xxd -r -p > brcm_shared_secret.bin\n");
	TC_PRINT("#######################################\n");

	/* Commands to create the brcm public key file (DER) */
	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to brcm create public key\n# --------------\n");
	TC_PRINT("echo \"3081a40201010430\n");
	for (i = 0; i < sizeof(priv_key); i++) {
		TC_PRINT("%02X", priv_key[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("a00706052b81040022a16403620004\n");
	for (i = 0; i < sizeof(pub_k_x); i++) {
		TC_PRINT("%02X", pub_k_x[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	for (i = 0; i < sizeof(pub_k_y); i++) {
		TC_PRINT("%02X", pub_k_y[i]);
		if ((i & 0xF) == 0xF)
			TC_PRINT("\n");
	}
	TC_PRINT("\" | xxd -r -p > brcm_priv_key_ecdh_p384.der\n");
	TC_PRINT("openssl ec -inform DER -in brcm_priv_key_ecdh_p384.der \\\n"
		 "-pubout -out brcm_pub_key_ecdh_p384.pem\n");
	TC_PRINT("#######################################\n");

	TC_PRINT("\n#######################################\n");
	TC_PRINT("# Command to gen openssl shared secret\n# --------------\n");
	TC_PRINT("openssl pkeyutl -derive -inkey openssl_dhk_p384.pem \\\n"
		 "-peerkey brcm_pub_key_ecdh_p384.pem \\\n"
		 "-out openssl_shared_secret.bin\n");
	TC_PRINT("xxd openssl_shared_secret.bin\n");
	TC_PRINT("xxd brcm_shared_secret.bin\n");
	TC_PRINT("cmp --silent openssl_shared_secret.bin \\\n"
		 "brcm_shared_secret.bin\n");
	TC_PRINT("if [ \"$?\" == \"0\" ]\n");
	TC_PRINT("then echo 'Shared secrets match!!! TEST PASS'\n");
	TC_PRINT("else echo 'Shared secret DO NOT match!!! TEST FAIL'; fi \n");
	TC_PRINT("#######################################\n");
	TC_PRINT("[MANUAL MODE]: Run the above commands on a linux server"
		 "to verify the ECDH secret match\n");
	k_sleep(3000);
}

SHELL_TEST_DECLARE(test_openssl_pka)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	/* To get the tests to run faster */
	clk_a7_set(MHZ(1000));

	ztest_test_suite(openssl_tests,
		ztest_unit_test(rsa_2k_openssl_sign_brcm_verify),
		ztest_unit_test(rsa_2k_brcm_sign_openssl_verify),
		ztest_unit_test(ecdsa_p256_openssl_sign_brcm_verify),
		ztest_unit_test(ecdsa_p256_brcm_sign_openssl_verify),
		ztest_unit_test(ecdsa_p521_openssl_sign_brcm_verify),
		ztest_unit_test(ecdsa_p521_brcm_sign_openssl_verify),
		ztest_unit_test(ecdsa_p384_openssl_sign_brcm_verify),
		ztest_unit_test(ecdsa_p384_brcm_sign_openssl_verify),
		ztest_unit_test(ecdh_p384_match_shared_secret),
		ztest_unit_test(rsa_4k_key_gen));

	ztest_run_test_suite(openssl_tests);
	return 0;
}
