/******************************************************************************
 *  Copyright (C) 2017 Broadcom. The term "Broadcom" refers to Broadcom Limited
 *  and/or its subsidiaries.
 *
 *  This program is the proprietary software of Broadcom and/or its licensors,
 *  and may only be used, duplicated, modified or distributed pursuant to the
 *  terms and conditions of a separate, written license agreement executed
 *  between you and Broadcom (an "Authorized License").  Except as set forth in
 *  an Authorized License, Broadcom grants no license (express or implied),
 *  right to use, or waiver of any kind with respect to the Software, and
 *  Broadcom expressly reserves all rights in and to the Software and all
 *  intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE,
 *  THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD
 *  IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
 *
 *  Except as expressly set forth in the Authorized License,
 *
 *  1.     This program, including its structure, sequence and organization,
 *  constitutes the valuable trade secrets of Broadcom, and you shall use all
 *  reasonable efforts to protect the confidentiality thereof, and to use this
 *  information only in connection with your use of Broadcom integrated circuit
 *  products.
 *
 *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
 *  "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS
 *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH
 *  RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL
 *  IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A
 *  PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET
 *  ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE
 *  ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 *
 *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
 *  ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL,
 *  INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY
 *  RELATING TO YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
 *  HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN
 *  EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1,
 *  WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY
 *  FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
 ******************************************************************************/

/* @file crypto_selftest.c
 *
 * This file contains
 *
 *
 */
/* ***************************************************************************
 * Includes
 * ***************************************************************************/
#include <string.h>
#include <misc/printk.h>
#include <zephyr/types.h>
#include <crypto/crypto_rng.h>
#include <crypto/crypto.h>
#include <crypto/crypto_smau.h>
#include <pka/crypto_pka_util.h>
#include <crypto/crypto_symmetric.h>
#include <crypto/crypto_selftest.h>
#include <crypto/crypto_sw_utils.h>

/* ***************************************************************************
 * MACROS/Defines
 * ***************************************************************************/
#define CRYPTO_DEBUG
/* ***************************************************************************
 * Types/Structure Declarations
 * ***************************************************************************/

/* ***************************************************************************
 * Global and Static Variables
 * Total Size: NNNbytes
 * ***************************************************************************/

static u8_t data_enc[] = {
        0xd9,0x48,0x65,0x47,
        0x40,0xbd,0x19,0x24,
        0x65,0x7c,0x25,0x85,
        0x34,0x66,0xdf,0xc1,
        0x96,0x57,0xaf,0x14,
        0x57,0xc7,0xc3,0x6c,
        0x17,0x3,0xb8,0x82,
        0x32,0xca,0x49,0xb2,
        0xa,0x18,0xeb,0x37,
        0xdb,0xc6,0x91,0xf6,
        0xb9,0x83,0x30,0xc1,
        0x64,0xdf,0x4d,0x58,
        0x18,0x45,0x8d,0x13,
        0xff,0x2e,0x12,0x60,
        0xf6,0x4a,0xbd,0x3c,
        0x23,0xc6,0xee,0x2a,
        0x13,0x38,0x2b,0xc1,
        0x2e,0xf3,0x39,0xf6,
        0x1e,0x7,0x4c,0xc4,
        0xb7,0x84,0x26,0x10,
        0xae,0xa4,0x66,0x1c,
        0xa1,0xf4,0x3a,0x64,
        0x38,0x91,0xcf,0x1d,
        0xf3,0x76,0x14,0x12,
        0x1b,0xf9,0x30,0x2a,
        0xda,0x69,0x16,0xd3,
        0xab,0x48,0xee,0x9a,
        0x88,0x9e,0x93,0x65,
        0x17,0x7c,0xdb,0xe2,
        0xf7,0xe,0xb2,0x41,
        0x21,0xf0,0xe1,0xf4,
        0xe4,0x49,0xd2,0xb7
};


static u8_t data_in_2[] = {
        0xaf,0xbb,0x1f,0xb6,
        0x9a,0x1a,0x3e,0x96,
        0x39,0xbd,0xb3,0x3c,
        0x27,0x5e,0x6b,0x0b,
        0xb2,0x78,0x7b,0xd2,
        0xc2,0x91,0x1b,0xcc,
        0xe3,0xf7,0x04,0x2c,
        0x7c,0x4a,0xd7,0x06,
        0x5e,0xfc,0x77,0x05,
        0xbb,0xa4,0x10,0x4c,
        0x54,0x6c,0xb6,0x90,
        0xb2,0x6d,0x18,0x85,
        0x13,0xc3,0x8a,0x37,
        0xfa,0x86,0xd8,0xcb,
        0xd9,0xac,0xe2,0x46,
        0x1a,0xa5,0x3a,0xac,
        0x71,0xbb,0x61,0x23,
        0x3f,0x4f,0x8c,0x91,
        0xe4,0xaf,0x3a,0xc7,
        0xaa,0x96,0x9d,0x30,
        0xef,0xb1,0x88,0x0f,
        0x19,0x9f,0x3d,0xb1,
        0x08,0x6c,0x22,0xc3,
        0xda,0x68,0x57,0xf5,
        0x04,0x6e,0x25,0x67,
        0x50,0x84,0xc2,0x72,
        0x9a,0x7b,0x35,0x2f,
        0xac,0x17,0x0d,0xa8,
        0xb6,0x10,0x5d,0x9f,
        0xc0,0x40,0xf4,0x63,
        0xd8,0x0a,0x0d,0x92,
        0xf0,0xa5,0xe5,0x15

};

static u8_t ref_hash2[] = {
	0x2b,0x47,0x36,0x71,0x57,0xb0,0x90,0xa9,0x21,0x20,0xa0,0xfc,0xb,0x5b,
	0xbd,0xd8,0xec,0x93,0x8,0x76,0x3,0x56,0xfa,0xa1,0xf4, 0x81, 0x80, 0x6d,
	0xfe, 0x87, 0xb7, 0x22 };
static u8_t encr_key_cbc[] = {0x68,0xf6,0x56,0x8d,
                        0x22,0x38,0x61,0x3c,
                        0x37,0x05,0x3a,0x4b,
                        0x85,0x37,0x2b,0xda
                        };


static u8_t auth_key_hmac[] = { 0xed,0xb4,0xe5,0x38,
                                0x7d,0xc1,0xff,0x89,
                                0xf4,0xdb,0xe8,0x4b,
                                0x91,0x5b,0x62,0x53,
                                0xc3,0x76,0xd0,0x1f,
                                0x92,0xa6,0x57,0x55,
                                0xe8,0x30,0x55,0x47,
                                0x44,0x1d,0x54,0x2f
};

static u8_t cipher_iv[] = {
                           0x0b,0x94,0x4b,0x7b,
                        0x8c,0xb5,0x3f,0x46,
                        0xa3,0x06,0x04,0x56,
                        0x2c,0xdd,0x8f,0x4e

        };


/* ***************************************************************************
 * Private Functions Prototypes
 * ****************************************************************************/

/* ***************************************************************************
 * Public Functions
 * ****************************************************************************/

/*---------------------------------------------------------------
 * Name    : crypto_rng_selftest
 * Purpose : implement SP800-90A selftest
 * Input   : pHandle:              crypto handle
 * Return  : Appropriate status
 * Remark  : Note: This will also init the RNG system
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_rng_selftest(crypto_lib_handle *pHandle,
				     fips_rng_context *rngctx)
{
	/* [SHA-256], [PredictionResistance = True], [EntropyInputLen = 256],
	 * [NonceLen = 128] */
	/* [PersonalizationStringLen = 256], [AdditionalInputLen = 256],
	 * [ReturnedBitsLen = 1024] */
	/* ** INSTANTIATE: */
	u8_t inst_EntropyInput[32] =    { 0x29,0xe1,0xa4,0x27,
			0x09,0xb7,0xe8,0x4d, 0xbe,0x50,0x78,0x8f,
			0xba,0xd8,0xcb,0x60,
	0x9c,0x12,0x7e,0xec, 0x32,0x62,0x63,0x6a,
	0x51,0x3f,0xd9,0x05, 0x9f,0xb8,0xba,0xe4 };
	u8_t inst_Nonce[16] =           { 0xf3,0xa5,0x21,0xf2,
			0x8d,0xff,0xbd,0x97, 0x57,0x4c,0x40,0x5b,
			0x69,0xb6,0x36,0xad };
	u8_t inst_PersonalStr[32] =     { 0xc9,0x9a,0x11,0x47,
			0xd8,0xdb,0x40,0x1f, 0x4f,0xcf,0x76,0x38,
			0x67,0x29,0x67,0x58,
	0xe2,0x64,0x04,0xa3, 0x0a,0x4a,0x9f,0xa4,
	0x96,0xa7,0x17,0xf2, 0x1f,0x5d,0x74,0x9b };

	u8_t inst_V[55] =               { 0x1a,0x6f,0x54,0x9b,
			0x63,0x40,0x59,0xb4, 0x33,0xc5,0xe3,0x3b,
			0x6a,0x79,0x17,0xcb,
	0xe0,0x49,0x52,0xc1, 0xac,0x09,0xfd,0xb0,
	0x33,0x61,0x12,0xfa, 0x5f,0xb2,0xbc,0xb8,
	0xf9,0xbf,0x03,0xee, 0x3e,0x72,0xe5,0x37,
	0xfc,0xa6,0x99,0x71, 0xd8,0x5f,0x1e,0x4e,
	0x2e,0x1e,0xd7,0xd2, 0xe0,0x8c,0x08 };
	u8_t inst_C[55] =               { 0xcc,0xef,0xd0,0x8c,
			0x20,0x6b,0x02,0x25, 0x5d,0xe4,0xd5,0x15,
			0x03,0x4f,0x2a,0x43,
	0x74,0x07,0xb5,0xb2, 0x78,0xa6,0xd2,0xdb,
	0x09,0x6f,0x65,0xd1, 0xb6,0x25,0x47,0x4a,
	0xdc,0x09,0xb6,0xb7, 0x9d,0x9b,0x06,0xfd,
	0x22,0x08,0xf0,0xa1, 0xc0,0xdb,0xce,0x3f,
	0x21,0x10,0x72,0x14, 0x0c,0xa1,0x2b };
	u8_t inst_reseed_counter = 1;

	/* ** GENERATE (FIRST CALL): */
	u8_t gen1_AdditionalInput[32] = { 0x17,0x25,0x4e,0xa3,
			0x92,0xae,0xad,0x0d, 0xc9,0x49,0x92,0xd8,
			0x67,0x81,0x34,0x97,
	0xd3,0xfd,0x6d,0xc7, 0x66,0x96,0x67,0x15,
	0x0a,0xfe,0x6c,0x28, 0xa2,0xb8,0x99,0x46 };
	u8_t gen1_EntropyInputPR[32] =  { 0xd5,0x26,0x6c,0x01,
			0xe1,0x0d,0x72,0xdd, 0x7e,0x8a,0x3b,0xf7,
			0x17,0xcc,0xcb,0x8f,
	0x64,0x3c,0xa2,0x33, 0x31,0x4e,0x3e,0x74,
	0xf1,0x06,0xf4,0x6b, 0x09,0x0e,0x5c,0x73 };

	u8_t gen1_V[55] =               { 0x10,0x1e,0x08,0x2f,
			0xd3,0xa1,0xa5,0x3a, 0xb8,0xbb,0xdc,0x2e,
			0xb6,0x70,0x90,0x79,
	0x93,0xae,0xb7,0xc6, 0xf8,0x44,0x05,0xa3,
	0x29,0xf0,0x95,0xfe, 0xdf,0x97,0xbf,0xd1,
	0xb4,0x68,0xc5,0xd8, 0xd6,0xca,0x72,0x57,
	0xee,0x72,0x24,0xbb, 0x1f,0x8d,0x81,0xbd,
	0x5f,0x8d,0x79,0xd5, 0x1e,0x18,0x00 };
	u8_t gen1_C[55] =               { 0x1d,0x8d,0x2d,0xff,
			0x2c,0x0d,0x27,0xd4, 0x3a,0xae,0xec,0x85,
			0xe9,0x41,0x70,0xff,
	0xb1,0x24,0x86,0x6e, 0xb7,0x0f,0x6c,0x79,
	0x77,0x4c,0x5f,0xf2, 0x8e,0x44,0x0c,0xf4,
	0xa0,0xe4,0x23,0xdc, 0x47,0x09,0x3b,0xfb,
	0x85,0xe7,0x85,0xaf, 0xd5,0x7d,0x09,0xd2,
	0x9e,0xc4,0xc3,0xea, 0x4d,0x2d,0x37 };
	u8_t gen1_reseed_counter = 2;

	/* ** GENERATE (SECOND CALL): */
	u8_t gen2_AdditionalInput[32] = { 0x15,0x7d,0xde,0x59,
			0xce,0xb2,0xc6,0x62, 0xc8,0x66,0x5f,0xbe,
			0x62,0x3e,0xc7,0x58,
	0x73,0xfd,0x0c,0x5c, 0xcc,0xe7,0x9a,0x9f,
	0x5b,0x70,0x98,0xec, 0x8e,0xd7,0x7b,0x67 };
	u8_t gen2_EntropyInputPR[32] =  { 0xc7,0xe5,0xf0,0x3d,
			0x26,0xbd,0xf9,0x55, 0x33,0x38,0xe6,0x4b,
			0xa6,0x4c,0xe5,0xb5,
	0x75,0x1b,0x04,0xf9, 0xc6,0x99,0x92,0x22,
	0x14,0x95,0xf2,0x22, 0x7b,0x97,0x99,0xd0 };

	u8_t gen2_V[55] =               { 0xff,0x79,0x2d,0x24,
			0x7a,0xf2,0x63,0xe6, 0xb0,0x3d,0x5a,0x60,
			0xb8,0x5d,0xa4,0xae,
	0x3e,0xc9,0x16,0xa4, 0x71,0x01,0xf0,0xf1,
	0x7e,0x17,0x61,0xcf, 0xb8,0x8b,0x67,0x30,
	0x46,0x30,0x60,0x29, 0xcb,0x7d,0x82,0x2a,
	0xb9,0x03,0xc2,0xdb, 0xa0,0xa5,0xc7,0x0d,
	0xd7,0xe7,0x66,0x5f, 0x22,0x04,0x00 };
	u8_t gen2_C[55] =               { 0xc3,0xf8,0xf6,0x56,
			0x54,0xe4,0x74,0xa7, 0x93,0xd1,0x96,0x0b,
			0x66,0x24,0x61,0xc0,
	0xb7,0xf6,0xd5,0xbf, 0x6a,0x7e,0x39,0x41,
	0xba,0xdf,0x5c,0xc8, 0x61,0x2f,0x9b,0x7f,
	0x4c,0xad,0x8e,0x22, 0x70,0xeb,0x16,0x5b,
	0x6b,0x7b,0x78,0xa2, 0xdb,0x4d,0x8d,0xb9,
	0x62,0x08,0xad,0xc3, 0xfe,0xc2,0x75 };
	u8_t gen2_reseed_counter = 2;

	u8_t gen2_ReturnedBits[128] =   { 0xe3,0x04,0xde,0x9f,
			0xfd,0x88,0x5c,0xf9, 0x17,0xea,0xd7,0x8f,
			0x05,0x93,0x9b,0x8c,
	0xf5,0x47,0x09,0xfc, 0x2d,0x0c,0x79,0x9a,
	0x98,0xb5,0x43,0x48, 0x63,0x37,0x20,0x44,
	0x77,0xb1,0x06,0x0b, 0xce,0xae,0x2a,0x22,
	0xf7,0xff,0x42,0xb6, 0xcb,0x4b,0x4b,0xc0,
	0x61,0x0a,0xe2,0xb6, 0x75,0x58,0xa7,0xc5,
	0x4b,0x65,0xe4,0x5b, 0xb9,0xf1,0xa8,0x69,
	0x81,0xb7,0x47,0x05, 0xb4,0x8c,0xdb,0xf7,
	0xd8,0xde,0xcf,0x87, 0x86,0x82,0x67,0xbd,
	0x94,0x8e,0x93,0x94, 0xaa,0x43,0x57,0xf8,
	0xdb,0xbf,0x30,0x61, 0x2a,0x0e,0xb5,0xb1,
	0x31,0x88,0x4c,0x22, 0x0e,0x44,0x2d,0x36,
	0x77,0x8e,0x8d,0x74, 0x09,0x1d,0x8a,0x27,
	0xc0,0x70,0xfe,0x69, 0x04,0x69,0xe0,0x7f,
	0x3a,0xab,0xee,0xf7, 0xc6,0x29,0xbf,0xab };
	u8_t result[128];

	BCM_SCAPI_STATUS status = BCM_SCAPI_STATUS_OK;

	/* Check instantiation */
	status = crypto_rng_init(pHandle, rngctx, 1,
		(u32_t*)inst_EntropyInput, sizeof(inst_EntropyInput),
		(u32_t*)inst_Nonce, sizeof(inst_Nonce),
		inst_PersonalStr, sizeof(inst_PersonalStr));
	if (status != BCM_SCAPI_STATUS_OK)
		return status;

	if (!secure_memeql(pHandle->rngctx->v, inst_V, sizeof(inst_V)))
		return BCM_SCAPI_STATUS_SELFTEST_RNG_FAIL;
	if (!secure_memeql(pHandle->rngctx->c, inst_C, sizeof(inst_C)))
		return BCM_SCAPI_STATUS_SELFTEST_RNG_FAIL;
	if (pHandle->rngctx->reseed_counter != inst_reseed_counter)
		return BCM_SCAPI_STATUS_SELFTEST_RNG_FAIL;

	/* Run a first generate check */
	status = crypto_rng_generate(pHandle,
			(u32_t*)gen1_EntropyInputPR,
			sizeof(gen1_EntropyInputPR),
			result, 128,
	gen1_AdditionalInput, sizeof(gen1_AdditionalInput));
	if (status != BCM_SCAPI_STATUS_OK)
		return status;

	if (!secure_memeql(pHandle->rngctx->v, gen1_V, sizeof(gen1_V)))
		return BCM_SCAPI_STATUS_SELFTEST_RNG_FAIL;
	if (!secure_memeql(pHandle->rngctx->c, gen1_C, sizeof(gen1_C)))
		return BCM_SCAPI_STATUS_SELFTEST_RNG_FAIL;
	if (pHandle->rngctx->reseed_counter != gen1_reseed_counter)
		return BCM_SCAPI_STATUS_SELFTEST_RNG_FAIL;

	/* Run a second generate check */
	status = crypto_rng_generate(pHandle,
			(u32_t*)gen2_EntropyInputPR,
			sizeof(gen2_EntropyInputPR),
			result, 128,
	gen2_AdditionalInput, sizeof(gen2_AdditionalInput));
	if (status != BCM_SCAPI_STATUS_OK)
		return status;

	if (!secure_memeql(pHandle->rngctx->v, gen2_V, sizeof(gen2_V)))
		return BCM_SCAPI_STATUS_SELFTEST_RNG_FAIL;
	if (!secure_memeql(pHandle->rngctx->c, gen2_C, sizeof(gen2_C)))
		return BCM_SCAPI_STATUS_SELFTEST_RNG_FAIL;
	if (pHandle->rngctx->reseed_counter != gen2_reseed_counter)
		return BCM_SCAPI_STATUS_SELFTEST_RNG_FAIL;

	/* Check the result */
	if (!secure_memeql(result, gen2_ReturnedBits, 1024/8))
		return BCM_SCAPI_STATUS_SELFTEST_RNG_FAIL;

	return status;
}

BCM_SCAPI_STATUS crypto_selftest_sha1(crypto_lib_handle *handle)
{
	BCM_SCAPI_STATUS rv;
	u8_t plain[SHA1_BLK_SIZE * 3] = {
		0xdb, 0x82, 0xd3, 0x0e, 0x4b, 0xf7, 0xc9, 0xbf,
		0xc2, 0xed, 0xde, 0x7d, 0xa7, 0x6d, 0x54, 0x65,
		0xf5, 0x40, 0xe6, 0x29, 0xa4, 0x90, 0x61, 0x63,
		0xde, 0x06, 0x63, 0x71, 0x72, 0x2b, 0x62, 0x19,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0xd9, 0x48, 0x65, 0x47, 0x40, 0xbd, 0x19, 0x24,
		0x65, 0x7c, 0x25, 0x85, 0x34, 0x66, 0xdf, 0xc1,
		0x96, 0x57, 0xaf, 0x14, 0x57, 0xc7, 0xc3, 0x6c,
		0x17, 0x03, 0xb8, 0x82, 0x32, 0xca, 0x49, 0xb2,
		0x0a, 0x18, 0xeb, 0x37, 0xdb, 0xc6, 0x91, 0xf6,
		0xb9, 0x83, 0x30, 0xc1, 0x64, 0xdf, 0x4d, 0x58,
		0x18, 0x45, 0x8d, 0x13, 0xff, 0x2e, 0x12, 0x60,
		0xf6, 0x4a, 0xbd, 0x3c, 0x23, 0xc6, 0xee, 0x2a,
		0x13, 0x38, 0x2b, 0xc1, 0x2e, 0xf3, 0x39, 0xf6,
		0x1e, 0x07, 0x4c, 0xc4, 0xb7, 0x84, 0x26, 0x10,
		0xae, 0xa4, 0x66, 0x1c, 0xa1, 0xf4, 0x3a, 0x64,
		0x38, 0x91, 0xcf, 0x1d, 0xf3, 0x76, 0x14, 0x12,
		0x1b, 0xf9, 0x30, 0x2a, 0xda, 0x69, 0x16, 0xd3,
		0xab, 0x48, 0xee, 0x9a, 0x88, 0x9e, 0x93, 0x65,
		0x17, 0x7c, 0xdb, 0xe2, 0xf7, 0x0e, 0xb2, 0x41,
		0x21, 0xf0, 0xe1, 0xf4, 0xe4, 0x49, 0xd2, 0xb7
	};
	u32_t len = sizeof(plain);
	u32_t part = SHA1_BLK_SIZE;
	u8_t digest1[SHA1_HASH_SIZE] = {0};
	u8_t digest2[SHA1_HASH_SIZE] = {0};

	/* Calculate the hash for total data */
	rv = crypto_symmetric_hmac_sha1(handle, plain, len, NULL, 0,
					digest1, FALSE);
	if (rv)
		return rv;

	/* Calculate the hash for total data with a part each time */
	rv = crypto_symmetric_hmac_sha_init(handle, BCM_SCAPI_AUTH_ALG_SHA1,
					    plain, part, NULL, 0, digest2);
	if (rv)
		return rv;

	rv = crypto_symmetric_hmac_sha_update(handle, BCM_SCAPI_AUTH_ALG_SHA1,
					      plain + part, part,
					      NULL, 0, digest2, digest2);

	if (rv)
		return rv;

	rv = crypto_symmetric_hmac_sha_final(handle, BCM_SCAPI_AUTH_ALG_SHA1,
					     plain + (part * 2),
					     part, part * 3, NULL, 0,
					     digest2, digest2);
	if (rv)
		return rv;

	rv = memcmp(digest1, digest2, SHA1_HASH_SIZE);
	if (rv)
		return BCM_SCAPI_STATUS_SELFTEST_SHA256_FAIL;

	return BCM_SCAPI_STATUS_OK;
}


BCM_SCAPI_STATUS crypto_test_sha256_parts(crypto_lib_handle *handle)
{
	BCM_SCAPI_STATUS rv = 0;
	u8_t plain[SHA256_BLK_SIZE * 3] = {
		0xdb, 0x82, 0xd3, 0x0e, 0x4b, 0xf7, 0xc9, 0xbf,
		0xc2, 0xed, 0xde, 0x7d, 0xa7, 0x6d, 0x54, 0x65,
		0xf5, 0x40, 0xe6, 0x29, 0xa4, 0x90, 0x61, 0x63,
		0xde, 0x06, 0x63, 0x71, 0x72, 0x2b, 0x62, 0x19,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0xd9, 0x48, 0x65, 0x47, 0x40, 0xbd, 0x19, 0x24,
		0x65, 0x7c, 0x25, 0x85, 0x34, 0x66, 0xdf, 0xc1,
		0x96, 0x57, 0xaf, 0x14, 0x57, 0xc7, 0xc3, 0x6c,
		0x17, 0x03, 0xb8, 0x82, 0x32, 0xca, 0x49, 0xb2,
		0x0a, 0x18, 0xeb, 0x37, 0xdb, 0xc6, 0x91, 0xf6,
		0xb9, 0x83, 0x30, 0xc1, 0x64, 0xdf, 0x4d, 0x58,
		0x18, 0x45, 0x8d, 0x13, 0xff, 0x2e, 0x12, 0x60,
		0xf6, 0x4a, 0xbd, 0x3c, 0x23, 0xc6, 0xee, 0x2a,
		0x13, 0x38, 0x2b, 0xc1, 0x2e, 0xf3, 0x39, 0xf6,
		0x1e, 0x07, 0x4c, 0xc4, 0xb7, 0x84, 0x26, 0x10,
		0xae, 0xa4, 0x66, 0x1c, 0xa1, 0xf4, 0x3a, 0x64,
		0x38, 0x91, 0xcf, 0x1d, 0xf3, 0x76, 0x14, 0x12,
		0x1b, 0xf9, 0x30, 0x2a, 0xda, 0x69, 0x16, 0xd3,
		0xab, 0x48, 0xee, 0x9a, 0x88, 0x9e, 0x93, 0x65,
		0x17, 0x7c, 0xdb, 0xe2, 0xf7, 0x0e, 0xb2, 0x41,
		0x21, 0xf0, 0xe1, 0xf4, 0xe4, 0x49, 0xd2, 0xb7
	};
	u32_t len = sizeof(plain);
	u32_t part = SHA256_BLK_SIZE;
	u8_t digest1[64]__attribute__ ((aligned (64))) = {0};
	u8_t digest2[64]__attribute__ ((aligned (64))) = {0};

	/* Calculate the hash for total data */
	rv = crypto_symmetric_hmac_sha256(handle, plain, len, NULL, 0,
						digest1, FALSE);
	if (rv)
		return rv;

	/* Calculate the hash for total data with a part each time */
	rv = crypto_symmetric_hmac_sha_init(handle, BCM_SCAPI_AUTH_ALG_SHA256,
					    plain, part, NULL, 0, digest2);
	if (rv)
		return rv;

	rv = crypto_symmetric_hmac_sha_update(handle, BCM_SCAPI_AUTH_ALG_SHA256,
					      plain + part, part,
					      NULL, 0, digest2, digest2);

	if (rv)
		return rv;

	rv = crypto_symmetric_hmac_sha_final(handle, BCM_SCAPI_AUTH_ALG_SHA256,
					     plain + (part * 2),
					     part, part * 3, NULL, 0,
					     digest2, digest2);
	if (rv)
		return rv;

	rv = memcmp(digest1, digest2, SHA256_HASH_SIZE);
	if (rv)
		return BCM_SCAPI_STATUS_SELFTEST_SHA256_FAIL;

	return BCM_SCAPI_STATUS_OK;
}

/*---------------------------------------------------------------
 * Name    : crypto_selftest_sha256
 * Purpose : Perform the FIPS SHA256 test
 * Input   : the crypto library handle
 * Return  : Appropriate status
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_selftest_sha256(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS status;
	/* Align to 64 byte and minimum size should be 64 bytes
	 * since data cache lines are 64 bytes */
	u8_t outputSha256[SHA256_HASH_SIZE*2]__attribute__((aligned(64)));
	int i=0;
	u8_t plainSha256[] =
	{ 0xd9,0x3d,0xac,0xfc, 0xe1,0xa7,0x28,0x99,
	0x18,0x15,0xe6,0x88, 0x11,0x1d,0x33,0xb4,
	0x96,0xb3,0x42,0x52, 0x9a,0x4c,0xc4,0x21,
	0x6f,0x44,0xb8,0xf0, 0x39,0x7d,0x85,0x62 };

	u8_t digestSha256[] =
	{ 0x45,0x2b,0x0b,0xf1, 0x20,0x07,0xf2,0x28,
	0x6b,0x1f,0x73,0x3d, 0xc5,0x1a,0xe1,0xe6,
	0x93,0xaa,0xa7,0xf6, 0xcb,0x27,0xf5,0xff,
	0x20,0x10,0xff,0x2c, 0xb2,0x41,0xe0,0x10 };
#ifdef CRYPTO_DEBUG
	printk("Calling crypto_symmetric_hmac_sha256\n");
#endif
	status = crypto_symmetric_hmac_sha256(pHandle,
			(u8_t *)plainSha256, sizeof(plainSha256),
			NULL, 0,
			outputSha256, FALSE);
	if (status != BCM_SCAPI_STATUS_OK)
		return status;
#ifdef CRYPTO_DEBUG
	printk("Compare the hash values\n");
	for(i=0;i<32;i++)
		printk("%x\t",outputSha256[i]);
#endif
	if (!secure_memeql(digestSha256, outputSha256, SHA256_HASH_SIZE))
		return BCM_SCAPI_STATUS_SELFTEST_SHA256_FAIL;

	printk("\nTesting crypto_test_sha256_parts\n");
	status = crypto_test_sha256_parts(pHandle);

	return status;
}


/*---------------------------------------------------------------
 * Name    : crypto_selftest_hmac_sha256
 * Purpose : Perform the FIPS HMAC SHA256 test
 * Input   : the crypto library handle
 * Return  : Appropriate status
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_selftest_hmac_sha256(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS status;
	/* Align to 64 byte and minimum size should be 64 bytes
	 * since data cache lines are 64 bytes */
	u8_t outputHmacSha256[SHA256_HASH_SIZE*2]__attribute__((aligned(64)));
	int i;
	u8_t plainHmacSha256[] __attribute__((aligned(4)))=
			"Sample message for keylen<blocklen";

	u8_t keyHmacSha256[] __attribute__((aligned(4)))=
	{ 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07,
	0x08,0x09,0x0A,0x0B, 0x0C,0x0D,0x0E,0x0F,
	0x10,0x11,0x12,0x13, 0x14,0x15,0x16,0x17,
	0x18,0x19,0x1A,0x1B, 0x1C,0x1D,0x1E,0x1F };

	u8_t digestHmacSha256[] __attribute__((aligned(4)))=
	{ 0xA2,0x8C,0xF4,0x31, 0x30,0xEE,0x69,0x6A,
	0x98,0xF1,0x4A,0x37, 0x67,0x8B,0x56,0xBC,
	0xFC,0xBD,0xD9,0xE5, 0xCF,0x69,0x71,0x7F,
	0xEC,0xf5,0x48,0x0f, 0x0e,0xbd,0xf7,0x90 };

#ifdef CRYPTO_DEBUG
	printk("Calling crypto_symmetric_hmac_sha256\n");
#endif

	status = crypto_symmetric_hmac_sha256(pHandle,
			(u8_t *)plainHmacSha256, sizeof(plainHmacSha256)- 1,
			(u8_t *)keyHmacSha256, sizeof(keyHmacSha256),
			outputHmacSha256, FALSE);
	if (status != BCM_SCAPI_STATUS_OK)
		return status;
#ifdef CRYPTO_DEBUG
	printk("Compare the hmac hash values\n");
	for(i=0;i<32;i++)
		printk("%x\t",outputHmacSha256[i]);
#endif
	if (!secure_memeql(digestHmacSha256, outputHmacSha256,
			SHA256_HASH_SIZE))
		return BCM_SCAPI_STATUS_SELFTEST_SHA256_FAIL;
	else
		return BCM_SCAPI_STATUS_OK;
}


/*---------------------------------------------------------------
 * Name    : crypto_selftest_sha3_224
 * Purpose : Perform the FIPS SHA224 test
 * Input   : the crypto library handle
 * Return  : Appropriate status
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_selftest_sha3_224(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS status;
	u8_t outputSha3_224[64]__attribute__((aligned(64)));
	int i=0;
	u8_t plainSha3_224[] __attribute__((aligned(4)))=
			"Sample message for keylen<blocklen";

	u8_t digestSha3_224[] =
	{0xe9,0xd7,0x28,0xc2,0xac,0x7a,0x52,0x16,0xdb,0xdb,0x12,0x61,
     0x94,0xda,0xf4,0xa9,0x81,0xeb,0xf7,0x7c,0x36,0xd8,0x31,0xce,
	 0x74,0x91,0xc8,0xa7 };

	printk("Calling crypto_symmetric_sha3\n");

	status = crypto_symmetric_sha3(pHandle,
				(u8_t *)plainSha3_224, sizeof(plainSha3_224)-1,
				outputSha3_224, BCM_SCAPI_AUTH_ALG_SHA3_224);
	if (status != BCM_SCAPI_STATUS_OK)
		return status;

	printk("Compare the hash values\n");
	for(i=0;i<SHA3_224_HASH_SIZE;i++)
		printk("%x\t",outputSha3_224[i]);

	if (!secure_memeql(digestSha3_224, outputSha3_224, SHA3_224_HASH_SIZE))
		return BCM_SCAPI_STATUS_SELFTEST_SHA256_FAIL;
	else
		return BCM_SCAPI_STATUS_OK;
}

/*---------------------------------------------------------------
 * Name    : crypto_selftest_sha3_256
 * Purpose : Perform the FIPS SHA256 test
 * Input   : the crypto library handle
 * Return  : Appropriate status
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_selftest_sha3_256(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS status;
	u8_t outputSha3_256[64]__attribute__((aligned(64)));
	int i=0;
	u8_t plainSha3_256[] __attribute__((aligned(4)))=
			"Sample message for keylen<blocklen";

	u8_t digestSha3_256[] =
	{0x0b,0x80,0x3e,0xa8,0x2f,0x71,0x3e,0xfd,0x1f,0xb4,0x6c,0x52,0x7d,0xd1,
     0xaf,0x20,0xee,0xf5,0x54,0x33,0x94,0x89,0x8d,0xe5,0x7e,0x96,0x9e,0x73,
	 0x92,0x1b,0x89,0x1c};

	printk("Calling crypto_symmetric_sha3\n");

	status = crypto_symmetric_sha3(pHandle,
				(u8_t *)plainSha3_256, sizeof(plainSha3_256)-1,
				outputSha3_256, BCM_SCAPI_AUTH_ALG_SHA3_256);
	if (status != BCM_SCAPI_STATUS_OK)
		return status;

	printk("Compare the hash values\n");
	for(i=0;i<SHA3_256_HASH_SIZE;i++)
		printk("%x\t",outputSha3_256[i]);

	if (!secure_memeql(digestSha3_256, outputSha3_256, SHA3_256_HASH_SIZE))
		return BCM_SCAPI_STATUS_SELFTEST_SHA256_FAIL;
	else
		return BCM_SCAPI_STATUS_OK;
}

/*---------------------------------------------------------------
 * Name    : crypto_selftest_sha3_384
 * Purpose : Perform the FIPS SHA384 test
 * Input   : the crypto library handle
 * Return  : Appropriate status
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_selftest_sha3_384(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS status;
	u8_t outputSha3_384[64]__attribute__((aligned(64)));
	int i=0;
	u8_t plainSha3_384[] __attribute__((aligned(4)))=
			"Sample message for keylen<blocklen";

	u8_t digestSha3_384[] =
	{0x71,0xde,0xd6,0x63,0xff,0xa6,0x83,0x05,0x84,0x56,0xda,0xe5,0x06,0xbd,
	0x80,0xa5,0xc3,0x28,0x3b,0x82,0xa1,0xef,0xec,0x8e,0xe6,0x64,0x0b,
	0x98,0x90,0x69,0x1b,0x57,0x7a,0x08,0x57,0xea,0x8d,0xd3,0x55,0x6d,
	0x25,0xca,0x7f,0x9c,0x97,0x81,0xea,0xb8};

	printk("Calling crypto_symmetric_sha3\n");

	status = crypto_symmetric_sha3(pHandle,
				(u8_t *)plainSha3_384, sizeof(plainSha3_384)-1,
				outputSha3_384, BCM_SCAPI_AUTH_ALG_SHA3_384);
	if (status != BCM_SCAPI_STATUS_OK)
		return status;

	printk("Compare the hash values\n");
	for(i=0;i<SHA3_384_HASH_SIZE;i++)
		printk("%x\t",outputSha3_384[i]);

	if (!secure_memeql(digestSha3_384, outputSha3_384, SHA3_384_HASH_SIZE))
		return BCM_SCAPI_STATUS_SELFTEST_SHA256_FAIL;
	else
		return BCM_SCAPI_STATUS_OK;
}

/*---------------------------------------------------------------
 * Name    : crypto_selftest_sha3_512
 * Purpose : Perform the FIPS SHA512 test
 * Input   : the crypto library handle
 * Return  : Appropriate status
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_selftest_sha3_512(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS status;
	u8_t outputSha3_512[SHA3_512_HASH_SIZE]__attribute__((aligned(64)));
	int i=0;
	u8_t plainSha3_512[] __attribute__((aligned(4)))=
			"Sample message for keylen<blocklen";

	u8_t digestSha3_512[] =
	{0xa6,0xb0,0x1e,0x4a,0xaf,0xec,0xdf,0x9f,0xa4,0xe9,0xbe,0x5b,0xff,0xa4,
	 0x01,0xe8,0x0c,0xf1,0x96,0xc1,0xe3,0x59,0x6d,0xe9,0xdd,0xab,
	 0x3b,0xe0,0x0b,0xc3,0x2d,0x70,0xc8,0x46,0xc6,0xdb,0xf0,0x20,0xf9,0x82,
	 0x1d,0xcd,0xb7,0x06,0x44,0x80,
	 0x3d,0xaf,0x0f,0xfb,0x5c,0x6e,0x02,0x50,0x67,0x86,0x6a,0xe0,0x9f,0x89,
	 0xa3,0xdb,0x4c,0xf5};

	printk("Calling crypto_symmetric_sha3\n");

	status = crypto_symmetric_sha3(pHandle,
				(u8_t *)plainSha3_512, sizeof(plainSha3_512)-1,
				outputSha3_512, BCM_SCAPI_AUTH_ALG_SHA3_512);
	if (status != BCM_SCAPI_STATUS_OK)
		return status;

	printk("Compare the hash values\n");
	for(i=0;i<SHA3_512_HASH_SIZE;i++)
		printk("%x\t",outputSha3_512[i]);

	if (!secure_memeql(digestSha3_512, outputSha3_512, SHA3_512_HASH_SIZE))
		return BCM_SCAPI_STATUS_SELFTEST_SHA256_FAIL;
	else
		return BCM_SCAPI_STATUS_OK;
}

/*---------------------------------------------------------------
 * Name    : crypto_selftest_fips_aes_cbc
 * Purpose : Perform the FIPS AES CBC test
 * Input   : the crypto library handle
 * Return  : Appropriate status
 *--------------------------------------------------------------*/
static u8_t crypto_cipher_iv[] __aligned(64) = {
	0x00, 0x01, 0x02, 0x03,
	0x04, 0x05, 0x06, 0x07,
	0x08, 0x09, 0x0a, 0x0b,
	0x0c, 0x0d, 0x0e, 0x0f
};

static u8_t NIST_CBCAES_CipherIV[] __attribute__((aligned(4))) =
	{ 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f };

static u8_t NIST_CBCAES_Plaintext[] __attribute__((aligned(4))) =
	{ 0x6B,0xC1,0xBE,0xE2,0x2E,0x40,0x9F,0x96,
	0xE9,0x3D,0x7E,0x11,0x73,0x93,0x17,0x2A,
	0xAE,0x2D,0x8A,0x57,0x1E,0x03,0xAC,0x9C,
	0x9E,0xB7,0x6F,0xAC,0x45,0xAF,0x8E,0x51,
	0x30,0xC8,0x1C,0x46,0xA3,0x5C,0xE4,0x11,
	0xE5,0xFB,0xC1,0x19,0x1A,0x0A,0x52,0xEF,
	0xF6,0x9F,0x24,0x45,0xDF,0x4F,0x9B,0x17,
	0xAD,0x2B,0x41,0x7B,0xE6,0x6C,0x37,0x10 };

static u8_t NIST_CBCAES128_Key[] __attribute__((aligned(4))) =
	{ 0x2B,0x7E,0x15,0x16,0x28,0xAE,0xD2,0xA6,
	0xAB,0xF7,0x15,0x88,0x09,0xCF,0x4F,0x3C };

static u8_t NIST_CBCAES128_Ciphertext[] __attribute__((aligned(4))) =
	{ 0x76,0x49,0xAB,0xAC,0x81,0x19,0xB2,0x46,
	0xCE,0xE9,0x8E,0x9B,0x12,0xE9,0x19,0x7D,
	0x50,0x86,0xCB,0x9B,0x50,0x72,0x19,0xEE,
	0x95,0xDB,0x11,0x3A,0x91,0x76,0x78,0xB2,
	0x73,0xBE,0xD6,0xB8,0xE3,0xC1,0x74,0x3B,
	0x71,0x16,0xE6,0x9E,0x22,0x22,0x95,0x16,
	0x3F,0xF1,0xCA,0xA1,0x68,0x1F,0xAC,0x09,
	0x12,0x0E,0xCA,0x30,0x75,0x86,0xE1,0xA7};

static u8_t NIST_CBCAES192_Key[] __attribute__((aligned(4)))=
	{ 0x8E,0x73,0xB0,0xF7,0xDA,0x0E,0x64,0x52,
	0xC8,0x10,0xF3,0x2B,0x80,0x90,0x79,0xE5,
	0x62,0xF8,0xEA,0xD2,0x52,0x2C,0x6B,0x7B };

static u8_t NIST_CBCAES192_Ciphertext[] __attribute__((aligned(4))) =
	{ 0x4F,0x02,0x1D,0xB2,0x43,0xBC,0x63,0x3D,
	0x71,0x78,0x18,0x3A,0x9F,0xA0,0x71,0xE8,
	0xB4,0xD9,0xAD,0xA9,0xAD,0x7D,0xED,0xF4,
	0xE5,0xE7,0x38,0x76,0x3F,0x69,0x14,0x5A,
	0x57,0x1B,0x24,0x20,0x12,0xFB,0x7A,0xE0,
	0x7F,0xA9,0xBA,0xAC,0x3D,0xF1,0x02,0xE0,
	0x08,0xB0,0xE2,0x79,0x88,0x59,0x88,0x81,
	0xD9,0x20,0xA9,0xE6,0x4F,0x56,0x15,0xCD };

static u8_t NIST_CBCAES256_Key[] __attribute__((aligned(4))) =
	{ 0x60,0x3D,0xEB,0x10,0x15,0xCA,0x71,0xBE,
	0x2B,0x73,0xAE,0xF0,0x85,0x7D,0x77,0x81,
	0x1F,0x35,0x2C,0x07,0x3B,0x61,0x08,0xD7,
	0x2D,0x98,0x10,0xA3,0x09,0x14,0xDF,0xF4 };

static u8_t NIST_CBCAES256_Ciphertext[] __attribute__((aligned(4))) =
	{ 0xF5,0x8C,0x4C,0x04,0xD6,0xE5,0xF1,0xBA,
	0x77,0x9E,0xAB,0xFB,0x5F,0x7B,0xFB,0xD6,
	0x9C,0xFC,0x4E,0x96,0x7E,0xDB,0x80,0x8D,
	0x67,0x9F,0x77,0x7B,0xC6,0x70,0x2C,0x7D,
	0x39,0xF2,0x33,0x69,0xA9,0xD9,0xBA,0xCF,
	0xA5,0x30,0xE2,0x63,0x04,0x23,0x14,0x61,
	0xB2,0xEB,0x05,0xE2,0xC3,0x9B,0xE9,0xFC,
	0xDA,0x6C,0x19,0x07,0x8C,0x6A,0x9D,0x1B };

BCM_SCAPI_STATUS crypto_selftest_aes_cbc(crypto_lib_handle * pHandle)
{
	BCM_SCAPI_STATUS status;
	BCM_SCAPI_ENCR_ALG encr_alg;
	u8_t output[256] __attribute__((aligned(64))) ;
	u8_t *encr_key, *cipher_text;
	u32_t cipher_size;
	u32_t key_size[3] = {AES_128_KEY_LEN_BYTES, AES_192_KEY_LEN_BYTES,
				AES_256_KEY_LEN_BYTES};
	int i = 0;

	for(i = 0; i < 3; i++) {

		switch(key_size[i]) {
			case AES_128_KEY_LEN_BYTES:
				encr_alg     = BCM_SCAPI_ENCR_ALG_AES_128;
				cipher_text = NIST_CBCAES128_Ciphertext;
				cipher_size = sizeof(NIST_CBCAES128_Ciphertext);
				encr_key = NIST_CBCAES128_Key;
			break;
			case AES_192_KEY_LEN_BYTES:
				encr_alg     = BCM_SCAPI_ENCR_ALG_AES_192;
				cipher_text = NIST_CBCAES192_Ciphertext;
				cipher_size = sizeof(NIST_CBCAES192_Ciphertext);
				encr_key = NIST_CBCAES192_Key;
			break;
			case AES_256_KEY_LEN_BYTES:
				encr_alg     = BCM_SCAPI_ENCR_ALG_AES_256;
				cipher_text = NIST_CBCAES256_Ciphertext;
				cipher_size = sizeof(NIST_CBCAES256_Ciphertext);
				encr_key = NIST_CBCAES256_Key;
			break;
			default:
				return BCM_SCAPI_STATUS_CRYPTO_ENCR_UNSUPPORTED;
		}

		/* test encrypt */
		status = crypto_symmetric_fips_aes(pHandle,
					BCM_SCAPI_ENCR_MODE_CBC,
					encr_alg, BCM_SCAPI_CIPHER_MODE_ENCRYPT,
					encr_key, NIST_CBCAES_CipherIV,
					NIST_CBCAES_Plaintext,
					sizeof(NIST_CBCAES_Plaintext),
					64, 0, output);
		if (BCM_SCAPI_STATUS_OK != status)
			return status;

		if (!secure_memeql(cipher_text, output, 64))
			return BCM_SCAPI_STATUS_SELFTEST_AES_FAIL;

		/* now test decrypt */
		status = crypto_symmetric_fips_aes(pHandle,
					BCM_SCAPI_ENCR_MODE_CBC,
					encr_alg, BCM_SCAPI_CIPHER_MODE_DECRYPT,
					encr_key, NIST_CBCAES_CipherIV,
					cipher_text, cipher_size,
					64, 0, output);
		if (BCM_SCAPI_STATUS_OK != status)
			return status;

		if (!secure_memeql(NIST_CBCAES_Plaintext, output, 64))
			return BCM_SCAPI_STATUS_SELFTEST_AES_FAIL;
	}

	return status;
}

u8_t output[256] __attribute__((aligned(64)));
/*---------------------------------------------------------------
 * Name    : crypto_selftest_aes_ctr
 * Purpose : Perform the FIPS AES CTR test
 * Input   : the crypto library handle
 * Return  : Appropriate status
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_selftest_aes_ctr(crypto_lib_handle * pHandle)
{
	BCM_SCAPI_STATUS status;

	u8_t AES_CipherIV[] __attribute__((aligned(4))) =
				{ 0x00,0x6C,0xB6,0xDB,
				0xC0,0x54,0x3B,0x59,0xDA,0x48,0xD9,0x0B,
				0x00,0x00,0x00,0x01 };

	u8_t AES_Plaintext[] __attribute__((aligned(4))) =
				{ 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
				0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
				0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
				0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F };

	u8_t AES128_Key[] __attribute__((aligned(4))) =
				{ 0x7E,0x24,0x06,0x78,0x17,0xFA,0xE0,0xD7,
				0x43,0xD6,0xCE,0x1F,0x32,0x53,0x91,0x63 };
	u8_t AES128_Ciphertext[] __attribute__((aligned(4))) =
				{ 0x51,0x04,0xA1,0x06,0x16,0x8A,0x72,0xD9,
				0x79,0x0D,0x41,0xEE,0x8E,0xDA,0xD3,0x88,
				0xEB,0x2E,0x1E,0xFC,0x46,0xDA,0x57,0xC8,
				0xFC,0xE6,0x30,0xDF,0x91,0x41,0xBE,0x28 };

	/* test encrypt */
	status = crypto_symmetric_fips_aes(pHandle,
				BCM_SCAPI_ENCR_MODE_CTR,
				BCM_SCAPI_ENCR_ALG_AES_128,
				BCM_SCAPI_CIPHER_MODE_ENCRYPT,
				AES128_Key, AES_CipherIV,
				AES_Plaintext, sizeof(AES_Plaintext),
				sizeof(AES_Plaintext), 0, output);

	if (BCM_SCAPI_STATUS_OK != status)
		return status;

	if (!secure_memeql(AES128_Ciphertext, output, sizeof(AES128_Ciphertext)))
	{
		printk("failed to compare");
		return BCM_SCAPI_STATUS_SELFTEST_AES_FAIL;
	}

	/* now test decrypt */
	status = crypto_symmetric_fips_aes(pHandle,
				BCM_SCAPI_ENCR_MODE_CTR,
				BCM_SCAPI_ENCR_ALG_AES_128,
				BCM_SCAPI_CIPHER_MODE_DECRYPT,
				AES128_Key, AES_CipherIV,
				AES128_Ciphertext, sizeof(AES128_Ciphertext),
				sizeof(AES_Plaintext), 0, output);
	if (BCM_SCAPI_STATUS_OK != status)
		return status;

	if (!secure_memeql(AES_Plaintext, output, sizeof(AES128_Ciphertext)))
	{
		printk("failed to compare decryption");
		return BCM_SCAPI_STATUS_SELFTEST_AES_FAIL;
	}

	return BCM_SCAPI_STATUS_OK;
}


/* AES_128_CCM encrypt selftest (from spec) */
BCM_SCAPI_STATUS crypto_selftest_aes_128_ccm(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS        status;

	uint8_t input[64] __attribute__((aligned(4)));

	/* DV Data with plain text aligned 16B */
	/* Full CCM IV, already setup */
	uint8_t AES128_CCM_IV[] =
	{ 0x59,0x00,0x00,0x00,0x03,0x02,0x01,0x00,
	0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0x00,0x17 };

	uint8_t AES128_CCM_key[]=
	{ 0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,
	0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF };

	/* len + 8 bytes of AAD + padding */
	uint8_t AES128_CCM_aad[] =
	{ 0x00,0x08,0x00,0x01,0x02,0x03,0x04,0x05,
	0x06,0x07,0x00,0x00,0x00,0x00,0x00,0x00 };

	/* plaintest + padding */
	uint8_t AES128_CCM_plain[]=
	{ 0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
	0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };

	/* cipher text */
	uint8_t AES128_CCM_enctext[] =
	{ 0x58,0x8C,0x97,0x9A,0x61,0xC6,0x63,0xD2,
	0xF0,0x66,0xD0,0xC2,0xC0,0xF9,0x89,0x80,
	0x6D,0x5F,0x6B,0x61,0xDA,0xC3,0x84      };

	/* 8 bytes of MAC (per IV) */
	uint8_t AES128_CCM_mac[] = { 0x17,0xE8,0xD1,0x2C,0xFD,0xF9,0x26,0xE0 };

	unsigned aad_len = 8;
	unsigned data_len = sizeof(AES128_CCM_enctext);
	unsigned req_len = sizeof(AES128_CCM_aad) + sizeof(AES128_CCM_plain);
	unsigned mac_len = sizeof(AES128_CCM_mac);

	/* Test encrypt */

	/* clear the output buffer (and make DMA txfr visible) */
	secure_memclr(output, sizeof(output));
	/* Create the message data */
	/* length + AAD + padding */
	secure_memcpy(&input[0], AES128_CCM_aad, 16);
	/* plaintext + padding */
	secure_memcpy(&input[16], AES128_CCM_plain, 32);

	status = crypto_symmetric_aes_ccm(pHandle,
				BCM_SCAPI_ENCR_ALG_AES_128,
				BCM_SCAPI_CIPHER_MODE_ENCRYPT,
				AES128_CCM_key, AES128_CCM_IV,
				NULL, mac_len, input, req_len,
				data_len, aad_len, output);
	printk("%s: crypto_symmetric_aes_ccm status %d:\n",__func__,status);
	if (BCM_SCAPI_STATUS_OK != status)
		return status;

	/* Compare the data */
	if (!secure_memeql(AES128_CCM_enctext, output, data_len))
		return BCM_SCAPI_STATUS_SELFTEST_AES_FAIL;
	/* Compare the MAC */
	if (!secure_memeql(AES128_CCM_mac,
			&output[sizeof(AES128_CCM_enctext)], mac_len))
		return BCM_SCAPI_STATUS_SELFTEST_AES_FAIL;

	/* Test decrypt */

	/* clear the output buffer (and make DMA txfr visible) */
	secure_memclr(output, sizeof(output));
	/* Create the message data */
	/* length + AAD + padding */
	secure_memcpy(&input[0], AES128_CCM_aad, 16);
	/* plaintext + padding */
	secure_memcpy(&input[16], AES128_CCM_enctext, data_len);

	status = crypto_symmetric_aes_ccm(pHandle,
				BCM_SCAPI_ENCR_ALG_AES_128,
				BCM_SCAPI_CIPHER_MODE_DECRYPT,
				AES128_CCM_key, AES128_CCM_IV,
				AES128_CCM_mac, mac_len,
				input, req_len,
				data_len, aad_len, output);
	printk("%s: crypto_symmetric_aes_ccm status %d:\n",__func__,status);
	if (BCM_SCAPI_STATUS_OK != status)
		return status;

	/* Compare the data */
	if (!secure_memeql(AES128_CCM_plain, output, data_len))
		return BCM_SCAPI_STATUS_SELFTEST_AES_FAIL;

	return BCM_SCAPI_STATUS_OK;
}

/*---------------------------------------------------------------
 * Name    : crypto_selftest_aes_cbc_sha256_hmac
 *
 * Purpose : Perform the FIPS AES CBC test + HMAC combination case
 *           This mode is not used in the FIPS
 * Input   : the crypto library handle
 * Return  : Appropriate status
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_selftest_aes_cbc_sha256_hmac(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS status;
	u32_t  crypto_len = 0x80;
	u32_t  crypto_offset = 0;
	u32_t auth_len = 0x80;
	u32_t auth_offset = 0;
	/* need to check if it's aligned? +4: leave room so can align */
	u32_t outputAESHmacSha256[0x80+SHA256_HASH_SIZE+SHA256_HASH_SIZE]__attribute__((aligned(64)));

	status = crypto_symmetric_aes_hmacsha256(pHandle, (u8_t*)&data_enc[0],
				     sizeof(data_enc),
					 (u8_t*)&encr_key_cbc[0],
					 sizeof(encr_key_cbc),
					 (u8_t*)&auth_key_hmac[0],
					 sizeof(auth_key_hmac),
					 (u8_t*)&cipher_iv[0] ,
					crypto_len, crypto_offset,
					auth_len, auth_offset,
					(u8_t*)outputAESHmacSha256,
					BCM_SCAPI_CIPHER_MODE_DECRYPT,
					BCM_SCAPI_CIPHER_ORDER_CRYPT_AUTH);

#ifdef CRYPTO_DEBUG
	printk("crypto_symmetric_aes_hmacsha256 returned %d\n",status);
#endif
	if (status != BCM_SCAPI_STATUS_OK)
		return status;

	if(memcmp(data_in_2,(u8_t*)(outputAESHmacSha256), crypto_len)) {
#ifdef CRYPTO_DEBUG
		printk("Decrypt fails \n");
#endif
		return BCM_SCAPI_STATUS_SELFTEST_AES_SHA256_FAIL;
	}

	if (memcmp(ref_hash2, (u8_t*)(outputAESHmacSha256+(crypto_len/4)),
			   SHA256_HASH_SIZE)) {
#ifdef CRYPTO_DEBUG
		printk("Authentication Fails\n");
#endif
		return BCM_SCAPI_STATUS_SELFTEST_AES_SHA256_FAIL;
	}

	return BCM_SCAPI_STATUS_OK;
}

BCM_SCAPI_STATUS crypto_selftest_des(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS rc = 0;
	u8_t text[256]__aligned(64) = "A Boeing 767 arrives at "
			"JFK and is on its way across the tarmac, when it "
			"suddenly stops dead.";
	u32_t text_size = 0;
	u8_t cipher[256]__aligned(64) = {0};
	u8_t plain[256]__aligned(64) = {0};
	u8_t *encr_key;
	u32_t unit = 32;

	for (text_size = 0; text_size < 256; text_size += unit) {
		if (text[text_size] == 0)
			break;
	}

	encr_key  = (u8_t *)NIST_CBCAES256_Key;
	rc = crypto_symmetric_des_encrypt(pHandle, BCM_SCAPI_ENCR_ALG_DES,
					  encr_key, 8, text, text_size,
					  crypto_cipher_iv, 8, cipher);
	if (rc)
		return rc;

	rc = crypto_symmetric_des_decrypt(pHandle, BCM_SCAPI_ENCR_ALG_DES,
					  encr_key, 8, cipher, text_size,
					  crypto_cipher_iv, 8, plain);
	if (rc)
		return rc;

	rc = secure_memeql(plain, text, text_size);
	if (rc == 0) {
		u32_t cnt;

		printk("Compare the plain and decrypted values\n");
		for (cnt = 0; cnt < text_size; cnt++)
			printk("%x ", text[cnt]);

		printk("\n");

		for (cnt = 0; cnt < text_size; cnt++)
			printk("%x ", plain[cnt]);

		return BCM_SCAPI_STATUS_SELFTEST_DES_FAIL;
	}

	return 0;
}

BCM_SCAPI_STATUS crypto_selftest_3des(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS rc = 0;
	u8_t text[256]__aligned(64) = "A Boeing 767 arrives at "
			"JFK and is on its way across the tarmac, when it "
			"suddenly stops dead.";
	u32_t text_size = 0;
	u8_t cipher[256]__aligned(64) = {0};
	u8_t plain[256]__aligned(64) = {0};
	u8_t *encr_key;
	u32_t unit = 32;

	for (text_size = 0; text_size < 256; text_size += unit) {
		if (text[text_size] == 0)
			break;
	}

	encr_key  = (u8_t *)NIST_CBCAES256_Key;
	rc = crypto_symmetric_des_encrypt(pHandle, BCM_SCAPI_ENCR_ALG_3DES,
					  encr_key, 24, text, text_size,
					  crypto_cipher_iv, 8, cipher);
	if (rc)
		return rc;

	rc = crypto_symmetric_des_decrypt(pHandle, BCM_SCAPI_ENCR_ALG_3DES,
					  encr_key, 24, cipher, text_size,
					  crypto_cipher_iv, 8, plain);
	if (rc)
		return rc;

	rc = secure_memeql(plain, text, text_size);
	if (rc == 0) {
		u32_t cnt;

		printk("Compare the plain and decrypted values\n");
		for (cnt = 0; cnt < text_size; cnt++)
			printk("%x ", plain[cnt]);

		printk("\n");

		for (cnt = 0; cnt < text_size; cnt++)
			printk("%x ", text[cnt]);

		return BCM_SCAPI_STATUS_SELFTEST_DES_FAIL;
	}

	return 0;
}

/* ***************************************************************************
 * Private Functions
 * ****************************************************************************/
