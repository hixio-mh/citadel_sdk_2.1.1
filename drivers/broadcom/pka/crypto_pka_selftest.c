/******************************************************************************
 *  Copyright (C) 2017 Broadcom. The term "Broadcom" refers to Broadcom Limited
 *  and/or its subsidiaries.
 *
 *  This program is the proprietary software of Broadcom and/or its licensors,
 *  and may only be used, duplicated, modified or distributed pursuant to the
 *  terms and conditions of a separate, written license agreement executed
 *  between you and Broadcom (an "Authorized License").  Except as set forth in
 *  an Authorized License, Broadcom grants no license (express or implied),
 *  right to use, or waiver of any kind with respect to the Software, and
 *  Broadcom expressly reserves all rights in and to the Software and all
 *  intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE,
 *  THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD
 *  IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.
 *
 *  Except as expressly set forth in the Authorized License,
 *
 *  1.     This program, including its structure, sequence and organization,
 *  constitutes the valuable trade secrets of Broadcom, and you shall use all
 *  reasonable efforts to protect the confidentiality thereof, and to use this
 *  information only in connection with your use of Broadcom integrated circuit
 *  products.
 *
 *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
 *  "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS
 *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH
 *  RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL
 *  IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A
 *  PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET
 *  ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE
 *  ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 *
 *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
 *  ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL,
 *  INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY
 *  RELATING TO YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
 *  HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN
 *  EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1,
 *  WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY
 *  FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
 ******************************************************************************/

/* @file crypto_pka_selftest.c
 *
 * Self tests for the pka
 * This file contains the self test for the pka algorithms like RSA, DSA,
 * ECC and Diffie Hellman
 *
 */

/*
 * TODO
 *  * 3. Enable the custom tests once RNG and hash available
 *
 * */
/* ***************************************************************************
 * Includes
 * ***************************************************************************/
#include <string.h>
#include <misc/printk.h>
#include <zephyr/types.h>
#include <pka/crypto_pka.h>
#include <pka/crypto_pka_util.h>
#include <crypto/crypto_smau.h>
#include <crypto/crypto_symmetric.h>
#include <crypto/crypto_rng.h>
#include <pka/crypto_pka_selftest.h>

/* ***************************************************************************
 * MACROS/Defines
 * ***************************************************************************/
/**
 * Definition
 */
/* this is the MODEXP test vector, with 2048 bit modulus and 256 bit
 * exponenet */
/* generated by charles */
#define MODEXP_SIZE_N (BITLEN2BYTELEN(2048)) /* byte len */
#define MODEXP_SIZE_E (BITLEN2BYTELEN(256))  /* byte len */

/* ***************************************************************************
 * Types/Structure Declarations
 * ***************************************************************************/

/* Self test function type definition */
typedef BCM_SCAPI_STATUS (*DrvCryptoPka_Self_test)(crypto_lib_handle *pHandle);

/* Unit test case info */
typedef struct DrvCryptoPka_Self_test_cases {
    DrvCryptoPka_Self_test    fptr;
    char            *desc;
} DrvCryptoPka_Self_test_cases_t;

/* ***************************************************************************
 * Global and Static Variables
 * Total Size: NNNbytes
 * ***************************************************************************/

static u32_t modexpN[MODEXP_SIZE_N>>2] = { /* "MODEXP n" in the XCT file*/
    0x2ff52305, 0x3c246d97, 0x5f4d1c9e, 0x67192192,
    0x187a93c2, 0x489e3756, 0xaac73bb3, 0x382ab29f,
    0x2f45d389, 0xd0f17c8b, 0x26123196, 0x03c4d8db,
    0x2c77b6a9, 0x3d918e03, 0xf91cd21e, 0x75581060,
    0x640fd581, 0x71ede4b1, 0x22552704, 0x1c3c2460,
    0xb1f7d86e, 0xbf8e0d88, 0x43d7f0b8, 0xcac9e615,
    0x9f8e48a7, 0x8d2609bf, 0xd1e28c46, 0x09c8830a,
    0xdfaf0319, 0xddebdab8, 0x5de5f59d, 0xc662eca8,
    0x63b0761c, 0xfcf367d9, 0x52a27f02, 0xfc5ac8a2,
    0x4cadd0f8, 0xdba4aba0, 0x8095b62b, 0x1e56eea6,
    0x92970a70, 0x1a867598, 0xe7a9654f, 0xf970d52a,
    0x2cd5be56, 0xf0058304, 0xfa2d3b99, 0x9c1b7bf9,
    0xa029e3c5, 0xd3536cc0, 0x9e9461f1, 0xe07d9055,
    0xe7f5258f, 0x0835bdbf, 0xceb051c9, 0xe1660001,
    0x9dbde1f7, 0xc3aaf99c, 0x9fd8b519, 0xdae95a0f,
    0xc8632931, 0x515647ed, 0xebcec2d2, 0x82912712,
};

static u32_t modexpA[MODEXP_SIZE_N>>2] = { /* "MODEXP m" in the XCT file*/
    0x32a995ee, 0xbf4c2a03, 0x69e7f446, 0xa2616022,
    0xcb4cebb1, 0xd2c4d949, 0xf5fbb233, 0x4007671d,
    0xae669d26, 0xbf86a04f, 0x184bfa4d, 0xa297f843,
    0x43f393c6, 0xd8d6a946, 0x83c3c9ce, 0x07c152a6,
    0xd836e922, 0xe4062a28, 0x5c3f85b8, 0xe9325953,
    0x8c14b557, 0xaa67700f, 0xacb73431, 0x908d3eb4,
    0xb05ebd4e, 0x63e75354, 0x4cf3022c, 0xca985319,
    0xd28a5e48, 0xa4f0bea6, 0xb233ef2b, 0xddd072ed,
    0x50c4fc13, 0x33274179, 0xe0b1b0a4, 0x0a4e9784,
    0x112e95bc, 0x58cc9f98, 0xbd969e86, 0x5322192b,
    0xda3e7e93, 0x12a9fea5, 0xb186bf05, 0xbfa7d59e,
    0x0fe5ed88, 0x27dec22b, 0xa5cb17d3, 0x569e9be8,
    0x5d7676a0, 0x2b9e2150, 0x52aaa313, 0x28ecd2ea,
    0x32e48f40, 0xd9faa1c6, 0xb56e7e32, 0x295b8a85,
    0xf3d4065a, 0x9eda55a2, 0xb7c64f86, 0x9e4c1498,
    0x13194628, 0xc749b513, 0x1f508da5, 0x192da825,
};

static u32_t modexpB[MODEXP_SIZE_E>>2] = { /* "MODEXP e" in XCT file */
    0x6709bad2, 0x547bd207, 0x0d90470b, 0x88e57826,
    0x71b3a872, 0x04e3f7ff, 0x3b472f68, 0x8220370c,
};

/* the expected output */
static u32_t modexpC[MODEXP_SIZE_N>>2] = { /* "MODEXP c" in XCT file */
    0xb0c86fbc, 0xd26a20b9, 0xd40ec3ef, 0x82561625,
    0x8dc0d91f, 0x9b505c26, 0x33eaa649, 0xaa28410c,
    0x8cbe55dc, 0x8f9a7a53, 0xc0762f01, 0x3c358887,
    0xa4d69adc, 0x89ae3eed, 0x113ef65a, 0xb0f4c0ac,
    0xfe74dc73, 0x1ed9a579, 0x0fb7da6b, 0x738fcd1b,
    0xf1609612, 0x34e6ba17, 0xbe341643, 0x99c52712,
    0xb0d92f2e, 0x1df247d4, 0xda638e0c, 0x5cb1207f,
    0x386ec6fb, 0xc5809e4f, 0x41a39014, 0x6d8e2c79,
    0x9e9d3ab8, 0x745a7361, 0xd5fde071, 0xfbf3e6fa,
    0x62955eb8, 0x98b2e169, 0x4a03bae2, 0x6c713aa3,
    0xf415c8cb, 0xa1d82fe4, 0x5a69acc4, 0x3c336df6,
    0x072c33a8, 0x5ab0672a, 0x7e53a942, 0xdcf26c71,
    0x283297d4, 0xda3f2330, 0x1808202e, 0x998ee259,
    0x793a5885, 0xc171b932, 0x41d04abd, 0xedafa7f1,
    0x1f6a8418, 0x5144483f, 0xd11892bf, 0x48dd2350,
    0x4829db9d, 0xe8ab65b1, 0x594ae2cf, 0x394ab3a9,
};

/* MODINV test vector */
#define MODINV_SIZE_N (BITLEN2BYTELEN(2048)) /* byte len */

static u32_t modinvN[64] = {
        0x83e60831, 0x45262df2, 0xd97f675a, 0x132aecdf,
        0xfffffffe, 0xdfff1fc0, 0xffff51f7, 0xfffdf769,
        0xafebff4b, 0x7bff5a07, 0xfffe0001, 0xffffffff,
        0x4c93b477, 0x16c70295, 0x664d0001, 0x7fffffff,
        0xffffffff, 0xffff3307, 0xadf65be4, 0xffff30fa,
        0x7ffffffe, 0xffffffff, 0xe287fd9b, 0x7ffffffe,
        0x7fffffff, 0x7ffffffe, 0x00000000, 0x7fffffff,
        0xfffe9b16, 0xcf970618, 0x77ff7518, 0xb7f7d48b,
        0xcd5f77ec, 0xffaa2533, 0x7fffffff, 0xffb37bd8,
        0x7ffffffe, 0xffff62eb, 0x541d0611, 0x6d810001,
        0xffff101b, 0x00000001, 0xbb7fef43, 0xffffffff,
        0xffffffff, 0x2346e1dd, 0x7bf0dc3b, 0x549ffc1c,
        0xffff5aa7, 0x730f0001, 0x7a3b682a, 0xffff3fa9,
        0xffff4cef, 0x00000000, 0xffff4509, 0x7ffffffe,
        0xb7fbd1bc, 0xe7f751db, 0x1fe75541, 0x9f4eac77,
        0x2f5651c2, 0xfb7d32bc, 0xfbfba77e, 0xe7cc0001
};

static u32_t modinvA[64] = {
        0x7fffffff, 0x7fffffff, 0x6fdfdbcc, 0xffffffff,
        0x7ffffffe, 0xfe7543c3, 0x7ffffffe, 0x66ef2efa,
        0x7f7db0bb, 0x47fdeea4, 0x00000001, 0x0a4ae057,
        0xfffffffe, 0x72171d0a, 0x0da50001, 0x00000000,
        0xffffffff, 0xff2f25f4, 0xfffe0000, 0x6dbfefcd,
        0x7ffffffe, 0x222822a1, 0x3ebbc94d, 0xfffedee4,
        0x7ffffffe, 0xfffee377, 0xfbff0e1b, 0x408c0001,
        0xffffffff, 0xff3f1391, 0xfff12e56, 0x5ff7ea17,
        0xffffffff, 0xfffffffe, 0x7ffffffe, 0x75f3ec4b,
        0xdfef7a36, 0xfffffffe, 0xfdff63f1, 0x51b8e54e,
        0x659d63a9, 0x6fffde39, 0x20120000, 0xfbfaa953,
        0x7fffffff, 0xfffe0001, 0x3b4b30d1, 0xff5b93e6,
        0xac800000, 0xd2d86acf, 0x7feeeb07, 0xef66c042,
        0xafff71c5, 0xff7e0520, 0xffffffff, 0xfffff7a7,
        0x0dd7b4f0, 0x7ffffffe, 0x7fffffff, 0xffffaec3,
        0xfeed9d20, 0xaefb4caf, 0xde7fe231, 0xa7950000
};

static u32_t modinvC[64] = { /* the expected output */
        0x938962f6, 0xc6e4d9db, 0xd2304e38, 0x61941b71,
        0x3b5be534, 0x2da98260, 0xb022a53c, 0xd460d4c4,
        0xc60d72da, 0x8e399f36, 0x1b524892, 0x397812e3,
        0xf47ed664, 0xcdbaf406, 0xf8c0f576, 0x3cbf0d61,
        0xcc7c7aad, 0x5e8a9c55, 0x3dcf7803, 0x24716c10,
        0x832b90af, 0xc8787f98, 0xe077177f, 0x466a778d,
        0x3a6972b5, 0x1a035033, 0xa2f0de50, 0x6c4e54c4,
        0x24ea16a8, 0x3fbd785b, 0xbb4e978c, 0x588679b9,
        0xdcbb4178, 0x646543fe, 0xe784f6ef, 0x91708d67,
        0x67c6d83b, 0x6cb48fbd, 0xe5e74009, 0xc504e586,
        0xcdd80e83, 0xf2748c10, 0xd1e925d9, 0xb86e6251,
        0x1d76d06b, 0x335e6b45, 0x59bd76b8, 0xb16ae1b5,
        0x55d12b75, 0x1402f479, 0xda04868e, 0xe11328ca,
        0x7043b737, 0x4f31e937, 0xb21b737b, 0xea9e5288,
        0xb521e885, 0x01a483f2, 0x905fd717, 0x4cfccfaa,
        0x60bc37f3, 0x8565f51d, 0x31834927, 0x277924e6
};

/* FIPS DSA test vector, from FIPS186-2.pdf Appendix5, Page 21-22
 * re-arrange into BIGNUM format (e.g. reversed word sequence without
 * change bytes inside each word.
 */
static u32_t dsa_p[] = {
    0x31c80291, 0xec0736ee, 0xf83724c2, 0x49693dfb, 0x32ab7aac,
    0xc2e9adac, 0xb7210eaf, 0xd0762fc5, 0x0d7882e5, 0xcbb8324f,
    0xfb8d0cf7, 0xeac0d83a, 0xb06869cb, 0x3d25759b, 0x492276aa,
    0x8df2a494,
};

static u32_t dsa_q[] = {
    0xdace915f, 0xed30f48e, 0x993b4f2d, 0x737ec8ee, 0xc773218c,
};

static u32_t dsa_g[] = {
    0xe6d78802, 0xc572af53, 0x464b088c, 0xc42e9f6f, 0x21925c9c,
    0x58e5b795, 0xfa24babf, 0x71cb9de5, 0x99ce2c2e, 0x3bff10f3,
    0x956cefcb, 0x299d5522, 0x5b4cb500, 0x413163a5, 0x39ea0a13,
    0x626d0278,
};

static u32_t dsa_y[] = {
    0x030ee333, 0x9630a76b, 0xf44c0669, 0x858fba33, 0x5cc0ec74,
    0x0b8c7c25, 0x1672ef66, 0x2d3a36ef, 0x75da9d21, 0x9bfd6c56,
    0x7bb62a85, 0x346f7aa7, 0x78d1b0d7, 0xa819f29d, 0xd75b1612,
    0x19131871,
};

static u32_t dsa_hash[] = {
    0x9cd0d89d, 0x7850c26c, 0xba3e2571, 0x4706816a, 0xa9993e36,
};

static u32_t dsa_r[] = {
    0x92b341c0, 0xb16ab97c, 0xb7181f95, 0x6410435c, 0x8bac1ab6,
};

static u32_t dsa_s[] = {
    0xb6dcd8c8, 0x55b4ba2d, 0x58f426d1, 0x1f56df24, 0x41e2345f,
};

static u32_t dsa_x[] = {
    0x8b260614, 0x7b2e3b49, 0xde1c0ffc, 0x3dba372f, 0x2070b322
};

static u32_t dsa_k[] = {
    0xdeaadfbf, 0x1a376b2b, 0x50e254cf, 0x1462710f, 0x358dad57
};


/* The following vector comes from SigVer15.rsp file (the P case, not the F case)
   in Perfoce ../FIPS-186-2/Test_Vectors/BroadcomRSASamples/fax,
   which originally came from Infogard
*/
static u32_t RSA_PKCS_2048_SHA256_modulus[] = {
            0xd6998e65,   0xc0a94d7d,   0x29ccf6d5,   0xb7da956c,
            0xe75a0ae7,   0xf62bfde2,   0x500f1bad,   0x84adf1a5,
            0x849f58d1,   0x012c5a6f,   0xcbbc9d5c,   0x9629c82d,
            0x5bae5036,   0x77c741f9,   0x11de895d,   0xf504d897,
            0x6ef3ed91,   0xb0b1b099,   0xa972806e,   0x1a48094e,
            0x905c51d2,   0xe5ee1eee,   0x73810789,   0xbce1588c,
            0xc7c36295,   0x372bad4d,   0x61faa0c8,   0x231f5754,
            0xc93952fb,   0xb8272120,   0xb17f3a2c,   0x9cb2e7f7,
            0x1261b7a3,   0xb543de67,   0xaeea45c8,   0x06ec22fe,
            0xa02c8c92,   0x318093a6,   0xefa25cb7,   0xbc2f2a24,
            0xd3b6ab58,   0x5c595cd7,   0x2a82e140,   0x12e18e40,
            0x693fcf01,   0x27137b2f,   0xf64a2a1b,   0xaf5524d8,
            0x9febed47,   0x869cada7,   0x9c80be91,   0xfd55a4ba,
            0xabf1af4d,   0x3b74f8ec,   0xce9b0640,   0xa7fc2737,
            0x11f47d41,   0x6a22fe65,   0x204977ab,   0x62d87e25,
            0xfd324234,   0x1bdc89f3,   0xba06628d,   0xa5cd1374,
        };

static u32_t RSA_PKCS_2048_SHA256_Msg[] = {
            0xc398b287,   0x5f7d8f07,   0x4a03efd3,   0x353f0205,
            0x11901a5a,   0x775f70d3,   0x5314378e,   0xd259e0e0,
            0x8c95afb6,   0xf4a27d2c,   0xfecfcd6c,   0x111d14cb,
            0x2eb44421,   0x60a59967,   0x66e5a695,   0x9d88a1bc,
            0x323cec62,   0x8807e71c,   0xe544f370,   0x62dac9eb,
            0x13bdfb80,   0x75a8c922,   0x171b28a4,   0x8b910fcf,
            0x8d0503c2,   0x73a7e491,   0xd7d9f817,   0x816e371d,
            0x9925d8b0,   0x0d611abe,   0x3f2d56f1,   0xf16e44ce
        };

static u32_t RSA_PKCS_2048_SHA256_S[] = {
            0x12d04f66,   0x48a4bde8,   0x791a15b3,   0x3acd1d48,
            0x19688b1b,   0xb0d93c8a,   0x77eddd99,   0xc8201e60,
            0xe7411647,   0xdcada465,   0x2106210c,   0x92ca8654,
            0x07fa96d4,   0x40532743,   0xce5515a6,   0x83279681,
            0xd8bdb1a2,   0x6170e28e,   0xd0998764,   0xa2b737c5,
            0x4468c7fd,   0x1cf87509,   0x02882fb1,   0x8fe992fa,
            0x5d06cc6f,   0x0141eb8c,   0xd479c381,   0xc6bc2514,
            0x3e07c731,   0x9fba9e78,   0xa80b842b,   0x5d309680,
            0x049198d3,   0xd5c9743a,   0xe7d6df2e,   0x2af6a6d9,
            0x663969b1,   0xaa4df33a,   0xda1b234b,   0x224b5f85,
            0xa0f3fdcf,   0xdfe16f0e,   0x861d09ac,   0x9ecc8881,
            0xad05de2d,   0x569d3f01,   0xe536be60,   0x6f93ff17,
            0xea9f400f,   0x92e425fc,   0xf1cfb412,   0xa73fc23e,
            0xe523d4d6,   0x01cfaa4c,   0xd1c4e572,   0x3e0d2368,
            0x411608ab,   0x19197944,   0x5a684fd4,   0x2545ad6b,
            0xe874a539,   0x7c721c6a,   0x3617321c,   0x102f6c14,
        };

/* ***************************************************************************
 * Private Functions Prototypes
 * ****************************************************************************/

/* ***************************************************************************
 * Public Functions
 * ****************************************************************************/
/*---------------------------------------------------------------
 * Name    : crypto_pka_selftest_modexp
 * Purpose : Perform RSA mod exponentiation to verify the RSA mod exponent API
 * Input   : crypto library handle
 * Output  : None
 * Return  : BCM_SCAPI_STATUS test status
 * Remark  : This tests performs tests on
 *           crypto_pka_math_accelerate() API with BCM_SCAPI_MATH_MODEXP
 *
 *   The test calculates the mod exponent and compares the values with the
 *   expected mod exponent.
 *--------------------------------------------------------------*/

BCM_SCAPI_STATUS crypto_pka_selftest_modexp(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS status;
	u32_t result_modexpC[MODEXP_SIZE_N>>2];
	u32_t result_len;

	memset(result_modexpC, 0, MODEXP_SIZE_N);

	status = crypto_pka_math_accelerate(pHandle, BCM_SCAPI_MATH_MODEXP,
			(u8_t *)modexpN, BYTELEN2BITLEN(sizeof(modexpN)),
			(u8_t *)modexpA, BYTELEN2BITLEN(sizeof(modexpA)),
			(u8_t *)modexpB, BYTELEN2BITLEN(sizeof(modexpB)),
			(u8_t *)result_modexpC, /* output */ &result_len,
			NULL, 0);

	if (status == BCM_SCAPI_STATUS_OK) {
		printk("Compare the exponentiation result\n");
		if (!secure_memeql((u8_t*)result_modexpC, (u8_t*)modexpC,
				   MODEXP_SIZE_N)) {
			return BCM_SCAPI_STATUS_SELFTEST_MODEXP_FAIL;
		} else {
			return 0;
		}
	}
	return status;
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_selftest_modinv
 * Purpose : Perform RSA mod inv to verify the RSA mod inversion API
 * Input   : crypto library handle
 * Output  : None
 * Return  : BCM_SCAPI_STATUS test status
 * Remark  : This tests performs tests on
 *           crypto_pka_math_accelerate() API with BCM_SCAPI_MATH_MODINV
 *
 *   The test calculates the mod inversion and compares the values with the
 *   expected mod inversion.
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_selftest_modinv(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS status;
	u32_t result_modinvC[MODINV_SIZE_N>>2];
	u32_t result_len;

	secure_memclr(result_modinvC, MODINV_SIZE_N);

	status = crypto_pka_math_accelerate(pHandle, BCM_SCAPI_MATH_MODINV,
			(u8_t *)modinvN, BYTELEN2BITLEN(sizeof(modinvN)),
			(u8_t *)modinvA, BYTELEN2BITLEN(sizeof(modinvA)),
			NULL, 0,
			(u8_t *)result_modinvC, /* output */ &result_len,
			NULL, 0);

	if (status == BCM_SCAPI_STATUS_OK)
		if (!secure_memeql((u8_t*)result_modinvC,
				   (u8_t*)modinvC, MODINV_SIZE_N))
				return BCM_SCAPI_STATUS_SELFTEST_MODINV_FAIL;
	return status;
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_selftest_rsa_keygen
 * Purpose : Perform the RSA Key Generate function test
 * Input   : crypto library handle
 * Output  : None
 * Return  : BCM_SCAPI_STATUS test status
 * Remark  : This tests performs tests on
 *           crypto_pka_rsa_key_generate() API
 *
 *   The test calculates n, d, dp, dq, and qinv, given manual prime numbers
 *   p, q and e values, and them compare the n, d, dp, dq, and qinv with
 *   the expected values.
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_selftest_rsa_keygen(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS status;

	/* Test case from XCT generation using BSAFE library RSA key
	 * generation routine */
	/* represented here in BIGNUM format i.e LSW first. */

	// RSAP e
	// 010001

	// RSAP n
	// A6168960 1DB7DC51 6A5F327B 3D1C7847 79F7B0B0 DC0A867D E4A91EBB 97F5B531

	// RSAP p
	// C8A26921 AE654B23 5A419574 35256371

	// RSAP q
	// D3EBA2DB 8E63743F E6E59F49 DDC90DC1

	// RSAP d
	// 470EE751 77057DBE 5B7B4536 D2CB866D A5B01826 3D61C014 9695F38D 62C7DC01

	// RSAP dp
	// 0E682B28 71FF700F CFD159CC 086CF0E1

	// RSAP dq
	// 9330B3F1 C9091CC2 118E653F 79D2DE41

	// RSAP pinv
	// A8A1FB27 D533CCF2 59471482 69718AF7

	// RSAP m
	// 5509AD71 7BC1C521 E312A986 7E918159 05B1C1C9 9C3CEFE9 7C565E58 92A6FCBD

	// RSAP c
	// 42880544 2D7CB3A9 8E42D314 2C90276D 7F3F50AA A9AB3BA7 ECD37E78 F2D42668

	u32_t e      = 0x00010001;	// e
	u32_t p[4] = {
	0x35256371, 0x5A419574, 0xAE654B23, 0xC8A26921
	};

	u32_t q[4] = {
	0xDDC90DC1, 0xE6E59F49, 0x8E63743F, 0xD3EBA2DB
	};
	u32_t n[8];
	u32_t d[8];
	u32_t dp[4];
	u32_t dq[4];
	u32_t qinv[4];
	/* Expcted qinv */
	u32_t Eqinv[4] = {
    0x101779EB, 0xB987EC7B, 0x31AB2B03, 0x28FB7D8A
	};

	/* Expcted n */
	u32_t En[8] = {
	0x97F5B531, 0xE4A91EBB, 0xDC0A867D, 0x79F7B0B0,
	0x3D1C7847, 0x6A5F327B, 0x1DB7DC51, 0xA6168960
	};

	/* Expcted d */
	u32_t Ed[8] = {
	0x62C7DC01, 0x9695F38D, 0x3D61C014, 0xA5B01826,
	0xD2CB866D, 0x5B7B4536, 0x77057DBE, 0x470EE751
	};

	/* Expcted dp */
	u32_t Edp[4] = {
	0x086CF0E1, 0xCFD159CC, 0x71FF700F, 0x0E682B28
	};

	/* Expcted dq */
	u32_t Edq[4] = {
	0x79D2DE41, 0x118E653F, 0xC9091CC2, 0x9330B3F1
	};

	u32_t modulus_bits = 256;
	u32_t e_bits = 17;
	u32_t p_bits = 128;
	u32_t q_bits = 128;

	u32_t n_bits = modulus_bits;
	u32_t d_bits = modulus_bits;
	u32_t dp_bits = 128;
	u32_t dq_bits = 128;
	u32_t qinv_bits = 128;

	printk("Testing crypto_pka_rsa_key_generate, manual inputs...\n");
	status = crypto_pka_rsa_key_generate (pHandle,
			modulus_bits,            /* input, requested modulus size */
			&e_bits,    (u8_t *) &e,    /* input */
			&p_bits,    (u8_t *) p,    /* manual input or generated output */
			&q_bits,    (u8_t *) q,    /* manual input or generated output */
			&n_bits,    (u8_t *) n,    /* generated output */
			&d_bits,    (u8_t *) d,    /* generated output */
			&dp_bits,   (u8_t *) dp,   /* generated output */
			&dq_bits,   (u8_t *) dq,   /* generated output */
			&qinv_bits, (u8_t *) qinv  /* generated output */
	);

	if (status == BCM_SCAPI_STATUS_OK)
	{
		printk("Compare the expected key result\n");

		if (memcmp(qinv, Eqinv, 16) || memcmp(n, En, 32) ||
			memcmp(d, Ed, 32) || memcmp(dp, Edp, 16) ||
			memcmp(dq, Edq, 16))
		{
			status = BCM_SCAPI_STATUS_SELFTEST_RSA_FAIL;
		}
		else
		{
			status = 0;
		}
	}

	return status;
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_selftest_rsa_enc
 * Purpose : Perform the selftest to verify the RSA encryption
 * Input   : crypto library handle
 * Output  : None
 * Return  : BCM_SCAPI_STATUS test status
 * Remark  : This tests performs tests on API
 *           crypto_pka_rsa_mod_exp()
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_selftest_rsa_enc(crypto_lib_handle *pHandle)
{
    u32_t e = 0x00000003;
    u32_t a = 0x00029983;
    u32_t n = 0x00078e41;
    u32_t result = 0;
    u32_t result_len = 0;
    u32_t expect = 0x00007E92;
    BCM_SCAPI_STATUS status = 0;
	u8_t sign[256]__attribute__((aligned(64)));
	u32_t sign_size;
	u8_t exponent[] = {0x03};
	u8_t input[] = {0x7f, 0x24, 0x12, 0x34, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0x1F, 0xD7, 0xC0, 0x08, 0x4A, 0x8F, 0x22, 0x52};
	u8_t modulus[] = {0xd1, 0xBF, 0xDE, 0x6C, 0xEF, 0xC7, 0x70, 0x57,
			  0xB2, 0xE4, 0x7B, 0xA6, 0x40, 0x40, 0xBC, 0x2D, 0xAD};
	u8_t expected[] = {0x24, 0xFD, 0xC2, 0x92, 0xBA, 0x61, 0xD3, 0x7B, 0xC6,
			   0xD6, 0xE0, 0x02, 0x43, 0x31, 0x6B, 0x58, 0x88};

	printk("Testing unaligned 32 bit inputs\n");
	memset(sign, 0, sizeof(sign));
	secure_memrev(input, input, sizeof(input));
	secure_memrev(modulus, modulus, sizeof(modulus));

	status = crypto_pka_rsa_mod_exp(pHandle,
			input, sizeof(input) * 8, /* Msg size in bits */
			modulus, sizeof(modulus) * 8, /* Modulus Size in bits */
			exponent, sizeof(exponent) * 8, /* Exponent in bits */
			sign, &sign_size,
			NULL, NULL); /* No callback needed */

	if (status == BCM_SCAPI_STATUS_OK) {
		printk("Compare the expected encryption result\n");
		 secure_memrev(sign, sign, sign_size);
		if (memcmp(sign, expected, sign_size))
			return BCM_SCAPI_STATUS_SELFTEST_RSA_FAIL;
	} else {
		return status;
	}

	printk("Testing aligned 32 bit inputs\n");
    status = crypto_pka_rsa_mod_exp(pHandle,
            (u8_t *)&a, 32,
            (u8_t *)&n, 32,
            (u8_t *)&e, 32,
            (u8_t *)&result, &result_len,
			NULL, 0);

	if (status == BCM_SCAPI_STATUS_OK)
	{
		printk("Compare the expected encryption result\n");

		if(memcmp((u8_t *)&result, (u8_t *)&expect, 4))
		{
			status = BCM_SCAPI_STATUS_SELFTEST_RSA_FAIL;
		}
		else
		{
			status = 0;
		}
	}
    return status;
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_selftest_rsa_dec
 * Purpose : Perform the selftest to verify the RSA decryption using the CRT
 * 			 keys
 * Input   : crypto library handle
 * Output  : None
 * Return  : BCM_SCAPI_STATUS test status
 * Remark  : This tests performs tests on API
 *           crypto_pka_rsa_mod_exp_crt()
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_selftest_rsa_dec(crypto_lib_handle *pHandle)
{

	/* TODO currently there are no CRT keys, once keys are available
	 * will be verified */
	/* Warning removal only [-Werror=unused-but-set-parameter] */
	pHandle = NULL;
	if(pHandle)
	{
		return 0;
	}
	else
	{
		return -1;
	}
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_selftest_dsa_sign
 * Purpose : Perform the DSA signature test
 * Input   : the crypto library handle
 * Return  : Appropriate status
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_selftest_dsa_sign(crypto_lib_handle *pHandle)
{
    BCM_SCAPI_STATUS status;
    u32_t rs[10] = {0};
    u32_t rs_bytelen;

    status = crypto_pka_dsa_sign(pHandle, (u8_t *)dsa_hash, (u8_t *)dsa_k,
                            (u8_t *)dsa_p, 512, (u8_t *)dsa_q,
                            (u8_t *)dsa_g, (u8_t *)dsa_x, (u8_t *)rs,
                            &rs_bytelen, NULL, NULL);

    printk("%s:%d  status =  %d. \n",__FUNCTION__,__LINE__,status);

    if (status == BCM_SCAPI_STATUS_OK)
    {
        if (memcmp(dsa_r, rs, DSA_SIZE_R) || memcmp(dsa_s, &rs[5], DSA_SIZE_S))
        {
            status = BCM_SCAPI_STATUS_SELFTEST_DSA_SIGN_FAIL;
        }
        else
        {
            status = 0;
        }
    }

    return status;
}


/*---------------------------------------------------------------
 * Name    : crypto_pka_selftest_dsa_verify
 * Purpose : Perform the DSA signature verification test
 * Input   : the crypto library handle
 * Return  : Appropriate status
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_selftest_dsa_verify(crypto_lib_handle *pHandle)
{
    BCM_SCAPI_STATUS status;
    u32_t dsa_v[] = {0x0, 0x0, 0x0, 0x0, 0x0};
    u32_t result_len;

    status = crypto_pka_dsa_verify (pHandle, (u8_t *)dsa_hash,
                            (u8_t *)dsa_p, BYTELEN2BITLEN(sizeof(dsa_p)),
                    (u8_t *)dsa_q, (u8_t *)dsa_g, (u8_t *)dsa_y, (u8_t *)dsa_r,
                    (u8_t *)dsa_s, (u8_t *)dsa_v, &result_len, NULL, NULL);

    if (status == BCM_SCAPI_STATUS_OK)
    {
        if (memcmp(dsa_v, dsa_r, DSA_SIZE_V))
        {
            status =  BCM_SCAPI_STATUS_SELFTEST_DSA_VERIFY_FAIL;
        }
        else
        {
            status = 0;
        }
    }

    return status;
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_selftest_dsa2048_sign_verify
 * Purpose : Perform the FIPS DSA signature verification test
 * Input   : the crypto library handle
 * Return  : Appropriate status
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS
crypto_pka_selftest_dsa2048_sign_verify(crypto_lib_handle *handle)
{
    BCM_SCAPI_STATUS status;

    u8_t p[] =
    {0xfb,0x3b,0x23,0x7e, 0xf1,0x18,0x29,0xd1, 0xa2,0x86,0x36,0xca,
    0xef,0x75,0xd1,0x7b,
    0x31,0x40,0x76,0x52, 0x11,0xc6,0xe6,0x90, 0x15,0x9e,0xc8,0x9a,
    0xe4,0x99,0xa0,0x26,
    0x58,0xcb,0xde,0x20, 0x23,0x8d,0x6d,0xae, 0x89,0x50,0x9a,0x4c,
    0xdc,0xaa,0x25,0x8d,
    0xd8,0x46,0xd0,0x2a, 0xd9,0x72,0x70,0xbf, 0x6e,0xc5,0xe2,0x2c,
    0xb1,0xcb,0x43,0xcc,
    0x9b,0xbf,0x9d,0x4d, 0xb8,0xbc,0x3a,0xfb, 0xa1,0x8a,0x5b,0x7e,
    0x8b,0x54,0x40,0xe9,
    0xf4,0xb4,0xed,0xe8, 0x1a,0x84,0x30,0xc0, 0xfe,0xa9,0xa9,0x09,
    0xa8,0x1f,0x76,0x7e,
    0xbe,0x69,0x03,0x92, 0x43,0x90,0x51,0xad, 0xc9,0x4f,0xcf,0x15,
    0xc9,0x71,0x07,0x32,
    0x4c,0x69,0x86,0x98, 0x5a,0x4a,0x56,0x10, 0xdd,0x41,0xb2,0x88,
    0xd2,0xda,0x2f,0x36,
    0xb0,0x37,0xa9,0x13, 0x28,0x9d,0x9d,0x0e, 0x77,0x13,0xc0,0x8b,
    0xbc,0x63,0x15,0x91,
    0x96,0x7c,0xef,0x6e, 0xcf,0x00,0x86,0xfe, 0x35,0x9b,0xa2,0x01,
    0xad,0xbc,0x5a,0xdf,
    0x43,0x77,0xf4,0x74, 0x2d,0x29,0x40,0xbd, 0x65,0x85,0xb5,0x67,
    0x27,0xc3,0x3f,0x10,
    0x23,0xf2,0x18,0x9b, 0x61,0xea,0x93,0xaf, 0x93,0x75,0x55,0x76,
    0xde,0x39,0x50,0xa7,
    0x5b,0xf1,0x6c,0xc1, 0x3d,0x97,0x9d,0x18, 0x43,0x67,0x74,0xf0,
    0xb7,0x12,0xf9,0x5b,
    0xc4,0xbc,0x09,0xd1, 0xdb,0x10,0x8c,0xaa, 0x9e,0x4b,0xeb,0xac,
    0xcc,0x07,0x94,0xb1,
    0xa5,0xe1,0x65,0xaf, 0x6a,0xa9,0x14,0xf8, 0x89,0x67,0xca,0x3b,
    0xad,0xa0,0x15,0x21,
    0xf5,0x52,0x3a,0x8f, 0x25,0xd6,0xbc,0xfd, 0x18,0x6d,0x08,0xa5,
    0x15,0x7e,0x9c,0x89 };

    u8_t q[] ={ 0xb2,0xea,0x06,0xcf, 0x54,0x43,0x22,0xc7, 0x48,0xb7,0x5f,0xf5,
                0xd4,0x86,0xe9,0x2b,
                0x85,0x4f,0x51,0x97, 0x90,0xc2,0x75,0xdf, 0x22,0x96,0xb7,0x42,
                0x9f,0x9f,0x4c,0x89 };

    u8_t g[] ={ 0xb1,0xe1,0x07,0xd3, 0xae,0x78,0xa4,0xb9, 0xb0,0xa7,0x42,0xe2,
                0xa8,0x85,0x09,0xac,
                0x56,0x5a,0x39,0xff, 0x62,0xcc,0x0d,0x5f, 0x7f,0x17,0x31,0x18,
                0xf7,0x3e,0xe2,0x65,
                0x81,0x29,0xd3,0xaa, 0x62,0x59,0xfb,0x63, 0x50,0xbf,0x88,0x6e,
                0x64,0x3f,0xad,0xac,
                0x1b,0x0b,0x05,0x8f, 0xae,0x8d,0x12,0xc3, 0x43,0x1e,0x99,0xda,
                0x67,0x1c,0xc0,0x16,
                0x8d,0x95,0xf3,0xfa, 0x3e,0xf3,0xdd,0xd9, 0x1a,0x17,0x02,0xae,
                0x58,0xe0,0x09,0xa4,
                0xeb,0x08,0x4f,0x63, 0xe1,0x0e,0x09,0x68, 0x0a,0xc9,0xda,0x3c,
                0x21,0x27,0x40,0x1c,
                0x27,0xe8,0x46,0xce, 0x2c,0xfb,0x28,0xe1, 0xad,0x3b,0xe5,0x19,
                0xcd,0x04,0x41,0x9b,
                0x79,0x52,0xc1,0xd2, 0x94,0x0d,0xbe,0xc4, 0xb2,0xc0,0x6a,0xeb,
                0x71,0x6b,0xac,0x0f,
                0xbb,0x5b,0xb5,0x13, 0xb7,0x46,0x0e,0xae, 0xfa,0xee,0xef,0x5b,
                0x75,0x5e,0xf7,0x46,
                0x8a,0x26,0x6c,0x21, 0xf4,0x69,0xe3,0x54, 0xf1,0x29,0xbb,0x76,
                0xc9,0xb9,0x2f,0x55,
                0x8c,0xad,0x14,0x26, 0x41,0x34,0x2d,0xca, 0x64,0x6a,0x17,0x43,
                0xed,0x93,0x8b,0x95,
                0x77,0x57,0x8f,0x32, 0xc2,0xb2,0x82,0x30, 0xc9,0x86,0x34,0xd8,
                0x3d,0x6d,0x16,0x2d,
                0x4c,0x38,0xbd,0xcd, 0xc5,0xb6,0x33,0x57, 0xbc,0x17,0xa3,0xad,
                0x7c,0x9b,0xe1,0x05,
                0x4a,0x4d,0x54,0x1b, 0x3c,0x7b,0xb1,0xfb, 0xf0,0x26,0x22,0x61,
                0xfd,0xe1,0x5d,0xac,
                0xb5,0xe4,0x12,0x6e, 0x3b,0x1a,0x5b,0x89, 0x21,0x7f,0x67,0xf6,
                0x31,0xd1,0x1b,0xe1,
                0x90,0x98,0x8f,0x2e, 0x6c,0x80,0xc0,0xcf, 0x71,0x23,0x41,0x21,
                0xa0,0x31,0x46,0xec };

    u8_t msg[]={0xb1,0x9c,0x69,0x9a, 0x62,0xc0,0xc7,0x86, 0x99,0xa3,0xe9,0x29,
                0x52,0x95,0xa6,0x01,
                0xdc,0x3f,0x4a,0x09, 0x11,0xb9,0x86,0xf4, 0x35,0xaa,0xb1,0x35,
                0xe9,0x75,0xe5,0x00,
                0x76,0xee,0xc4,0xe6, 0xe0,0xf1,0x72,0x50, 0x7e,0xf5,0x4a,0xa4,
                0x18,0x68,0xcc,0x4e,
                0x33,0x95,0xef,0x5b, 0xbb,0xac,0xbf,0x06, 0xc7,0xfb,0xc4,0xf8,
                0x7c,0x86,0x38,0x21,
                0x5b,0x87,0xeb,0x28, 0x2a,0xb3,0xac,0xff, 0x06,0x08,0x43,0xab,
                0xef,0x9a,0x70,0x4a,
                0xd5,0x3e,0x6b,0x82, 0x77,0x9d,0xdf,0xc7, 0x96,0xfc,0x2b,0x31,
                0x63,0xa0,0x8d,0x78,
                0x82,0x43,0xe7,0x8f, 0xf4,0xc0,0x75,0x5e, 0x63,0x1c,0x5e,0x7c,
                0x0d,0xf2,0xb1,0x61,
                0xec,0x49,0x5d,0xc5, 0x9d,0x24,0x79,0xcb, 0xb6,0x3b,0xff,0x08,
                0xc2,0xab,0x9d,0xd4 };

    u8_t priv[] =  {0x17,0x97,0x44,0x89, 0x2c,0x61,0xb5,0x0f,
                    0x71,0x6f,0xab,0xd4, 0x22,0x18,0xfa,0x10,
                    0x10,0x5e,0x61,0x36, 0xfc,0x44,0x47,0xbe,
                    0xd3,0x85,0xaa,0xeb, 0xb9,0xb5,0x24,0x3b };

    u8_t pub[] =   {0x7d,0xf7,0x1d,0x42, 0x9c,0x93,0xce,0x7c, 0x04,0xe8,0x47,
                    0xdb, 0x05,0x29,0x63,0xa4,
                    0x36,0x28,0x98,0x15, 0xa5,0x33,0xec,0x94, 0x19,0x4e,0x50,
                    0x5f, 0x6e,0xb9,0x38,0x8f,
                    0x62,0x50,0x07,0x74, 0x26,0x7a,0x72,0x43, 0x39,0x46,0xf6,
                    0xdd, 0x04,0x78,0x6b,0x63,
                    0x02,0x22,0x0b,0x32, 0x6b,0x22,0x47,0x96, 0x26,0xd6,0xaf,
                    0xca, 0xcd,0x31,0xd9,0x50,
                    0x70,0x9a,0x4f,0x63, 0xfb,0xdd,0x07,0x95, 0xe5,0xd2,0x72,
                    0x34, 0xe2,0x36,0xb1,0x92,
                    0x96,0xfe,0xcb,0xb8, 0x26,0x81,0xea,0x29, 0x2e,0xf5,0xd6,
                    0x72, 0xa4,0x31,0x00,0x2c,
                    0xa0,0x7b,0x2d,0xf9, 0x62,0x94,0x79,0x30, 0x14,0xf9,0x84,
                    0x29, 0x06,0x03,0x56,0x69,
                    0x81,0x1e,0x24,0xc5, 0x1d,0x3d,0xe8,0xed, 0x5b,0xfc,0x88,
                    0xde, 0xce,0x9f,0xcd,0xef,
                    0x98,0xb8,0x35,0xe7, 0x14,0x85,0x9a,0xc3, 0x58,0xe2,0x06,
                    0x14, 0xf4,0x12,0xfa,0xaa,
                    0x6b,0x44,0xcc,0x4d, 0xf3,0x0c,0xcd,0x9d, 0x20,0xf2,0xc4,
                    0x6a, 0xe9,0x94,0x69,0x16,
                    0x2a,0x46,0x41,0xb6, 0x1b,0x87,0x3d,0x63, 0x9a,0x04,0x48,
                    0x52, 0xe5,0x52,0x53,0xe1,
                    0x98,0x42,0xbd,0x4e, 0x6b,0x39,0x5c,0xdc, 0xaa,0x2f,0xc1,
                    0x3f, 0x16,0xd6,0x6f,0x67,
                    0xf7,0x77,0x40,0xe8, 0x66,0x7a,0x2b,0x6a, 0x42,0x1a,0x2f,
                    0x70, 0x71,0x1b,0xba,0x3c,
                    0x3c,0x92,0xe3,0x81, 0x58,0x5a,0xc5,0x0f, 0xb9,0x7a,0xe6,
                    0x1c, 0x31,0xbd,0xe9,0x4d,
                    0x80,0xd7,0xab,0x13, 0x22,0x56,0x4b,0x80, 0x04,0xb1,0xe3,
                    0xb1, 0xa8,0x20,0xfa,0xf2,
                    0x23,0xd9,0x51,0x85, 0x2c,0xdb,0xb4,0xaf, 0x03,0x74,0xcf,
                    0xf3, 0x60,0x96,0x27,0x11 };

    u8_t r[] =     { 0x77,0x47,0xb1,0xdf, 0x10,0x19,0xe3,0xb6,
                     0x37,0x28,0x78,0xb9, 0xef,0x95,0x7b,0x5b,
                     0x3f,0x0d,0x99,0x27, 0x69,0xf6,0x98,0x41,
                     0x79,0x06,0x9c,0x15, 0xfe,0x8e,0xb2,0xbe };
    u8_t s[] =     { 0x3b,0xc6,0x3c,0x2d, 0x2c,0x45,0x7b,0xb6,
                     0x30,0x06,0xc6,0x0b, 0xad,0x86,0xa7,0x6e,
                     0xcc,0x2e,0xad,0xf2, 0x1c,0x58,0x90,0xc1,
                     0x65,0x27,0x0e,0x37, 0xd1,0x9b,0xd7,0x3c };

    u8_t h[SHA256_HASH_SIZE*2]__attribute__((aligned(64)));
    u8_t sig[DSA_SIZE_SIGNATURE_2048];
    u8_t v[DSA_SIZE_V_2048];
    u32_t siglen = DSA_SIZE_SIGNATURE_2048, vlen;

    // validate verify
    status = crypto_symmetric_hmac_sha256(handle, msg, sizeof(msg),
                                      NULL, 0, h, TRUE);
    if (status != BCM_SCAPI_STATUS_OK) {
        printk("%s: hash fail status %d:\n",__func__,status);
        return BCM_SCAPI_STATUS_SELFTEST_RSA_FAIL;
    }

    memcpy(sig, r, DSA_SIZE_R_2048);
    memcpy(sig + DSA_SIZE_R_2048, s, DSA_SIZE_S_2048);

    // validate known good signature
    status = crypto_pka_dsa_verify_2048(handle, h, p, 2048, q, g, pub, sig,
            sig + SHA256_HASH_SIZE, v, &vlen, NULL, NULL);
    if (BCM_SCAPI_STATUS_OK != status) {
        printk("%s static verify failure (%d)\n", __func__, status);
        return status;
    }

    // generate signature
    status = crypto_pka_dsa_sign_2048(handle, h, NULL, p, 2048,
            q, g, priv, sig, &siglen, NULL, NULL);
    if (BCM_SCAPI_STATUS_OK != status) {
        printk("%s sign fail status = %d\n", __func__, status);
        return status;
    }

    // validate signature with verify
    status = crypto_pka_dsa_verify_2048(handle, h, p, 2048, q, g, pub,
            sig, sig + SHA256_HASH_SIZE, v, &vlen, NULL, NULL);
    if (BCM_SCAPI_STATUS_OK != status) {
        printk("%s verify failure (%d)\n", __func__, status);
        return status;
    }

    if (!secure_memeql(v, sig, DSA_SIZE_R_2048)) {
        printk("%s: verify of generated sig failed\n", __func__);
        return BCM_SCAPI_STATUS_SELFTEST_DSA_VERIFY_FAIL;
    }

    return BCM_SCAPI_STATUS_OK;
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_selftest_dh
 * Purpose : Perform the Diffie-Hellman function tests
 * Input   : the crypto library handle
 * Output  : None
 * Return  : void
 * Remark  : This tests performs tests on
 *           1. crypto_pka_diffie_hellman_generate()
 *           2. crypto_pka_diffie_hellman_shared_secret()
 *   The test generates two DH key pairs using common DH generator
 *   and modulus values. Then it compute DH shared secrets and
 *   compare them.
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_selftest_dh(crypto_lib_handle *pHandle)
{
    BCM_SCAPI_STATUS status;
    u32_t dh_m[] =
    {
        0xffffffff, 0xffffffff, 0x8aacaa68, 0x15728e5a,
        0x98fa0510, 0x15d22618, 0xea956ae5, 0x3995497c,
        0x95581718, 0xde2bcbf6, 0x6f4c52c9, 0xb5c55df0,
        0xec07a28f, 0x9b2783a2, 0x180e8603, 0xe39e772c,
        0x2e36ce3b, 0x32905e46, 0xca18217c, 0xf1746c08,
        0x4abc9804, 0x670c354e, 0x7096966d, 0x9ed52907,
        0x208552bb, 0x1c62f356, 0xdca3ad96, 0x83655d23,
        0xfd24cf5f, 0x69163fa8, 0x1c55d39a, 0x98da4836,
        0xa163bf05, 0xc2007cb8, 0xece45b3d, 0x49286651,
        0x7c4b1fe6, 0xae9f2411, 0x5a899fa5, 0xee386bfb,
        0xf406b7ed, 0x0bff5cb6, 0xa637ed6b, 0xf44c42e9,
        0x625e7ec6, 0xe485b576, 0x6d51c245, 0x4fe1356d,
        0xf25f1437, 0x302b0a6d, 0xcd3a431b, 0xef9519b3,
        0x8e3404dd, 0x514a0879, 0x3b139b22, 0x020bbea6,
        0x8a67cc74, 0x29024e08, 0x80dc1cd1, 0xc4c6628b,
        0x2168c234, 0xc90fdaa2, 0xffffffff, 0xffffffff,
    };

    u32_t dh_g[1] = {2};
    u32_t Ax[8] = {0}, Ay[64] = {0}, Ak[64] = {0}, Ay_bytelen, Ak_bytelen;
    u32_t Bx[8] = {0}, By[64] = {0}, Bk[64] = {0}, By_bytelen, Bk_bytelen;

    printk("Generating DH pair Ax, Ay...\n");
    status = crypto_pka_diffie_hellman_generate(pHandle, (u8_t*)(Ax), 256,
                                                0, (u8_t*)(Ay), &Ay_bytelen,
                                                (u8_t*)(dh_g), 32,
                                                (u8_t*)(dh_m), 2048,
                                                NULL, NULL);
    if (BCM_SCAPI_STATUS_OK != status)
    {
        printk("%s Generating DH pair Ax, Ay failed, status = %d\n",
                __func__, status);
        return status;
    }

    printk("Generating DH pair Bx, By...\n");
    status = crypto_pka_diffie_hellman_generate(pHandle, (u8_t*)(Bx), 256,
                                                0, (u8_t*)(By), &By_bytelen,
                                                (u8_t*)(dh_g), 32,
                                                (u8_t*)(dh_m), 2048,
                                                NULL, NULL);
    if (BCM_SCAPI_STATUS_OK != status)
    {
        printk("%s Generating DH pair Bx, By failed, status = %d\n",
                __func__, status);
        return status;
    }

    printk("Computing DH Shared secret Ak...\n");
    status = crypto_pka_diffie_hellman_shared_secret(pHandle, (u8_t*)(Ax), 256,
            (u8_t*)(By), 2048,
            (u8_t*)(dh_m), 2048, (u8_t*)(Ak), &Ak_bytelen,
                                              NULL, NULL);
    if (BCM_SCAPI_STATUS_OK != status)
    {
        printk("%s Computing DH Shared secret Ak failed status = %d\n",
                __func__, status);
        return status;
    }

    printk("Computing DH Shared secret Bk...\n");
    status = crypto_pka_diffie_hellman_shared_secret(pHandle, (u8_t*)(Bx), 256,
            (u8_t*)(Ay), 2048,
            (u8_t*)(dh_m), 2048, (u8_t*)(Bk), &Bk_bytelen,
                                              NULL, NULL);
    if (BCM_SCAPI_STATUS_OK != status)
    {
        printk("%s Computing DH Shared secret Bk failed status = %d\n",
                __func__, status);
        return status;
    }

    printk("Comparing DH Shared secrets Ak and Bk...\n");
    if (memcmp(Ak, Bk, Ak_bytelen))
    {
        status = BCM_SCAPI_STATUS_SELFTEST_DH_FAIL;
    }
    else
    {
        status = BCM_SCAPI_STATUS_OK;
    }
    printk("DH tests: All Done\n");

    return status;

}

/*---------------------------------------------------------------
 * Name    : crypto_pka_selftest_ecdh
 * Purpose : Perform the Elliptic Curve Diffie-Hellman function tests
 * Input   : the crypto library handle
 * Output  : None
 * Return  : void
 * Remark  : This tests performs tests on
 *           1. crypto_pka_ecp_diffie_hellman_generate()
 *           2. crypto_pka_ecp_diffie_hellman_shared_secret()
 *   The test generates two ECDH key pairs using common ECC
 *   parameters. Then it compute ECDH shared secrets and
 *   compare them.
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_selftest_ecdh(crypto_lib_handle *pHandle)
{
    BCM_SCAPI_STATUS status;

   /* ECC curve vectors from FIPS 186-2-change1.pdf, Page 29, Curve P-192,
      and represented here in BIGNUM format i.e LSW first. */

   u32_t A[6] = {
       0xFFFFFFFC, 0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
   };

   u32_t B[6] = {
       0xC146B9B1, 0xFEB8DEEC, 0x72243049, 0x0FA7E9AB, 0xE59C80E7, 0x64210519
   };

   u32_t p[6] = {
       0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
   };

   u32_t n[6] = {
       0xB4D22831, 0x146BC9B1, 0x99DEF836, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF
   };

   u32_t GX[6] = {
       0x82FF1012, 0xF4FF0AFD, 0x43A18800, 0x7CBF20EB, 0xB03090F6, 0x188DA80E
   };

   u32_t GY[6] = {
       0x1E794811, 0x73F977A1, 0x6B24CDD5, 0x631011ED, 0xFFC8DA78, 0x07192B95
   };

   u32_t A_pubx[6] = {0}, A_puby[6] = {0};
   u32_t B_pubx[6] = {0}, B_puby[6] = {0};
   u32_t A_ssx[6] = {0}, A_ssy[6] = {0}, B_ssx[6] = {0}, B_ssy[6] = {0};

   /* These are fixed random number generate them */
   u32_t A_priv[6];
   u32_t B_priv[6];

   printk("Generating ECDH pair 1...\n");
   status = crypto_pka_ecp_diffie_hellman_generate (pHandle, 0, (u8_t*)(p),
                                   192, (u8_t*)(A), (u8_t*)(B), (u8_t*)(n),
                                   (u8_t*)(GX), (u8_t*)(GY), (u8_t*)(A_priv),
                                   0, (u8_t*)(A_pubx), (u8_t*)(A_puby),
                                   NULL, NULL);

   if (BCM_SCAPI_STATUS_OK != status)
   {
       printk("%s Generating ECDH pair 1 failed, status = %d\n",
               __func__, status);
       return status;
   }

   printk("Generating ECDH pair 2...\n");
   status = crypto_pka_ecp_diffie_hellman_generate (pHandle, 0, (u8_t*)(p),
                                   192, (u8_t*)(A), (u8_t*)(B), (u8_t*)(n),
                                   (u8_t*)(GX), (u8_t*)(GY), (u8_t*)(B_priv),
                                   0, (u8_t*)(B_pubx), (u8_t*)(B_puby),
                                   NULL, NULL);

   if (BCM_SCAPI_STATUS_OK != status)
   {
       printk("%s Generating ECDH pair 2 failed, status = %d\n",
               __func__, status);
       return status;
   }


   printk("Computing ECDH Shared secret 1...\n");
   status = crypto_pka_ecp_diffie_hellman_shared_secret (pHandle, 0, (u8_t*)(p),
                                       192, (u8_t*)(A), (u8_t*)(B), (u8_t*)(n),
                                       (u8_t*)(A_priv), (u8_t*)(B_pubx),
                                       (u8_t*)(B_puby), (u8_t*)(A_ssx),
                                       (u8_t*)(A_ssy), NULL, NULL);

   if (BCM_SCAPI_STATUS_OK != status)
   {
       printk("%s Computing ECDH Shared secret 1 failed status = %d\n",
               __func__, status);
       return status;
   }

   printk("Computing ECDH Shared secret 2...\n");
   status = crypto_pka_ecp_diffie_hellman_shared_secret (pHandle, 0, (u8_t*)(p),
                                       192, (u8_t*)(A), (u8_t*)(B), (u8_t*)(n),
                                       (u8_t*)(B_priv), (u8_t*)(A_pubx),
                                       (u8_t*)(A_puby), (u8_t*)(B_ssx),
                                       (u8_t*)(B_ssy), NULL, NULL);

   if (BCM_SCAPI_STATUS_OK != status)
   {
       printk("%s Computing ECDH Shared secret 2 failed status = %d\n",
               __func__, status);
       return status;
   }

   printk("Comparing ECDH Shared secrets...\n");
   if (memcmp(A_ssx, B_ssx, 24) | memcmp(A_ssy, B_ssy, 24))
   {
      status = BCM_SCAPI_STATUS_SELFTEST_ECDH_FAIL;
   }
   else
   {
       status = BCM_SCAPI_STATUS_OK;
   }

   printk("ECDH tests: All Done\n");
   return status;
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_fips_selftest_ecdh
 * Purpose : Perform the Elliptic Curve Diffie-Hellman to test the key
 * 	     generation.
 * Input   : the crypto library handle
 * Output  : None
 * Return  : void
 * Remark  : This tests performs tests on
 *           1. crypto_pka_ecp_diffie_hellman_generate()
 *           2. crypto_pka_ecp_diffie_hellman_shared_secret()
 *   The test generates two ECDH key pairs using common ECC
 *   parameters. Then it compute ECDH shared secrets and
 *   compare them.
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_fips_selftest_ecdh(crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS status = BCM_SCAPI_STATUS_OK;

	u32_t A[8]  = {0xfffffffc, 0xffffffff, 0xffffffff, 0x00000000,
			  0x00000000, 0x00000000, 0x00000001, 0xffffffff};
	u32_t B[8]  = {0x27d2604b, 0x3bce3c3e, 0xcc53b0f6, 0x651d06b0,
			  0x769886bc, 0xb3ebbd55, 0xaa3a93e7, 0x5ac635d8};
	u32_t p[8]  = {0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
			  0x00000000, 0x00000000, 0x00000001, 0xffffffff};
	u32_t n[8]  = {0xfc632551, 0xf3b9cac2, 0xa7179e84, 0xbce6faad,
			  0xffffffff, 0xffffffff, 0x00000000, 0xffffffff};
	u32_t GX[8] = {0xd898c296, 0xf4a13945, 0x2deb33a0, 0x77037d81,
			  0x63a440f2, 0xf8bce6e5, 0xe12c4247, 0x6b17d1f2};
	u32_t GY[8] = {0x37bf51f5, 0xcbb64068, 0x6b315ece, 0x2bce3357,
			  0x7c0f9e16, 0x8ee7eb4a, 0xfe1a7f9b, 0x4fe342e2};

	u32_t A_priv[8] = {0}, A_pubx[8] = {0}, A_puby[8] = {0};

	/* Generate Point A */
	status = crypto_pka_ecp_diffie_hellman_generate(pHandle, 0,
					(u8_t*) p, 256,
					(u8_t*) A, (u8_t*) B,
					(u8_t*) n,
					(u8_t*) GX, (u8_t*) GY,
					(u8_t*) A_priv, 0,
					(u8_t*) A_pubx, (u8_t*) A_puby,
					NULL, NULL);

	if (status != BCM_SCAPI_STATUS_OK) {
		printk("%s Generating ECDH pair A failed, status = %d\n",
		               __func__, status);
		return BCM_SCAPI_STATUS_SELFTEST_DH_FAIL;
	}

	/* Test against a point B */
	status = crypto_pka_fips_test_ecdh_key(pHandle, (u8_t*)(A_priv),
					(u8_t*)(A_pubx), (u8_t*)(A_puby));
	if (status != BCM_SCAPI_STATUS_OK) {
		printk("%s Comparing ECDH Shared secrets, status = %d\n",
		               __func__, status);
		return BCM_SCAPI_STATUS_SELFTEST_DH_FAIL;
	}

	return status;
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_fips_test_ecdh_key
 * Purpose : Perform the Elliptic Curve Diffie-Hellman key generation test
 * Input   : the crypto library handle
 * Output  : None
 * Return  : void
 * Remark  : This tests performs tests on
 *           1. crypto_pka_ecp_diffie_hellman_generate()
 *           2. crypto_pka_ecp_diffie_hellman_shared_secret()
 *   The test generates two ECDH key pairs using common ECC
 *   parameters. Then it compute ECDH shared secrets and
 *   compare them.
 *   This API is used in the crypto_pka_fips_selftest_ecdh
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_fips_test_ecdh_key(crypto_lib_handle *pHandle,
		u8_t* A_priv, u8_t* A_pubx,
		u8_t* A_puby)
{
	BCM_SCAPI_STATUS status = BCM_SCAPI_STATUS_OK;

	u32_t A[8]  = {0xfffffffc, 0xffffffff, 0xffffffff, 0x00000000,
			0x00000000, 0x00000000, 0x00000001, 0xffffffff};
	u32_t B[8]  = {0x27d2604b, 0x3bce3c3e, 0xcc53b0f6, 0x651d06b0,
			0x769886bc, 0xb3ebbd55, 0xaa3a93e7, 0x5ac635d8};
	u32_t p[8]  = {0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
			0x00000000, 0x00000000, 0x00000001, 0xffffffff};
	u32_t n[8]  = {0xfc632551, 0xf3b9cac2, 0xa7179e84, 0xbce6faad,
			0xffffffff, 0xffffffff, 0x00000000, 0xffffffff};
	u32_t GX[8] = {0xd898c296, 0xf4a13945, 0x2deb33a0, 0x77037d81,
			0x63a440f2, 0xf8bce6e5, 0xe12c4247, 0x6b17d1f2};
	u32_t GY[8] = {0x37bf51f5, 0xcbb64068, 0x6b315ece, 0x2bce3357,
			0x7c0f9e16, 0x8ee7eb4a, 0xfe1a7f9b, 0x4fe342e2};

	u32_t B_priv[8] = {0}, B_pubx[8] = {0}, B_puby[8] = {0};

	u32_t A_ssx[8]  = {0}, A_ssy[8]  = {0}, B_ssx[8] = {0}, B_ssy[8] = {0};

	/* Generate keyB */
	status = crypto_pka_ecp_diffie_hellman_generate(pHandle, 0,
			(u8_t*) p, 256,
			(u8_t*) A, (u8_t*) B, (u8_t*) n,
			(u8_t*) GX, (u8_t*) GY,
			(u8_t*) B_priv, 0,
			(u8_t*) B_pubx, (u8_t*) B_puby,
			NULL, NULL);
	if (status != BCM_SCAPI_STATUS_OK) {
		printk("%s Generating ECDH pair B failed, status = %d\n",
		               __func__, status);
		return BCM_SCAPI_STATUS_SELFTEST_DH_FAIL;
	}

	/* Generate A's SS */
	status = crypto_pka_ecp_diffie_hellman_shared_secret(pHandle, 0,
			(u8_t*) p, 256,
			(u8_t*) A, (u8_t*) B, (u8_t*) n,
			(u8_t*) A_priv, (u8_t*) B_pubx, (u8_t*) B_puby,
			(u8_t*) A_ssx, (u8_t*) A_ssy,
			NULL, NULL);
	if (status != BCM_SCAPI_STATUS_OK) {
		printk("%s Generating shared secret A failed, status = %d\n",
		               __func__, status);
		return BCM_SCAPI_STATUS_SELFTEST_DH_FAIL;
	}

	/* Generate B's SS */
	status = crypto_pka_ecp_diffie_hellman_shared_secret(pHandle, 0,
			(u8_t*) p, 256,
			(u8_t*) A, (u8_t*) B, (u8_t*) n,
			(u8_t*) B_priv, (u8_t*) A_pubx, (u8_t*) A_puby,
			(u8_t*) B_ssx, (u8_t*) B_ssy,
			NULL, NULL);
	if (status != BCM_SCAPI_STATUS_OK) {
		printk("%s Generating shared secret B failed, status = %d\n",
		               __func__, status);
		return BCM_SCAPI_STATUS_SELFTEST_DH_FAIL;
	}

	/* Check that we match */
	if (!secure_memeql((u8_t*)A_ssx, (u8_t*)B_ssx, 32) ||
	    !secure_memeql((u8_t*)A_ssy, (u8_t*)B_ssy, 32))
		return BCM_SCAPI_STATUS_SELFTEST_DH_FAIL;

	return status;
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_selftest_ecdsa_sign_verify
 * Purpose : Perform the FIPS Elliptic Curve DSA sign & verify tests
 * Input   : the crypto library handle
 * Output  : None
 * Return  : Appropriate status
 * Remark  : This tests performs tests on
 *           1. crypto_pka_ecp_ecdsa_sign()
 *           2. crypto_pka_ecp_ecdsa_verify()
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_selftest_ecdsa_sign_verify(
        crypto_lib_handle *pHandle)
{
    BCM_SCAPI_STATUS status;

    /* ECC curve vectors from FIPS 186-2-change1.pdf, Page 29, Curve P-256,
    and represented here in BIGNUM format i.e LSW first. */
    u32_t A[8]  = {0xfffffffc, 0xffffffff, 0xffffffff, 0x00000000,
                    0x00000000, 0x00000000, 0x00000001, 0xffffffff};
    u32_t B[8]  = {0x27d2604b, 0x3bce3c3e, 0xcc53b0f6, 0x651d06b0,
                    0x769886bc, 0xb3ebbd55, 0xaa3a93e7, 0x5ac635d8};
    u32_t p[8]  = {0xffffffff, 0xffffffff, 0xffffffff, 0x00000000,
                    0x00000000, 0x00000000, 0x00000001, 0xffffffff};
    u32_t n[8]  = {0xfc632551, 0xf3b9cac2, 0xa7179e84, 0xbce6faad,
                    0xffffffff, 0xffffffff, 0x00000000, 0xffffffff};
    u32_t GX[8] = {0xd898c296, 0xf4a13945, 0x2deb33a0, 0x77037d81,
                    0x63a440f2, 0xf8bce6e5, 0xe12c4247, 0x6b17d1f2};
    u32_t GY[8] = {0x37bf51f5, 0xcbb64068, 0x6b315ece, 0x2bce3357,
                    0x7c0f9e16, 0x8ee7eb4a, 0xfe1a7f9b, 0x4fe342e2};
    /* The private key d:*/
    u32_t d[8]  = {0x3452b38a, 0x9f2d7d5b, 0x851bf634, 0x3f04d7d6,
                    0xc21a472b, 0x56ff68cf, 0xb16845ed, 0x70a12c2d};
    /* The public key Q = dG = (xQ, yQ):*/
    u32_t QX[8] = {0xf26680a8, 0xf7635eaf, 0x2d22cba4, 0x8691a326,
                    0x6e2bd3d8, 0xd70cf69a, 0x7464a6ea, 0x8101ece4};
    u32_t QY[8] = {0x36c0c3a9, 0xa6240799, 0x8f0a5aba, 0xd3ca43e7,
                    0xd58f1783, 0xf67d9cb4, 0x1d599235, 0xd8a12ba6};
    u32_t QZ[8] = {0x00000001, 0x00000000, 0x00000000, 0x00000000,
                    0x00000000, 0x00000000, 0x00000000, 0x00000000};
    u32_t h[8]  = {0xba2b8377, 0xf020bd39, 0xbb59e9c5, 0x8f30f9d6,
                    0x9324222c, 0xf96eac5e, 0xdc8bd688, 0x7c3e883d};
    /*Signature */
    u32_t ER[8] = {0xd4e6f27c, 0x61e805d5, 0x86bb8156, 0xddd70ddf,
                    0x533f5dc6, 0x39ff2f80, 0x47160bbd, 0x7214bc96};
    u32_t ES[8] = {0xaf2bc367, 0x92dbeaa1, 0xf9e14935, 0x3317d3e3,
                    0x6209f401, 0xdaa3233b, 0x980f961b, 0x7d1ff961};
    /* Random integer */
    u32_t k[8]  = {0x34ee45d0, 0x1965c7b1, 0xfa47055b, 0x5b12ae37,
                    0xecaed496, 0x4cef3f71, 0x85643433, 0x580ec00d};

    u32_t QR[8];
    u32_t QS[8];

    /* Testing bcm_ecp_ecdsa_sign, external random number... */
    status = crypto_pka_ecp_ecdsa_sign(pHandle, (u8_t *)h,
                32, 0, (u8_t *)p, 256,
                (u8_t *)A, (u8_t *)B, (u8_t *)n, (u8_t *)GX, (u8_t *)GY,
                (u8_t *)k, 1, (u8_t *)d, (u8_t *)QR, (u8_t *)QS, NULL, NULL);

    if (status != BCM_SCAPI_STATUS_OK) {
        return status;
    }

    if (!secure_memeql((u8_t*)QR, (u8_t*)ER, 32) ||
        !secure_memeql((u8_t*)QS, (u8_t*)ES, 32)) {
        printk("Signature comparison failed\n");
        return(BCM_SCAPI_STATUS_SELFTEST_ECDSA_SIGN_FAIL);
    }

    /* Testing bcm_ecp_ecdsa_verify... */
    status = crypto_pka_ecp_ecdsa_verify(pHandle, (u8_t *)h,
                32, 0, (u8_t *)p, 256,
                (u8_t *)A, (u8_t *)B, (u8_t *)n, (u8_t *)GX, (u8_t *)GY,
                (u8_t *)QX, (u8_t *)QY, (u8_t *)QZ, (u8_t *)ER, (u8_t *)ES,
                NULL, NULL);

    if (status != BCM_SCAPI_STATUS_OK) {
        return status;
    }

    /* Testing bcm_ecp_ecdsa_verify fail case */
    h[0]++;
    status = crypto_pka_ecp_ecdsa_verify(pHandle, (u8_t *)h, 32,
                0, (u8_t *)p, 256,
                (u8_t *)A, (u8_t *)B, (u8_t *)n, (u8_t *)GX, (u8_t *)GY,
                (u8_t *)QX, (u8_t *)QY, (u8_t *)QZ, (u8_t *)ER, (u8_t *)ES,
                NULL, NULL);

    /* should fail */
    if (status == BCM_SCAPI_STATUS_OK)
    {
        return BCM_SCAPI_STATUS_ECDSA_VERIFY_FAIL;
    }

    return ( BCM_SCAPI_STATUS_OK );
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_cust_selftest_ecdsa_p256_sign_verify
 * Purpose : To test Elliptic curve DSA signature with SHA-256 on NIST P-256 curve Signature
 * Input   : None
 * Return  : On success(= 0)
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_cust_selftest_ecdsa_p256_sign_verify(
                                        crypto_lib_handle *pHandle)
{
    BCM_SCAPI_STATUS status=BCM_SCAPI_STATUS_OK;

    /* Private Key */
    u32_t priv[8]  = {0x3452b38a, 0x9f2d7d5b, 0x851bf634, 0x3f04d7d6,
                      0xc21a472b, 0x56ff68cf, 0xb16845ed, 0x70a12c2d};
    /* Message */
    u32_t message[8]  = {0xba2b8377, 0xf020bd39, 0xbb59e9c5, 0x8f30f9d6,
                         0x9324222c, 0xf96eac5e, 0xdc8bd688, 0x7c3e883d};

    /*The public key Q = dG = (xQ, yQ):*/
    u32_t publicKey[16] = {0xf26680a8, 0xf7635eaf, 0x2d22cba4, 0x8691a326,
                           0x6e2bd3d8, 0xd70cf69a, 0x7464a6ea, 0x8101ece4,
                           0x36c0c3a9, 0xa6240799, 0x8f0a5aba, 0xd3ca43e7,
                           0xd58f1783, 0xf67d9cb4, 0x1d599235, 0xd8a12ba6};
    u32_t signature[16];

    status = crypto_pka_cust_ecdsa_p256_sign((crypto_lib_handle *)pHandle,
                            (u8_t *)priv,32,(u8_t *)message,(u8_t *)signature);

    printk("%s:%d  status =  %d. \n",__FUNCTION__,__LINE__,status);

    status = crypto_pka_cust_ecdsa_p256_verify((crypto_lib_handle *)pHandle,
                            (u8_t *)publicKey, 32,(u8_t *)message,
                            (u8_t *)signature);
    if (status == BCM_SCAPI_STATUS_OK)
    {
        printk("%s:%d  ecdsa P-256 functionality is working fine. \n",
                __FUNCTION__,__LINE__);
    }
    else
    {
        printk("%s:%d  ecdsa P-256 functionality is not working %d. \n",
                __FUNCTION__,__LINE__,status);
    }

    return status;
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_cust_selftest_ecp_diffie_hellman_shared_secret
 * Purpose : To test Elliptic curve DSA signature with SHA-256 on
 *              NIST P-256 curve
 * Input   : None
 * Return  : On success(= 0)
 *--------------------------------------------------------------*/
/*
Taken from KAS_ECC_CDH_PrimitiveTest.txt
http://csrc.nist.gov/groups/STM/cavp/documents/components/ecccdhtestvectors.zip
[P-256]

COUNT = 0
QCAVSx = 700c48f77f56584c5cc632ca65640db91b6bacce3a4df6b42ce7cc838833d287
QCAVSy = db71e509e3fd9b060ddb20ba5c51dcc5948d46fbf640dfe0441782cab85fa4ac
dIUT = 7d7dc5f71eb29ddaf80d6214632eeae03d9058af1fb6d22ed80badb62bc1a534
QIUTx = ead218590119e8876b29146ff89ca61770c4edbbf97d38ce385ed281d8a6b230
QIUTy = 28af61281fd35e2fa7002523acc85a429cb06ee6648325389f59edfce1405141
ZIUT = 46fc62106420ff012e54a434fbdd2d25ccc5852060561e68040dd7778997bd7b

Convert the above big-endian format into BIGNUM format.
*/
BCM_SCAPI_STATUS crypto_pka_cust_selftest_ecp_diffie_hellman_shared_secret(
                                                crypto_lib_handle *pHandle)
{
    BCM_SCAPI_STATUS status=BCM_SCAPI_STATUS_OK;

    u32_t priv[8]  =   {0x2bc1a534, 0xd80badb6, 0x1fb6d22e, 0x3d9058af,
                        0x632eeae0, 0xf80d6214, 0x1eb29dda, 0x7d7dc5f7};

    u32_t pubKey[16] = {0x8833d287, 0x2ce7cc83, 0x3a4df6b4, 0x1b6bacce,
                        0x65640db9, 0x5cc632ca, 0x7f56584c, 0x700c48f7,
                        0xb85fa4ac, 0x441782ca, 0xf640dfe0, 0x948d46fb,
                        0x5c51dcc5, 0x0ddb20ba, 0xe3fd9b06, 0xdb71e509};

    u32_t expectedSecret[8] = {0x8997bd7b, 0x040dd777, 0x60561e68, 0xccc58520,
                               0xfbdd2d25, 0x2e54a434, 0x6420ff01, 0x46fc6210};
    u8_t sharedSecret[64];

    status = crypto_pka_cust_ecp_diffie_hellman_shared_secret(
                                (crypto_lib_handle *)pHandle, (u8_t*)priv,
                                (u8_t*)pubKey,sharedSecret);

    if ((status == BCM_SCAPI_STATUS_OK) &&
        (memcmp(expectedSecret, sharedSecret, sizeof(expectedSecret))==0))
    {
        printk("%s:%d  ecp DH P-256 functionality is working fine. \n",
                __FUNCTION__,__LINE__);
    }
    else
    {
        printk("%s:%d  ecp DH P-256 functionality is not working %d. \n",
                __FUNCTION__,__LINE__,status);
    }

    return status;
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_cust_selftest_ecdsa_p256_key_generate
 * Purpose : To test Elliptic curve DSA pair key with SHA-256 on
 *           NIST P-256 curve Signature
 * Input   : None
 * Return  : On success(= 0)
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_cust_selftest_ecdsa_p256_key_generate(
                                    crypto_lib_handle *pHandle)
{
    BCM_SCAPI_STATUS status=BCM_SCAPI_STATUS_OK;

    /* Private Key */
    u32_t priv[8];
    /*The public key Q = dG = (xQ, yQ):*/
    u32_t publicKey[16];

    status = crypto_pka_cust_ecdsa_p256_key_generate(
                                          (crypto_lib_handle *)pHandle,
                                          (u8_t *)priv,(u8_t *)publicKey);
    printk("%s:%d  status =  %d. \n",__FUNCTION__,__LINE__,status);

    if (status == BCM_SCAPI_STATUS_OK)
    {
        printk("%s:%d  ecdsa P-256 key Gen functionality is working fine.\n",
            __FUNCTION__,__LINE__);
    }
    else
    {
        printk("%s:%d  ecdsa P-256 key Gen functionality is not working %d.\n",
            __FUNCTION__,__LINE__,status);
    }

    return status;
}


/*---------------------------------------------------------------
 * Name    : crypto_pka_cust_selftest_ec_point_verify
 * Purpose : To test Elliptic curve DSA pair key with SHA-256 on NIST P-256 curve Signature
 * Input   : None
 * Return  : On success(= 0)
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_cust_selftest_ec_point_verify(
                                            crypto_lib_handle *pHandle)
{
    BCM_SCAPI_STATUS status = BCM_SCAPI_STATUS_OK;

    u32_t priv[8];/* Private Key */
    u8_t pubkey[64];/*The public key Q = dG = (xQ, yQ):*/

    status = crypto_pka_cust_ecdsa_p256_key_generate(
                (crypto_lib_handle *)pHandle, (u8_t *)priv, (u8_t *)pubkey);
    if (status != BCM_SCAPI_STATUS_OK)
    {
        printk("%s:%d  key generate failed: status:%d. \n",
            __FUNCTION__, __LINE__, status);
    }
    else
    {
        printk("\npublic key: \n");
    }

    status = crypto_pka_cust_ec_point_verify((crypto_lib_handle *)pHandle,
                                         pubkey);
    if (status != BCM_SCAPI_STATUS_OK)
    {
        printk("%s:%d  primary key is not on elliptic curve status:%d. \n",
            __FUNCTION__, __LINE__, status);
    }
    else
    {
        printk("%s:%d  primary key is on elliptic curve status:%d. \n",
            __FUNCTION__, __LINE__, status);
    }

    return status;
}

BCM_SCAPI_STATUS crypto_pka_selftest_pkcs1_rsassa_v15_sig(
		crypto_lib_handle *handle)
{
	u8_t pq[256] = {
	0xfb,0x2f,0x93,0x78,0xa9,0x2a,0x22,0x00,
	0x99,0x1b,0x4c,0x79,0xc1,0xf3,0x4c,0x95,
	0x34,0x00,0x2f,0xe2,0x5b,0x7b,0xf1,0xb3,
	0x77,0xcd,0xf7,0xe3,0x77,0x44,0xd2,0x3d,
	0xb7,0xd5,0x6c,0x50,0xe9,0x9e,0xe1,0x8a,
	0x38,0xab,0x36,0x5b,0x17,0xb9,0xa5,0x38,
	0xbc,0x74,0x1b,0x88,0xd3,0xe1,0xcc,0x57,
	0x94,0x1c,0xc0,0xb9,0x3d,0x43,0x55,0xee,

	0x3b,0x37,0x20,0xca,0x03,0x6f,0xf6,0xe3,
	0x40,0x12,0xb9,0xe5,0xc2,0x59,0xe0,0x01,
	0x1f,0xdb,0x80,0x91,0x09,0x81,0xee,0xe0,
	0x0a,0xdc,0x47,0x32,0x21,0x52,0xa4,0xab,
	0xa3,0x41,0x4a,0x7a,0xa2,0x21,0x04,0x9f,
	0xa7,0xab,0x95,0xfa,0xb9,0x96,0x25,0x9a,
	0xfa,0xa5,0xeb,0x28,0x9a,0x24,0xc4,0xd4,
	0xbd,0x5c,0x09,0x67,0x9a,0x05,0x3f,0xcf,

	0xe2,0x79,0x79,0x1a,0x03,0x1c,0x1d,0xb4,
	0xc0,0x03,0xcd,0x43,0xcd,0x63,0x4b,0x2b,
	0xed,0xc6,0xaf,0x25,0xae,0x7b,0x78,0x9b,
	0xde,0x69,0x07,0x68,0x91,0x0d,0xc1,0x95,
	0xc7,0x9c,0xc9,0xc7,0x03,0x01,0xda,0xcf,
	0xe1,0xbc,0x87,0x73,0xd9,0x5f,0x00,0x7e,
	0x7f,0x5f,0xc8,0x26,0x94,0xfe,0x9d,0x7a,
	0x54,0x8d,0x95,0x69,0x5f,0x6a,0x41,0xd5,

	0xa0,0xe7,0x5b,0x79,0x1e,0x91,0x16,0x8b,
	0x6a,0x17,0xf8,0x37,0xc7,0x0b,0x37,0xd7,
	0xb6,0xdd,0x16,0x2a,0x39,0xdb,0x08,0xa8,
	0x5a,0x33,0x7e,0x0c,0x28,0x46,0xaa,0x59,
	0x09,0xb6,0x75,0xd1,0xf4,0x9a,0xc3,0xb5,
	0x3c,0xf1,0xf1,0x6c,0x6a,0x6e,0x6c,0x73,
	0x95,0x32,0xd5,0x2a,0x5c,0x21,0xc5,0xfb,
	0x0f,0xad,0x03,0x47,0x40,0xd0,0x8a,0xf7
	};

	u8_t cleartext[32] = {
	0xf8,0x57,0xb4,0x41,0x69,0xa5,0xec,0xe1,
	0x60,0x37,0x86,0x5c,0x5d,0xf4,0x95,0x89,
	0xf8,0xa5,0x34,0xa6,0x38,0xd2,0x97,0x2c,
	0x09,0x34,0x72,0x46,0x03,0x8d,0x9e,0x4d
	};

	u8_t m[256] = {
	0xde,0x37,0x30,0x80,0x3b,0xf5,0x4e,0x38,
	0xfa,0x89,0xf8,0x6b,0x61,0x62,0x24,0x93,
	0xb3,0x80,0x97,0x25,0xaf,0x0c,0x4c,0x5e,
	0x6a,0x99,0x50,0x49,0x0a,0x61,0x5e,0x86,
	0xc2,0x4c,0x59,0x86,0x99,0xb4,0x6a,0x9d,
	0xbb,0xab,0x5b,0x96,0xa5,0x62,0x48,0x64,
	0x98,0xfd,0x6b,0x69,0x66,0x61,0x22,0x01,
	0x5b,0x38,0xbf,0x9b,0x82,0x40,0x86,0x3d,
	0x45,0x7c,0x5f,0x58,0xd7,0xca,0x76,0x45,
	0xdd,0x5d,0x2c,0x41,0xc6,0x6b,0x5a,0x7e,
	0x3d,0x8b,0x98,0x48,0xaf,0x75,0x83,0xb3,
	0xfe,0x3f,0x2c,0x6a,0x4e,0x00,0x9f,0xde,
	0x61,0x56,0x3d,0x2b,0xd8,0xf1,0xcd,0xca,
	0x09,0x43,0x8b,0x19,0x96,0x2e,0xed,0xb2,
	0x59,0x7c,0x29,0x8d,0x3d,0x61,0xc1,0x4c,
	0xfb,0x1f,0xb3,0x74,0x20,0xab,0x0c,0xfb,
	0x29,0x3e,0x80,0x1a,0x8d,0xc4,0xc2,0x76,
	0x22,0x4b,0xe5,0xd7,0xcd,0xeb,0x14,0x51,
	0x1a,0xbd,0xcb,0xdc,0xf5,0xbb,0x5a,0xbd,
	0x1e,0x73,0xb8,0xd8,0x6e,0x2b,0xdb,0xaf,
	0x7b,0x32,0x8d,0x30,0x5b,0xf3,0xf8,0x2b,
	0x43,0xf6,0x14,0xed,0xcf,0xea,0xa0,0xe6,
	0xe5,0xf5,0xec,0x00,0x14,0xdf,0xde,0x80,
	0x58,0xbe,0x8b,0xd4,0x09,0xd4,0x7e,0xa5,
	0x8a,0x14,0x0b,0x76,0xd0,0x39,0xc2,0xe5,
	0xb0,0xbf,0xc5,0x8c,0x55,0xd7,0x02,0xa3,
	0x55,0x3b,0x0b,0x81,0xb0,0xbf,0xe6,0x34,
	0x30,0x51,0xf3,0xfa,0xa7,0xee,0x87,0x05,
	0xf0,0x6f,0x46,0x6b,0xe5,0xe6,0x7f,0xf4,
	0x5a,0x9b,0x5c,0x80,0x9e,0xfc,0x07,0x89,
	0xaa,0x4e,0x09,0xfd,0x58,0x60,0x86,0x3f,
	0xe2,0xa4,0x7f,0x9d,0x07,0xa6,0x26,0xb9
	};

	u32_t exponent = 0x10001;
	u8_t h[64] __attribute__((aligned(64)));
	u8_t sig[256];
	u8_t pq_LE[256];
	u8_t my_m[256];
	u8_t my_sig[256];

	BCM_SCAPI_STATUS status;
	u32_t sigLen;

	/* we need cleartext to pass to verify and a sha2 hash
	 * of it to pass to sign
	 */
	status = crypto_symmetric_hmac_sha256(handle, cleartext,
				sizeof(cleartext), NULL, 0, h, TRUE);
	if (status != BCM_SCAPI_STATUS_OK) {
		printk("%s: hash fail status %d:\n",__func__,status);
		return BCM_SCAPI_STATUS_SELFTEST_RSA_FAIL;
	}

	/* reverse p and q into internal BIGNUM format.
	* This will also exchange P and Q, but that doesn't matter
	*/
	secure_memrev(pq_LE, pq, 256);

	/* generate the signature */
	status = crypto_pka_rsassa_pkcs1_v15_sign_hash(handle, 256,
				pq_LE, sizeof(h)/2, h, &sigLen, sig);

	secure_memcpy(my_sig, sig, sizeof(sig));
	secure_memrev(my_m, m, sizeof(m));

	/* test with verify */
	status = crypto_pka_rsassa_pkcs1_v15_verify(handle,
				sizeof(m), my_m,      /* modulus */
				4,(u8_t *)&exponent,
				/* message */
				sizeof(cleartext), cleartext,
				sigLen, my_sig,       /* signature */
				BCM_HASH_ALG_SHA2_256);
	if (status != BCM_SCAPI_STATUS_OK)
		return status;

	return status;
}

/*---------------------------------------------------------------
 * Name    : crypto_pka_selftest_pkcs1_rsassa_v15_verify
 * Purpose : Perform the FIPS selftest for PKCS#1 RSASSA-PKCS1-v1_5
 * 		signature verification
 * Input   : the crypto library handle
 * Return  : Appropriate status
 *           Note: the modulus and signature has been word swapped to PKA format
 *                 the msg has been endian swapped to little endian
 *--------------------------------------------------------------*/
BCM_SCAPI_STATUS crypto_pka_selftest_pkcs1_rsassa_v15_verify(
		crypto_lib_handle *pHandle)
{
	BCM_SCAPI_STATUS status;
	u32_t exponent = 0x00010001;
	u32_t tmp_RSAPKCS_Msg[128] = {0};
	u8_t* modulus;
	u32_t modulusSize;
	u32_t msgSize;
	u8_t* signature;
	u32_t signatureSize;

	/* 2048 bit operation with SHA256 hash */
	memcpy(tmp_RSAPKCS_Msg, RSA_PKCS_2048_SHA256_Msg,
			sizeof(RSA_PKCS_2048_SHA256_Msg));
	msgSize = sizeof(RSA_PKCS_2048_SHA256_Msg);

	modulus = (u8_t *)&RSA_PKCS_2048_SHA256_modulus[0];
	modulusSize = sizeof(RSA_PKCS_2048_SHA256_modulus);

	signature = (u8_t *)&RSA_PKCS_2048_SHA256_S[0];
	signatureSize = sizeof(RSA_PKCS_2048_SHA256_S);

	bcm_int2bignum(tmp_RSAPKCS_Msg, msgSize);

	status = crypto_pka_rsassa_pkcs1_v15_verify(pHandle,
				modulusSize, modulus,
				4, (u8_t *)&exponent,
				msgSize, (u8_t *)tmp_RSAPKCS_Msg,
				signatureSize, signature,
				BCM_HASH_ALG_SHA2_256);
	return status;
}

/* ***************************************************************************
 * Private Functions
 * ****************************************************************************/
